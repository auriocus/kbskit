diff -ru vtk5.10-orig/CMakeLists.txt vtk5.10/CMakeLists.txt
--- vtk5.10-orig/CMakeLists.txt	2019-02-01 14:00:04.000000000 +0100
+++ vtk5.10/CMakeLists.txt	2019-02-01 14:46:28.000000000 +0100
@@ -20,9 +20,6 @@
          OSX_SDK_VERSION "${CMAKE_OSX_SYSROOT}")
   SET(VTK_OBJCXX_FLAGS_DEFAULT)
   IF(OSX_SDK_VERSION)
-    IF(${OSX_SDK_VERSION} VERSION_GREATER "10.4")
-      SET(VTK_OBJCXX_FLAGS_DEFAULT "-fobjc-gc")
-    ENDIF(${OSX_SDK_VERSION} VERSION_GREATER "10.4")
   ENDIF(OSX_SDK_VERSION)
   SET(VTK_REQUIRED_OBJCXX_FLAGS ${VTK_OBJCXX_FLAGS_DEFAULT} CACHE STRING "Extra flags for Objective C compilation")
   MARK_AS_ADVANCED(VTK_REQUIRED_OBJCXX_FLAGS)
diff -ru vtk5.10-orig/Common/vtkTclUtil.cxx vtk5.10/Common/vtkTclUtil.cxx
--- vtk5.10-orig/Common/vtkTclUtil.cxx	2019-02-01 14:00:07.000000000 +0100
+++ vtk5.10/Common/vtkTclUtil.cxx	2019-02-01 14:23:39.000000000 +0100
@@ -490,13 +490,13 @@
       vtkGenericWarningMacro("Error returned from vtk/tcl callback:\n" <<
                              arg2->command << endl <<
                              Tcl_GetVar(arg2->interp,(char *)("errorInfo"),0) <<
-                             " at line number " << arg2->interp->errorLine);
+                             " at line number " << Tcl_GetErrorLine(arg2->interp));
       }
     else
       {
       vtkGenericWarningMacro("Error returned from vtk/tcl callback:\n" <<
                              arg2->command << endl <<
-                             " at line number " << arg2->interp->errorLine);
+                             " at line number " << Tcl_GetErrorLine(arg2->interp));
       }
     }
 }
@@ -723,14 +723,14 @@
       vtkGenericWarningMacro("Error returned from vtk/tcl callback:\n" <<
                              this->StringCommand << endl <<
                              Tcl_GetVar(this->Interp,(char *)("errorInfo"),0) <<
-                             " at line number " << this->Interp->errorLine);
+                             " at line number " << Tcl_GetErrorLine(this->Interp));
       }
     else
       {
       vtkGenericWarningMacro("Error returned from vtk/tcl callback:\n" <<
                              this->StringCommand << endl <<
                              " at line number " << 
-                             this->Interp->errorLine);
+                             Tcl_GetErrorLine(this->Interp));
       }
     }
   else if (res == -1)
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/default.h vtk5.10/Utilities/TclTk/internals/tk8.6/default.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/default.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/default.h	2019-02-01 16:20:04.000000000 +0100
@@ -1,29 +1,27 @@
 /*
  * default.h --
  *
- *  This file defines the defaults for all options for all of
- *  the Tk widgets.
+ *    This file defines the defaults for all options for all of
+ *    the Tk widgets.
  *
  * Copyright (c) 1991-1994 The Regents of the University of California.
  * Copyright (c) 1994 Sun Microsystems, Inc.
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _DEFAULT
 #define _DEFAULT
 
 #if defined(__WIN32__) || defined(_WIN32) || \
-    defined(__CYGWIN__) || defined(__MINGW32__)
+    defined(__MINGW32__)
 #   include "tkWinDefault.h"
 #else
 #   if defined(MAC_OSX_TK)
-#  include "tkMacOSXDefault.h"
+#       include "tkMacOSXDefault.h"
 #   else
-#  include "tkUnixDefault.h"
+#       include "tkUnixDefault.h"
 #   endif
 #endif
 
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclInt.h vtk5.10/Utilities/TclTk/internals/tk8.6/tclInt.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclInt.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tclInt.h	2019-02-01 16:20:04.000000000 +0100
@@ -14,15 +14,13 @@
  *
  * See the file "license.terms" for information on usage and redistribution of
  * this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TCLINT
 #define _TCLINT
 
 /*
- * Some numerics configuration options
+ * Some numerics configuration options.
  */
 
 #undef NO_WIDE_TYPE
@@ -37,21 +35,11 @@
  * declaration in tcl.h is needed by stdlib.h in some configurations.
  */
 
-#ifdef HAVE_TCL_CONFIG_H
-#include "tclConfig.h"
-#endif
-#ifndef _TCL
-#include "tcl.h"
-#endif
+#include "tclPort.h"
 
 #include <stdio.h>
 
 #include <ctype.h>
-#ifdef NO_LIMITS_H
-#   include "../compat/limits.h"
-#else
-#   include <limits.h>
-#endif
 #ifdef NO_STDLIB_H
 #   include "../compat/stdlib.h"
 #else
@@ -69,7 +57,7 @@
 #endif
 
 /*
- * Ensure WORDS_BIGENDIAN is defined correcly:
+ * Ensure WORDS_BIGENDIAN is defined correctly:
  * Needs to happen here in addition to configure to work with fat compiles on
  * Darwin (where configure runs only once for multiple architectures).
  */
@@ -164,13 +152,13 @@
 } Tcl_ResolvedVarInfo;
 
 typedef int (Tcl_ResolveCompiledVarProc)(Tcl_Interp *interp,
-  const char *name, int length, Tcl_Namespace *context,
+  CONST84 char *name, int length, Tcl_Namespace *context,
   Tcl_ResolvedVarInfo **rPtr);
 
-typedef int (Tcl_ResolveVarProc)(Tcl_Interp *interp, const char *name,
+typedef int (Tcl_ResolveVarProc)(Tcl_Interp *interp, CONST84 char *name,
   Tcl_Namespace *context, int flags, Tcl_Var *rPtr);
 
-typedef int (Tcl_ResolveCmdProc)(Tcl_Interp *interp, const char *name,
+typedef int (Tcl_ResolveCmdProc)(Tcl_Interp *interp, CONST84 char *name,
   Tcl_Namespace *context, int flags, Tcl_Command *rPtr);
 
 typedef struct Tcl_ResolverInfo {
@@ -215,6 +203,15 @@
     TclVarHashCreateVar((tablePtr), (key), NULL)
 
 /*
+ * Define this to reduce the amount of space that the average namespace
+ * consumes by only allocating the table of child namespaces when necessary.
+ * Defining it breaks compatibility for Tcl extensions (e.g., itcl) which
+ * reach directly into the Namespace structure.
+ */
+
+#undef BREAK_NAMESPACE_COMPAT
+
+/*
  * The structure below defines a namespace.
  * Note: the first five fields must match exactly the fields in a
  * Tcl_Namespace structure (see tcl.h). If you change one, be sure to change
@@ -236,8 +233,15 @@
     struct Namespace *parentPtr;/* Points to the namespace that contains this
          * one. NULL if this is the global
          * namespace. */
+#ifndef BREAK_NAMESPACE_COMPAT
     Tcl_HashTable childTable;  /* Contains any child namespaces. Indexed by
          * strings; values have type (Namespace *). */
+#else
+    Tcl_HashTable *childTablePtr;
+        /* Contains any child namespaces. Indexed by
+         * strings; values have type (Namespace *). If
+         * NULL, there are no children. */
+#endif
     long nsId;      /* Unique id for the namespace. */
     Tcl_Interp *interp;    /* The interpreter containing this
          * namespace. */
@@ -274,9 +278,9 @@
          * is currently allocated. */
     int cmdRefEpoch;    /* Incremented if a newly added command
          * shadows a command for which this namespace
-         * has already cached a Command * pointer;
-         * this causes all its cached Command*
-         * pointers to be invalidated. */
+         * has already cached a Command* pointer; this
+         * causes all its cached Command* pointers to
+         * be invalidated. */
     int resolverEpoch;    /* Incremented whenever (a) the name
          * resolution rules change for this namespace
          * or (b) a newly added command shadows a
@@ -322,6 +326,12 @@
     NamespacePathEntry *commandPathSourceList;
         /* Linked list of path entries that point to
          * this namespace. */
+    Tcl_NamespaceDeleteProc *earlyDeleteProc;
+        /* Just like the deleteProc field (and called
+         * with the same clientData) but called at the
+         * start of the deletion process, so there is
+         * a chance for code to do stuff inside the
+         * namespace before deletion completes. */
 } Namespace;
 
 /*
@@ -406,10 +416,91 @@
 } EnsembleCmdRep;
 
 /*
- * Flag to enable bytecode compilation of an ensemble.
+ * The client data for an ensemble command. This consists of the table of
+ * commands that are actually exported by the namespace, and an epoch counter
+ * that, combined with the exportLookupEpoch field of the namespace structure,
+ * defines whether the table contains valid data or will need to be recomputed
+ * next time the ensemble command is called.
+ */
+
+typedef struct EnsembleConfig {
+    Namespace *nsPtr;    /* The namspace backing this ensemble up. */
+    Tcl_Command token;    /* The token for the command that provides
+         * ensemble support for the namespace, or NULL
+         * if the command has been deleted (or never
+         * existed; the global namespace never has an
+         * ensemble command.) */
+    int epoch;      /* The epoch at which this ensemble's table of
+         * exported commands is valid. */
+    char **subcommandArrayPtr;  /* Array of ensemble subcommand names. At all
+         * consistent points, this will have the same
+         * number of entries as there are entries in
+         * the subcommandTable hash. */
+    Tcl_HashTable subcommandTable;
+        /* Hash table of ensemble subcommand names,
+         * which are its keys so this also provides
+         * the storage management for those subcommand
+         * names. The contents of the entry values are
+         * object version the prefix lists to use when
+         * substituting for the command/subcommand to
+         * build the ensemble implementation command.
+         * Has to be stored here as well as in
+         * subcommandDict because that field is NULL
+         * when we are deriving the ensemble from the
+         * namespace exports list. FUTURE WORK: use
+         * object hash table here. */
+    struct EnsembleConfig *next;/* The next ensemble in the linked list of
+         * ensembles associated with a namespace. If
+         * this field points to this ensemble, the
+         * structure has already been unlinked from
+         * all lists, and cannot be found by scanning
+         * the list from the namespace's ensemble
+         * field. */
+    int flags;      /* ORed combo of TCL_ENSEMBLE_PREFIX,
+         * ENSEMBLE_DEAD and ENSEMBLE_COMPILE. */
+
+    /* OBJECT FIELDS FOR ENSEMBLE CONFIGURATION */
+
+    Tcl_Obj *subcommandDict;  /* Dictionary providing mapping from
+         * subcommands to their implementing command
+         * prefixes, or NULL if we are to build the
+         * map automatically from the namespace
+         * exports. */
+    Tcl_Obj *subcmdList;  /* List of commands that this ensemble
+         * actually provides, and whose implementation
+         * will be built using the subcommandDict (if
+         * present and defined) and by simple mapping
+         * to the namespace otherwise. If NULL,
+         * indicates that we are using the (dynamic)
+         * list of currently exported commands. */
+    Tcl_Obj *unknownHandler;  /* Script prefix used to handle the case when
+         * no match is found (according to the rule
+         * defined by flag bit TCL_ENSEMBLE_PREFIX) or
+         * NULL to use the default error-generating
+         * behaviour. The script execution gets all
+         * the arguments to the ensemble command
+         * (including objv[0]) and will have the
+         * results passed directly back to the caller
+         * (including the error code) unless the code
+         * is TCL_CONTINUE in which case the
+         * subcommand will be reparsed by the ensemble
+         * core, presumably because the ensemble
+         * itself has been updated. */
+    Tcl_Obj *parameterList;  /* List of ensemble parameter names. */
+    int numParameters;    /* Cached number of parameters. This is either
+         * 0 (if the parameterList field is NULL) or
+         * the length of the list in the parameterList
+         * field. */
+} EnsembleConfig;
+
+/*
+ * Various bits for the EnsembleConfig.flags field.
  */
 
-#define ENSEMBLE_COMPILE 0x4
+#define ENSEMBLE_DEAD  0x1  /* Flag value to say that the ensemble is dead
+         * and on its way out. */
+#define ENSEMBLE_COMPILE 0x4  /* Flag to enable bytecode compilation of an
+         * ensemble. */
 
 /*
  *----------------------------------------------------------------
@@ -654,7 +745,7 @@
 #define VAR_ALL_HASH \
   (VAR_IN_HASHTABLE|VAR_DEAD_HASH|VAR_NAMESPACE_VAR|VAR_ARRAY_ELEMENT)
 
-/* Trace and search state */
+/* Trace and search state. */
 
 #define VAR_TRACED_READ    0x10  /* TCL_TRACE_READS */
 #define VAR_TRACED_WRITE  0x20  /* TCL_TRACE_WRITES */
@@ -665,7 +756,7 @@
 #define VAR_ALL_TRACES \
   (VAR_TRACED_READ|VAR_TRACED_WRITE|VAR_TRACED_ARRAY|VAR_TRACED_UNSET)
 
-/* Special handling on initialisation (only CompiledLocal) */
+/* Special handling on initialisation (only CompiledLocal). */
 #define VAR_ARGUMENT    0x100  /* KEEP OLD VALUE! See tclProc.c */
 #define VAR_TEMPORARY    0x200  /* KEEP OLD VALUE! See tclProc.c */
 #define VAR_IS_ARGS    0x400
@@ -710,13 +801,17 @@
 #define TclSetVarNamespaceVar(varPtr) \
     if (!TclIsVarNamespaceVar(varPtr)) {\
   (varPtr)->flags |= VAR_NAMESPACE_VAR;\
-  ((VarInHash *)(varPtr))->refCount++;\
+  if (TclIsVarInHash(varPtr)) {\
+      ((VarInHash *)(varPtr))->refCount++;\
+  }\
     }
 
 #define TclClearVarNamespaceVar(varPtr) \
     if (TclIsVarNamespaceVar(varPtr)) {\
   (varPtr)->flags &= ~VAR_NAMESPACE_VAR;\
-  ((VarInHash *)(varPtr))->refCount--;\
+  if (TclIsVarInHash(varPtr)) {\
+      ((VarInHash *)(varPtr))->refCount--;\
+  }\
     }
 
 /*
@@ -781,7 +876,7 @@
     ((VarInHash *) (varPtr))->refCount
 
 /*
- * Macros for direct variable access by TEBC
+ * Macros for direct variable access by TEBC.
  */
 
 #define TclIsVarDirectReadable(varPtr) \
@@ -791,6 +886,9 @@
 #define TclIsVarDirectWritable(varPtr) \
     !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_WRITE|VAR_DEAD_HASH))
 
+#define TclIsVarDirectUnsettable(varPtr) \
+    !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ|VAR_TRACED_WRITE|VAR_TRACED_UNSET|VAR_DEAD_HASH))
+
 #define TclIsVarDirectModifyable(varPtr) \
     (   !((varPtr)->flags & (VAR_ARRAY|VAR_LINK|VAR_TRACED_READ|VAR_TRACED_WRITE)) \
     &&  (varPtr)->value.objPtr)
@@ -858,7 +956,7 @@
          * is marked by a unique ClientData tag during
          * compilation, and that same tag is used to
          * find the variable at runtime. */
-    char name[4];    /* Name of the local variable starts here. If
+    char name[1];    /* Name of the local variable starts here. If
          * the name is NULL, this will just be '\0'.
          * The actual size of this field will be large
          * enough to hold the name. MUST BE THE LAST
@@ -919,9 +1017,9 @@
     ClientData clientData;  /* Arbitrary value to pass to proc. */
     struct Trace *nextPtr;  /* Next in list of traces for this interp. */
     int flags;      /* Flags governing the trace - see
-         * Tcl_CreateObjTrace for details */
+         * Tcl_CreateObjTrace for details. */
     Tcl_CmdObjTraceDeleteProc *delProc;
-        /* Procedure to call when trace is deleted */
+        /* Procedure to call when trace is deleted. */
 } Trace;
 
 /*
@@ -954,8 +1052,8 @@
  * TCL_TRACE_LEAVE_EXEC    - triggers leave/leavestep traces.
  *         - passed to Tcl_CreateObjTrace to set up
  *          "leavestep" traces.
- *
  */
+
 #define TCL_TRACE_ENTER_EXEC  1
 #define TCL_TRACE_LEAVE_EXEC  2
 
@@ -1056,6 +1154,8 @@
          * meaning of the value is, which we do not
          * specify. */
     LocalCache *localCachePtr;
+    struct NRE_callback *tailcallPtr;
+        /* NULL if no tailcall is scheduled */
 } CallFrame;
 
 #define FRAME_IS_PROC  0x1
@@ -1093,16 +1193,13 @@
      */
 
     int type;      /* Values see below. */
-    int level;      /* #Frames in stack, prevent O(n) scan of
-         * list. */
-    int numLevels;    /* value of interp's numLevels when the frame
-         * was pushed */
+    int level;      /* Number of frames in stack, prevent O(n)
+         * scan of list. */
     int *line;      /* Lines the words of the command start on. */
     int nline;
     CallFrame *framePtr;  /* Procedure activation record, may be
          * NULL. */
-    struct CmdFrame *nextPtr;  /* Link to calling frame */
-
+    struct CmdFrame *nextPtr;  /* Link to calling frame. */
     /*
      * Data needed for Eval vs TEBC
      *
@@ -1139,40 +1236,77 @@
          * in. */
   } eval;
   struct {
-      const void *codePtr;/* Byte code currently executed */
-      const char *pc;  /* and instruction pointer. */
+      const void *codePtr;/* Byte code currently executed... */
+      const char *pc;  /* ... and instruction pointer. */
   } tebc;
     } data;
     union {
   struct {
-      const char *cmd;  /* The executed command, if possible */
-      int len;    /* And its length */
+      const char *cmd;  /* The executed command, if possible... */
+      int len;    /* ... and its length. */
   } str;
-  Tcl_Obj *listPtr;  /* Tcl_EvalObjEx, cmd list */
+  Tcl_Obj *listPtr;  /* Tcl_EvalObjEx, cmd list. */
     } cmd;
+    int numLevels;    /* Value of interp's numLevels when the frame
+         * was pushed. */
+    const struct CFWordBC *litarg;
+        /* Link to set of literal arguments which have
+         * ben pushed on the lineLABCPtr stack by
+         * TclArgumentBCEnter(). These will be removed
+         * by TclArgumentBCRelease. */
 } CmdFrame;
 
 typedef struct CFWord {
-    CmdFrame *framePtr;    /* CmdFrame to acess */
-    int word;      /* Index of the word in the command */
-    int refCount;    /* #times the word is on the stack */
+    CmdFrame *framePtr;    /* CmdFrame to access. */
+    int word;      /* Index of the word in the command. */
+    int refCount;    /* Number of times the word is on the
+         * stack. */
 } CFWord;
 
-typedef struct ExtIndex {
-    Tcl_Obj *obj;    /* Reference to the word */
+typedef struct CFWordBC {
+    CmdFrame *framePtr;    /* CmdFrame to access. */
     int pc;      /* Instruction pointer of a command in
          * ExtCmdLoc.loc[.] */
     int word;      /* Index of word in
          * ExtCmdLoc.loc[cmd]->line[.] */
-} ExtIndex;
-
-typedef struct CFWordBC {
-    CmdFrame *framePtr;    /* CmdFrame to acess */
-    ExtIndex *eiPtr;    /* Word info: PC and index */
-    int refCount;    /* #times the word is on the stack */
+    struct CFWordBC *prevPtr;  /* Previous entry in stack for same Tcl_Obj. */
+    struct CFWordBC *nextPtr;  /* Next entry for same command call. See
+         * CmdFrame litarg field for the list start. */
+    Tcl_Obj *obj;    /* Back reference to hashtable key */
 } CFWordBC;
 
 /*
+ * Structure to record the locations of invisible continuation lines in
+ * literal scripts, as character offset from the beginning of the script. Both
+ * compiler and direct evaluator use this information to adjust their line
+ * counters when tracking through the script, because when it is invoked the
+ * continuation line marker as a whole has been removed already, meaning that
+ * the \n which was part of it is gone as well, breaking regular line
+ * tracking.
+ *
+ * These structures are allocated and filled by both the function
+ * TclSubstTokens() in the file "tclParse.c" and its caller TclEvalEx() in the
+ * file "tclBasic.c", and stored in the thread-global hashtable "lineCLPtr" in
+ * file "tclObj.c". They are used by the functions TclSetByteCodeFromAny() and
+ * TclCompileScript(), both found in the file "tclCompile.c". Their memory is
+ * released by the function TclFreeObj(), in the file "tclObj.c", and also by
+ * the function TclThreadFinalizeObjects(), in the same file.
+ */
+
+#define CLL_END    (-1)
+
+typedef struct ContLineLoc {
+    int num;      /* Number of entries in loc, not counting the
+         * final -1 marker entry. */
+    int loc[1];      /* Table of locations, as character offsets.
+         * The table is allocated as part of the
+         * structure, extending behind the nominal end
+         * of the structure. An entry containing the
+         * value -1 is put after the last location, as
+         * end-marker/sentinel. */
+} ContLineLoc;
+
+/*
  * The following macros define the allowed values for the type field of the
  * CmdFrame structure above. Some of the values occur only in the extended
  * location data referenced via the 'baseLocPtr'.
@@ -1190,15 +1324,15 @@
  * types, per the context of the byte code in execution.
  */
 
-#define TCL_LOCATION_EVAL  (0) /* Location in a dynamic eval script */
+#define TCL_LOCATION_EVAL  (0) /* Location in a dynamic eval script. */
 #define TCL_LOCATION_EVAL_LIST  (1) /* Location in a dynamic eval script,
-             * list-path */
-#define TCL_LOCATION_BC    (2) /* Location in byte code */
+             * list-path. */
+#define TCL_LOCATION_BC    (2) /* Location in byte code. */
 #define TCL_LOCATION_PREBC  (3) /* Location in precompiled byte code, no
-             * location */
-#define TCL_LOCATION_SOURCE  (4) /* Location in a file */
-#define TCL_LOCATION_PROC  (5) /* Location in a dynamic proc */
-#define TCL_LOCATION_LAST  (6) /* Number of values in the enum */
+             * location. */
+#define TCL_LOCATION_SOURCE  (4) /* Location in a file. */
+#define TCL_LOCATION_PROC  (5) /* Location in a dynamic proc. */
+#define TCL_LOCATION_LAST  (6) /* Number of values in the enum. */
 
 /*
  * Structure passed to describe procedure-like "procedures" that are not
@@ -1206,10 +1340,10 @@
  * by [info frame]. Contains a sub-structure for each extra field.
  */
 
-typedef Tcl_Obj *(*GetFrameInfoValueProc)(ClientData clientData);
+typedef Tcl_Obj * (GetFrameInfoValueProc)(ClientData clientData);
 typedef struct {
     const char *name;    /* Name of this field. */
-    GetFrameInfoValueProc proc;  /* Function to generate a Tcl_Obj* from the
+    GetFrameInfoValueProc *proc;  /* Function to generate a Tcl_Obj* from the
          * clientData, or just use the clientData
          * directly (after casting) if NULL. */
     ClientData clientData;  /* Context for above function, or Tcl_Obj* if
@@ -1331,31 +1465,39 @@
 typedef struct CorContext {
     struct CallFrame *framePtr;
     struct CallFrame *varFramePtr;
-    struct CmdFrame *cmdFramePtr;
+    struct CmdFrame *cmdFramePtr;  /* See Interp.cmdFramePtr */
+    Tcl_HashTable *lineLABCPtr;    /* See Interp.lineLABCPtr */
 } CorContext;
 
 typedef struct CoroutineData {
-    struct Command *cmdPtr;
-    struct ExecEnv *eePtr;
-    struct ExecEnv *callerEEPtr;
+    struct Command *cmdPtr;  /* The command handle for the coroutine. */
+    struct ExecEnv *eePtr;  /* The special execution environment (stacks,
+         * etc.) for the coroutine. */
+    struct ExecEnv *callerEEPtr;/* The execution environment for the caller of
+         * the coroutine, which might be the
+         * interpreter global environment or another
+         * coroutine. */
     CorContext caller;
     CorContext running;
-    CorContext base;
-    int *stackLevel;
-    int auxNumLevels;  /* While the coroutine is running the numLevels of the
-      * create/resume command is stored here; for suspended
-      * coroutines it holds the nesting numLevels at yield*/
+    Tcl_HashTable *lineLABCPtr;    /* See Interp.lineLABCPtr */
+    void *stackLevel;
+    int auxNumLevels;    /* While the coroutine is running the
+         * numLevels of the create/resume command is
+         * stored here; for suspended coroutines it
+         * holds the nesting numLevels at yield. */
+    int nargs;                  /* Number of args required for resuming this
+         * coroutine; -2 means "0 or 1" (default), -1
+         * means "any" */
 } CoroutineData;
 
 typedef struct ExecEnv {
     ExecStack *execStackPtr;  /* Points to the first item in the evaluation
          * stack on the heap. */
-    Tcl_Obj *constants[2];  /* Pointers to constant "0" and "1" objs. */ 
+    Tcl_Obj *constants[2];  /* Pointers to constant "0" and "1" objs. */
     struct Tcl_Interp *interp;
-    struct TEOV_callback *callbackPtr;
-        /* Top callback in TEOV's stack */
+    struct NRE_callback *callbackPtr;
+        /* Top callback in NRE's stack. */
     struct CoroutineData *corPtr;
-    struct BottomData *bottomPtr;
     int rewind;
 } ExecEnv;
 
@@ -1451,14 +1593,18 @@
 
 /*
  * Structure used in implementation of those core ensembles which are
- * partially compiled.
+ * partially compiled. Used as an array of these, with a terminating field
+ * whose 'name' is NULL.
  */
 
 typedef struct {
     const char *name;    /* The name of the subcommand. */
     Tcl_ObjCmdProc *proc;  /* The implementation of the subcommand. */
     CompileProc *compileProc;  /* The compiler for the subcommand. */
-    Tcl_ObjCmdProc *nreProc;  /* NRE implementation of this command */
+    Tcl_ObjCmdProc *nreProc;  /* NRE implementation of this command. */
+    ClientData clientData;  /* Any clientData to give the command. */
+    int unsafe;      /* Whether this command is to be hidden by
+         * default in a safe interpreter. */
 } EnsembleImplMap;
 
 /*
@@ -1551,7 +1697,7 @@
          * command. */
     CommandTrace *tracePtr;  /* First in list of all traces set for this
          * command. */
-    Tcl_ObjCmdProc *nreProc;    /* NRE implementation of this command */
+    Tcl_ObjCmdProc *nreProc;  /* NRE implementation of this command. */
 } Command;
 
 /*
@@ -1637,10 +1783,10 @@
  */
 
 typedef struct AllocCache {
-    struct Cache *nextPtr;  /* Linked list of cache entries */
+    struct Cache *nextPtr;  /* Linked list of cache entries. */
     Tcl_ThreadId owner;    /* Which thread's cache is this? */
-    Tcl_Obj *firstObjPtr;  /* List of free objects for thread */
-    int numObjects;    /* Number of objects for thread */
+    Tcl_Obj *firstObjPtr;  /* List of free objects for thread. */
+    int numObjects;    /* Number of objects for thread. */
 } AllocCache;
 
 /*
@@ -1725,10 +1871,11 @@
     ActiveVarTrace *activeVarTracePtr;
         /* First in list of active traces for interp,
          * or NULL if no active traces. */
-    int returnCode;    /* [return -code] parameter */
-    CallFrame *rootFramePtr;  /* Global frame pointer for this interpreter */
+    int returnCode;    /* [return -code] parameter. */
+    CallFrame *rootFramePtr;  /* Global frame pointer for this
+         * interpreter. */
     Namespace *lookupNsPtr;  /* Namespace to use ONLY on the next
-         * TCL_EVAL_INVOKE call to Tcl_EvalObjv */
+         * TCL_EVAL_INVOKE call to Tcl_EvalObjv. */
 
     /*
      * Information used by Tcl_AppendResult to keep track of partial results.
@@ -1808,7 +1955,7 @@
     Tcl_Obj *objResultPtr;  /* If the last command returned an object
          * result, this points to it. Should not be
          * accessed directly; see comment above. */
-    Tcl_ThreadId threadId;  /* ID of thread that owns the interpreter */
+    Tcl_ThreadId threadId;  /* ID of thread that owns the interpreter. */
 
     ActiveCommandTrace *activeCmdTracePtr;
         /* First in list of active command traces for
@@ -1817,19 +1964,22 @@
         /* First in list of active traces for interp,
          * or NULL if no active traces. */
 
-    int tracesForbiddingInline; /* Count of traces (in the list headed by
+    int tracesForbiddingInline;  /* Count of traces (in the list headed by
          * tracePtr) that forbid inline bytecode
-         * compilation */
+         * compilation. */
+
+    /*
+     * Fields used to manage extensible return options (TIP 90).
+     */
 
-    /* Fields used to manage extensible return options (TIP 90) */
     Tcl_Obj *returnOpts;  /* A dictionary holding the options to the
-         * last [return] command */
+         * last [return] command. */
 
-    Tcl_Obj *errorInfo;    /* errorInfo value (now as a Tcl_Obj) */
-    Tcl_Obj *eiVar;    /* cached ref to ::errorInfo variable */
-    Tcl_Obj *errorCode;    /* errorCode value (now as a Tcl_Obj) */
-    Tcl_Obj *ecVar;    /* cached ref to ::errorInfo variable */
-    int returnLevel;    /* [return -level] parameter */
+    Tcl_Obj *errorInfo;    /* errorInfo value (now as a Tcl_Obj). */
+    Tcl_Obj *eiVar;    /* cached ref to ::errorInfo variable. */
+    Tcl_Obj *errorCode;    /* errorCode value (now as a Tcl_Obj). */
+    Tcl_Obj *ecVar;    /* cached ref to ::errorInfo variable. */
+    int returnLevel;    /* [return -level] parameter. */
 
     /*
      * Resource limiting framework support (TIP#143).
@@ -1887,7 +2037,7 @@
     } ensembleRewrite;
 
     /*
-     * TIP #219 ... Global info for the I/O system ...
+     * TIP #219: Global info for the I/O system.
      */
 
     Tcl_Obj *chanMsg;    /* Error message set by channel drivers, for
@@ -1897,19 +2047,9 @@
          * code returned by a channel operation. */
 
     /*
-     * TIP #285, Script cancellation support.
+     * Source code origin information (TIP #280).
      */
 
-    Tcl_AsyncHandler asyncCancel;
-        /* Async handler token for Tcl_CancelEval. */
-    Tcl_Obj *asyncCancelMsg;  /* Error message set by async cancel handler
-         * for the propagation of arbitrary Tcl
-         * errors. This information, if present
-         * (asyncCancelMsg not NULL), takes precedence
-         * over the default error messages returned by
-         * a script cancellation operation. */
-
-    /* TIP #280 */
     CmdFrame *cmdFramePtr;  /* Points to the command frame containing the
          * location information for the current
          * command. */
@@ -1945,6 +2085,15 @@
          * invoking command. Alt view: An index to the
          * CmdFrame stack keyed by command argument
          * holders. */
+    ContLineLoc *scriptCLLocPtr;/* This table points to the location data for
+         * invisible continuation lines in the script,
+         * if any. This pointer is set by the function
+         * TclEvalObjEx() in file "tclBasic.c", and
+         * used by function ...() in the same file.
+         * It does for the eval/direct path of script
+         * execution what CompileEnv.clLoc does for
+         * the bytecode compiler.
+         */
     /*
      * TIP #268. The currently active selection mode, i.e. the package require
      * preferences.
@@ -1953,13 +2102,13 @@
     int packagePrefer;    /* Current package selection mode. */
 
     /*
-     * Hashtables for variable traces and searches
+     * Hashtables for variable traces and searches.
      */
 
     Tcl_HashTable varTraces;  /* Hashtable holding the start of a variable's
          * active trace list; varPtr is the key. */
     Tcl_HashTable varSearches;  /* Hashtable holding the start of a variable's
-         * active searches list; varPtr is the key */
+         * active searches list; varPtr is the key. */
     /*
      * The thread-specific data ekeko: cache pointers or values that
      *  (a) do not change during the thread's lifetime
@@ -1979,26 +2128,49 @@
          * tclObj.c and tclThreadAlloc.c */
     int *asyncReadyPtr;    /* Pointer to the asyncReady indicator for
          * this interp's thread; see tclAsync.c */
-
     /*
      * The pointer to the object system root ekeko. c.f. TIP #257.
      */
-
     void *objectFoundation;  /* Pointer to the Foundation structure of the
          * object system, which contains things like
          * references to key namespaces. See
          * tclOOInt.h and tclOO.c for real definition
          * and setup. */
 
-    struct TEOV_callback *atExitPtr;
-        /* Callbacks to be run after a command exited;
-         * this is only set for atProcExirt or
-         * tailcalls that fall back out of tebc. */
-    
+    struct NRE_callback *deferredCallbacks;
+        /* Callbacks that are set previous to a call
+         * to some Eval function but that actually
+         * belong to the command that is about to be
+         * called - i.e., they should be run *before*
+         * any tailcall is invoked. */
+
+    /*
+     * TIP #285, Script cancellation support.
+     */
+
+    Tcl_AsyncHandler asyncCancel;
+        /* Async handler token for Tcl_CancelEval. */
+    Tcl_Obj *asyncCancelMsg;  /* Error message set by async cancel handler
+         * for the propagation of arbitrary Tcl
+         * errors. This information, if present
+         * (asyncCancelMsg not NULL), takes precedence
+         * over the default error messages returned by
+         * a script cancellation operation. */
+
+  /*
+   * TIP #348 IMPLEMENTATION  -  Substituted error stack
+   */
+    Tcl_Obj *errorStack;  /* [info errorstack] value (as a Tcl_Obj). */
+    Tcl_Obj *upLiteral;    /* "UP" literal for [info errorstack] */
+    Tcl_Obj *callLiteral;  /* "CALL" literal for [info errorstack] */
+    Tcl_Obj *innerLiteral;  /* "INNER" literal for [info errorstack] */
+    Tcl_Obj *innerContext;  /* cached list for fast reallocation */
+    int resetErrorStack;        /* controls cleaning up of ::errorStack */
+
 #ifdef TCL_COMPILE_STATS
     /*
      * Statistical information about the bytecode compiler and interpreter's
-     * operation.
+     * operation. This should be the last field of Interp.
      */
 
     ByteCodeStats stats;  /* Holds compilation and execution statistics
@@ -2014,6 +2186,22 @@
     *((iPtr)->asyncReadyPtr)
 
 /*
+ * Macros for script cancellation support (TIP #285).
+ */
+
+#define TclCanceled(iPtr) \
+    (((iPtr)->flags & CANCELED) || ((iPtr)->flags & TCL_CANCEL_UNWIND))
+
+#define TclSetCancelFlags(iPtr, cancelFlags)   \
+    (iPtr)->flags |= CANCELED;                 \
+    if ((cancelFlags) & TCL_CANCEL_UNWIND) {   \
+        (iPtr)->flags |= TCL_CANCEL_UNWIND;    \
+    }
+
+#define TclUnsetCancelFlags(iPtr) \
+    (iPtr)->flags &= (~(CANCELED | TCL_CANCEL_UNWIND))
+
+/*
  * General list of interpreters. Doubly linked for easier removal of items
  * deep in the list.
  */
@@ -2062,6 +2250,7 @@
 #define TCL_ALLOW_EXCEPTIONS  4
 #define TCL_EVAL_FILE    2
 #define TCL_EVAL_CTX    8
+#define TCL_EVAL_REDIRECT  16
 
 /*
  * Flag bits for Interp structures:
@@ -2084,6 +2273,9 @@
  * SAFE_INTERP:    Non zero means that the current interp is a safe
  *      interp (i.e. it has only the safe commands installed,
  *      less priviledge than a regular interp).
+ * INTERP_DEBUG_FRAME:  Used for switching on various extra interpreter
+ *      debug/info mechanisms (e.g. info frame eval/uplevel
+ *      tracing) which are performance intensive.
  * INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
  *      active; so no further trace callbacks should be
  *      invoked.
@@ -2109,6 +2301,7 @@
 
 #define DELETED             1
 #define ERR_ALREADY_LOGGED         4
+#define INTERP_DEBUG_FRAME      0x10
 #define DONT_COMPILE_CMDS_INLINE    0x20
 #define RAND_SEED_INITIALIZED      0x40
 #define SAFE_INTERP        0x80
@@ -2134,9 +2327,10 @@
         /* The handler callback. */
     ClientData clientData;  /* Opaque argument to the handler callback. */
     Tcl_LimitHandlerDeleteProc *deleteProc;
-        /* How to delete the clientData */
-    LimitHandler *prevPtr;  /* Previous item in linked list of handlers */
-    LimitHandler *nextPtr;  /* Next item in linked list of handlers */
+        /* How to delete the clientData. */
+    LimitHandler *prevPtr;  /* Previous item in linked list of
+         * handlers. */
+    LimitHandler *nextPtr;  /* Next item in linked list of handlers. */
 };
 
 /*
@@ -2162,7 +2356,7 @@
 
 /*
  * This macro is used to properly align the memory allocated by Tcl, giving
- * the same alignment as the native malloc
+ * the same alignment as the native malloc.
  */
 
 #if defined(__APPLE__)
@@ -2202,7 +2396,7 @@
 /*
  * The following enum values are used to indicate the translation of a Tcl
  * channel. Declared here so that each platform can define
- * TCL_PLATFORM_TRANSLATION to the native translation on that platform
+ * TCL_PLATFORM_TRANSLATION to the native translation on that platform.
  */
 
 typedef enum TclEolTranslation {
@@ -2251,6 +2445,11 @@
          * accomodate all elements. */
 } List;
 
+#define LIST_MAX \
+  (1 + (int)(((size_t)UINT_MAX - sizeof(List))/sizeof(Tcl_Obj *)))
+#define LIST_SIZE(numElems) \
+  (unsigned)(sizeof(List) + (((numElems) - 1) * sizeof(Tcl_Obj *)))
+
 /*
  * Macro used to get the elements of a list object.
  */
@@ -2258,6 +2457,12 @@
 #define ListRepPtr(listPtr) \
     ((List *) (listPtr)->internalRep.twoPtrValue.ptr1)
 
+#define ListSetIntRep(objPtr, listRepPtr) \
+    (objPtr)->internalRep.twoPtrValue.ptr1 = (void *)(listRepPtr), \
+    (objPtr)->internalRep.twoPtrValue.ptr2 = NULL, \
+    (listRepPtr)->refCount++, \
+    (objPtr)->typePtr = &tclListType
+
 #define ListObjGetElements(listPtr, objc, objv) \
     ((objv) = &(ListRepPtr(listPtr)->elements), \
      (objc) = ListRepPtr(listPtr)->elemCount)
@@ -2265,6 +2470,9 @@
 #define ListObjLength(listPtr, len) \
     ((len) = ListRepPtr(listPtr)->elemCount)
 
+#define ListObjIsCanonical(listPtr) \
+    (((listPtr)->bytes == NULL) || ListRepPtr(listPtr)->canonicalFlag)
+
 #define TclListObjGetElements(interp, listPtr, objcPtr, objvPtr) \
     (((listPtr)->typePtr == &tclListType) \
       ? ((ListObjGetElements((listPtr), *(objcPtr), *(objvPtr))), TCL_OK)\
@@ -2275,6 +2483,17 @@
       ? ((ListObjLength((listPtr), *(lenPtr))), TCL_OK)\
       : Tcl_ListObjLength((interp), (listPtr), (lenPtr)))
 
+#define TclListObjIsCanonical(listPtr) \
+    (((listPtr)->typePtr == &tclListType) ? ListObjIsCanonical((listPtr)) : 0)
+
+/*
+ * Modes for collecting (or not) in the implementations of TclNRForeachCmd,
+ * TclNRLmapCmd and their compilations.
+ */
+
+#define TCL_EACH_KEEP_NONE  0  /* Discard iteration result like [foreach] */
+#define TCL_EACH_COLLECT    1  /* Collect iteration result like [lmap] */
+
 /*
  * Macros providing a faster path to integers: Tcl_GetLongFromObj everywhere,
  * Tcl_GetIntFromObj and TclGetIntForIndex on platforms where longs are ints.
@@ -2345,6 +2564,8 @@
 
 #define TCL_FILESYSTEM_VERSION_2  ((Tcl_FSVersion) 0x2)
 typedef ClientData (TclFSGetCwdProc2)(ClientData clientData);
+typedef int (Tcl_FSLoadFileProc2) (Tcl_Interp *interp, Tcl_Obj *pathPtr,
+  Tcl_LoadHandle *handlePtr, Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
 
 /*
  * The following types are used for getting and storing platform-specific file
@@ -2449,17 +2670,21 @@
  */
 
 #define TCL_PARSE_DECIMAL_ONLY    1
-        /* Leading zero doesn't denote octal or hex */
+        /* Leading zero doesn't denote octal or
+         * hex. */
 #define TCL_PARSE_OCTAL_ONLY    2
-        /* Parse octal even without prefix */
+        /* Parse octal even without prefix. */
 #define TCL_PARSE_HEXADECIMAL_ONLY  4
-        /* Parse hexadecimal even without prefix */
+        /* Parse hexadecimal even without prefix. */
 #define TCL_PARSE_INTEGER_ONLY    8
-        /* Disable floating point parsing */
+        /* Disable floating point parsing. */
 #define TCL_PARSE_SCAN_PREFIXES    16
-        /* Use [scan] rules dealing with 0? prefixes */
+        /* Use [scan] rules dealing with 0?
+         * prefixes. */
 #define TCL_PARSE_NO_WHITESPACE    32
-        /* Reject leading/trailing whitespace */
+        /* Reject leading/trailing whitespace. */
+#define TCL_PARSE_BINARY_ONLY  64
+        /* Parse binary even without prefix. */
 
 /*
  *----------------------------------------------------------------------
@@ -2498,32 +2723,33 @@
  * Variables denoting the Tcl object types defined in the core.
  */
 
-MODULE_SCOPE Tcl_ObjType tclBignumType;
-MODULE_SCOPE Tcl_ObjType tclBooleanType;
-MODULE_SCOPE Tcl_ObjType tclByteArrayType;
-MODULE_SCOPE Tcl_ObjType tclByteCodeType;
-MODULE_SCOPE Tcl_ObjType tclDoubleType;
-MODULE_SCOPE Tcl_ObjType tclEndOffsetType;
-MODULE_SCOPE Tcl_ObjType tclIntType;
-MODULE_SCOPE Tcl_ObjType tclListType;
-MODULE_SCOPE Tcl_ObjType tclDictType;
-MODULE_SCOPE Tcl_ObjType tclProcBodyType;
-MODULE_SCOPE Tcl_ObjType tclStringType;
-MODULE_SCOPE Tcl_ObjType tclArraySearchType;
-MODULE_SCOPE Tcl_ObjType tclEnsembleCmdType;
+MODULE_SCOPE const Tcl_ObjType tclBignumType;
+MODULE_SCOPE const Tcl_ObjType tclBooleanType;
+MODULE_SCOPE const Tcl_ObjType tclByteArrayType;
+MODULE_SCOPE const Tcl_ObjType tclByteCodeType;
+MODULE_SCOPE const Tcl_ObjType tclDoubleType;
+MODULE_SCOPE const Tcl_ObjType tclEndOffsetType;
+MODULE_SCOPE const Tcl_ObjType tclIntType;
+MODULE_SCOPE const Tcl_ObjType tclListType;
+MODULE_SCOPE const Tcl_ObjType tclDictType;
+MODULE_SCOPE const Tcl_ObjType tclProcBodyType;
+MODULE_SCOPE const Tcl_ObjType tclStringType;
+MODULE_SCOPE const Tcl_ObjType tclArraySearchType;
+MODULE_SCOPE const Tcl_ObjType tclEnsembleCmdType;
 #ifndef NO_WIDE_TYPE
-MODULE_SCOPE Tcl_ObjType tclWideIntType;
+MODULE_SCOPE const Tcl_ObjType tclWideIntType;
 #endif
-MODULE_SCOPE Tcl_ObjType tclRegexpType;
+MODULE_SCOPE const Tcl_ObjType tclRegexpType;
+MODULE_SCOPE Tcl_ObjType tclCmdNameType;
 
 /*
  * Variables denoting the hash key types defined in the core.
  */
 
-MODULE_SCOPE Tcl_HashKeyType tclArrayHashKeyType;
-MODULE_SCOPE Tcl_HashKeyType tclOneWordHashKeyType;
-MODULE_SCOPE Tcl_HashKeyType tclStringHashKeyType;
-MODULE_SCOPE Tcl_HashKeyType tclObjHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclArrayHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclOneWordHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclStringHashKeyType;
+MODULE_SCOPE const Tcl_HashKeyType tclObjHashKeyType;
 
 /*
  * The head of the list of free Tcl objects, and the total number of Tcl
@@ -2555,19 +2781,95 @@
  *----------------------------------------------------------------
  */
 
-MODULE_SCOPE Tcl_ObjCmdProc TclNRNamespaceObjCmd;
 MODULE_SCOPE Tcl_ObjCmdProc TclNRApplyObjCmd;
-MODULE_SCOPE Tcl_ObjCmdProc TclNRUplevelObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNREvalObjCmd;
 MODULE_SCOPE Tcl_ObjCmdProc TclNRCatchObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRExprObjCmd;
 MODULE_SCOPE Tcl_ObjCmdProc TclNRForObjCmd;
 MODULE_SCOPE Tcl_ObjCmdProc TclNRForeachCmd;
 MODULE_SCOPE Tcl_ObjCmdProc TclNRIfObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRLmapCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSourceObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSubstObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRSwitchObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRTryObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRUplevelObjCmd;
 MODULE_SCOPE Tcl_ObjCmdProc TclNRWhileObjCmd;
 
 MODULE_SCOPE Tcl_NRPostProc TclNRForIterCallback;
-MODULE_SCOPE Tcl_ObjCmdProc TclNRAtProcExitObjCmd;
+MODULE_SCOPE Tcl_NRPostProc TclNRCoroutineActivateCallback;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRTailcallObjCmd;
+MODULE_SCOPE Tcl_NRPostProc TclNRTailcallEval;
 MODULE_SCOPE Tcl_ObjCmdProc TclNRCoroutineObjCmd;
 MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldmObjCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldToObjCmd;
+
+MODULE_SCOPE void  TclSpliceTailcall(Tcl_Interp *interp,
+                 struct NRE_callback *tailcallPtr);
+
+/*
+ * This structure holds the data for the various iteration callbacks used to
+ * NRE the 'for' and 'while' commands. We need a separate structure because we
+ * have more than the 4 client data entries we can provide directly thorugh
+ * the callback API. It is the 'word' information which puts us over the
+ * limit. It is needed because the loop body is argument 4 of 'for' and
+ * argument 2 of 'while'. Not providing the correct index confuses the #280
+ * code. We TclSmallAlloc/Free this.
+ */
+
+typedef struct ForIterData {
+    Tcl_Obj *cond;    /* Loop condition expression. */
+    Tcl_Obj *body;    /* Loop body. */
+    Tcl_Obj *next;    /* Loop step script, NULL for 'while'. */
+    const char *msg;    /* Error message part. */
+    int word;      /* Index of the body script in the command */
+} ForIterData;
+
+/* TIP #357 - Structure doing the bookkeeping of handles for Tcl_LoadFile
+ *            and Tcl_FindSymbol. This structure corresponds to an opaque
+ *            typedef in tcl.h */
+
+typedef void* TclFindSymbolProc(Tcl_Interp* interp, Tcl_LoadHandle loadHandle,
+        const char* symbol);
+struct Tcl_LoadHandle_ {
+    ClientData clientData;  /* Client data is the load handle in the
+         * native filesystem if a module was loaded
+         * there, or an opaque pointer to a structure
+         * for further bookkeeping on load-from-VFS
+         * and load-from-memory */
+    TclFindSymbolProc* findSymbolProcPtr;
+        /* Procedure that resolves symbols in a
+         * loaded module */
+    Tcl_FSUnloadFileProc* unloadFileProcPtr;
+        /* Procedure that unloads a loaded module */
+};
+
+/* Flags for conversion of doubles to digit strings */
+
+#define TCL_DD_SHORTEST     0x4
+        /* Use the shortest possible string */
+#define TCL_DD_STEELE       0x5
+        /* Use the original Steele&White algorithm */
+#define TCL_DD_E_FORMAT     0x2
+        /* Use a fixed-length string of digits,
+         * suitable for E format*/
+#define TCL_DD_F_FORMAT     0x3
+        /* Use a fixed number of digits after the
+         * decimal point, suitable for F format */
+
+#define TCL_DD_SHORTEN_FLAG     0x4
+        /* Allow return of a shorter digit string
+         * if it converts losslessly */
+#define TCL_DD_NO_QUICK     0x8
+        /* Debug flag: forbid quick FP conversion */
+
+#define TCL_DD_CONVERSION_TYPE_MASK  0x3
+        /* Mask to isolate the conversion type */
+#define TCL_DD_STEELE0       0x1
+        /* 'Steele&White' after masking */
+#define TCL_DD_SHORTEST0    0x0
+        /* 'Shortest possible' after masking */
 
 /*
  *----------------------------------------------------------------
@@ -2575,8 +2877,13 @@
  *----------------------------------------------------------------
  */
 
-MODULE_SCOPE int  TclNREvalCmd(Tcl_Interp * interp, Tcl_Obj * objPtr,
+MODULE_SCOPE void  TclAppendBytesToByteArray(Tcl_Obj *objPtr,
+          const unsigned char *bytes, int len);
+MODULE_SCOPE int  TclNREvalCmd(Tcl_Interp *interp, Tcl_Obj *objPtr,
           int flags);
+MODULE_SCOPE void  TclPushTailcallPoint(Tcl_Interp *interp);
+MODULE_SCOPE void  TclAdvanceContinuations(int *line, int **next,
+          int loc);
 MODULE_SCOPE void  TclAdvanceLines(int *line, const char *start,
           const char *end);
 MODULE_SCOPE void  TclArgumentEnter(Tcl_Interp *interp,
@@ -2584,40 +2891,57 @@
 MODULE_SCOPE void  TclArgumentRelease(Tcl_Interp *interp,
           Tcl_Obj *objv[], int objc);
 MODULE_SCOPE void  TclArgumentBCEnter(Tcl_Interp *interp,
-          void *codePtr, CmdFrame *cfPtr);
+          Tcl_Obj *objv[], int objc,
+          void *codePtr, CmdFrame *cfPtr, int pc);
 MODULE_SCOPE void  TclArgumentBCRelease(Tcl_Interp *interp,
-          void *codePtr);
+          CmdFrame *cfPtr);
 MODULE_SCOPE void  TclArgumentGet(Tcl_Interp *interp, Tcl_Obj *obj,
           CmdFrame **cfPtrPtr, int *wordPtr);
 MODULE_SCOPE int  TclArraySet(Tcl_Interp *interp,
           Tcl_Obj *arrayNameObj, Tcl_Obj *arrayElemObj);
-MODULE_SCOPE double  TclBignumToDouble(mp_int *bignum);
+MODULE_SCOPE double  TclBignumToDouble(const mp_int *bignum);
 MODULE_SCOPE int  TclByteArrayMatch(const unsigned char *string,
           int strLen, const unsigned char *pattern,
           int ptnLen, int flags);
-MODULE_SCOPE double  TclCeil(mp_int *a);
-MODULE_SCOPE int  TclCheckBadOctal(Tcl_Interp *interp,const char *value);
+MODULE_SCOPE double  TclCeil(const mp_int *a);
+MODULE_SCOPE int  TclCheckBadOctal(Tcl_Interp *interp,
+          const char *value);
 MODULE_SCOPE int  TclChanCaughtErrorBypass(Tcl_Interp *interp,
           Tcl_Channel chan);
+MODULE_SCOPE Tcl_ObjCmdProc TclChannelNamesCmd;
 MODULE_SCOPE int  TclClearRootEnsemble(ClientData data[],
           Tcl_Interp *interp, int result);
-MODULE_SCOPE void  TclCleanupLiteralTable(Tcl_Interp *interp,
-          LiteralTable *tablePtr);
-MODULE_SCOPE int  TclDoubleDigits(char *buf, double value, int *signum);
+MODULE_SCOPE ContLineLoc *TclContinuationsEnter(Tcl_Obj *objPtr, int num,
+          int *loc);
+MODULE_SCOPE void  TclContinuationsEnterDerived(Tcl_Obj *objPtr,
+          int start, int *clNext);
+MODULE_SCOPE ContLineLoc *TclContinuationsGet(Tcl_Obj *objPtr);
+MODULE_SCOPE void  TclContinuationsCopy(Tcl_Obj *objPtr,
+          Tcl_Obj *originObjPtr);
+MODULE_SCOPE int  TclConvertElement(const char *src, int length,
+          char *dst, int flags);
 MODULE_SCOPE void  TclDeleteNamespaceVars(Namespace *nsPtr);
-/* TIP #280 - Modified token based evulation, with line information */
+/* TIP #280 - Modified token based evulation, with line information. */
 MODULE_SCOPE int  TclEvalEx(Tcl_Interp *interp, const char *script,
-          int numBytes, int flags, int line);
-MODULE_SCOPE int  TclFileAttrsCmd(Tcl_Interp *interp,
-          int objc, Tcl_Obj *const objv[]);
-MODULE_SCOPE int  TclFileCopyCmd(Tcl_Interp *interp,
-          int objc, Tcl_Obj *const objv[]);
-MODULE_SCOPE int  TclFileDeleteCmd(Tcl_Interp *interp,
-          int objc, Tcl_Obj *const objv[]);
-MODULE_SCOPE int  TclFileMakeDirsCmd(Tcl_Interp *interp,
-          int objc, Tcl_Obj *const objv[]);
-MODULE_SCOPE int  TclFileRenameCmd(Tcl_Interp *interp,
-          int objc, Tcl_Obj *const objv[]);
+          int numBytes, int flags, int line,
+          int *clNextOuter, const char *outerScript);
+MODULE_SCOPE Tcl_ObjCmdProc TclFileAttrsCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileCopyCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileDeleteCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileLinkCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileMakeDirsCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileReadLinkCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileRenameCmd;
+MODULE_SCOPE Tcl_ObjCmdProc TclFileTemporaryCmd;
+MODULE_SCOPE void  TclCreateLateExitHandler(Tcl_ExitProc *proc,
+          ClientData clientData);
+MODULE_SCOPE void  TclDeleteLateExitHandler(Tcl_ExitProc *proc,
+          ClientData clientData);
+MODULE_SCOPE char *  TclDStringAppendObj(Tcl_DString *dsPtr,
+          Tcl_Obj *objPtr);
+MODULE_SCOPE char *  TclDStringAppendDString(Tcl_DString *dsPtr,
+          Tcl_DString *toAppendPtr);
+MODULE_SCOPE Tcl_Obj *  TclDStringToObj(Tcl_DString *dsPtr);
 MODULE_SCOPE void  TclFinalizeAllocSubsystem(void);
 MODULE_SCOPE void  TclFinalizeAsync(void);
 MODULE_SCOPE void  TclFinalizeDoubleConversion(void);
@@ -2637,15 +2961,21 @@
 MODULE_SCOPE void  TclFinalizeSynchronization(void);
 MODULE_SCOPE void  TclFinalizeThreadAlloc(void);
 MODULE_SCOPE void  TclFinalizeThreadData(void);
-MODULE_SCOPE double  TclFloor(mp_int *a);
+MODULE_SCOPE void  TclFinalizeThreadObjects(void);
+MODULE_SCOPE double  TclFloor(const mp_int *a);
 MODULE_SCOPE void  TclFormatNaN(double value, char *buffer);
 MODULE_SCOPE int  TclFSFileAttrIndex(Tcl_Obj *pathPtr,
           const char *attributeName, int *indexPtr);
+MODULE_SCOPE int  TclNREvalFile(Tcl_Interp *interp, Tcl_Obj *pathPtr,
+          const char *encodingName);
+MODULE_SCOPE void  TclFSUnloadTempFile(Tcl_LoadHandle loadHandle);
 MODULE_SCOPE int *  TclGetAsyncReadyPtr(void);
 MODULE_SCOPE Tcl_Obj *  TclGetBgErrorHandler(Tcl_Interp *interp);
 MODULE_SCOPE int  TclGetChannelFromObj(Tcl_Interp *interp,
           Tcl_Obj *objPtr, Tcl_Channel *chanPtr,
           int *modePtr, int flags);
+MODULE_SCOPE int TclGetCompletionCodeFromObj(Tcl_Interp *interp,
+          Tcl_Obj *value, int *code);
 MODULE_SCOPE int  TclGetNumberFromObj(Tcl_Interp *interp,
           Tcl_Obj *objPtr, ClientData *clientDataPtr,
           int *typePtr);
@@ -2686,6 +3016,8 @@
 MODULE_SCOPE void  TclInitSubsystems(void);
 MODULE_SCOPE int  TclInterpReady(Tcl_Interp *interp);
 MODULE_SCOPE int  TclIsLocalScalar(const char *src, int len);
+MODULE_SCOPE int  TclIsSpaceProc(char byte);
+MODULE_SCOPE Tcl_Obj *  TclJoinPath(int elements, Tcl_Obj * const objv[]);
 MODULE_SCOPE int  TclJoinThread(Tcl_ThreadId id, int *result);
 MODULE_SCOPE void  TclLimitRemoveAllHandlers(Tcl_Interp *interp);
 MODULE_SCOPE Tcl_Obj *  TclLindexList(Tcl_Interp *interp,
@@ -2693,15 +3025,9 @@
 MODULE_SCOPE Tcl_Obj *  TclLindexFlat(Tcl_Interp *interp, Tcl_Obj *listPtr,
           int indexCount, Tcl_Obj *const indexArray[]);
 /* TIP #280 */
-MODULE_SCOPE void  TclListLines(const char *listStr, int line, int n,
-          int *lines);
+MODULE_SCOPE void  TclListLines(Tcl_Obj *listObj, int line, int n,
+          int *lines, Tcl_Obj *const *elems);
 MODULE_SCOPE Tcl_Obj *  TclListObjCopy(Tcl_Interp *interp, Tcl_Obj *listPtr);
-MODULE_SCOPE int  TclLoadFile(Tcl_Interp *interp, Tcl_Obj *pathPtr,
-          int symc, const char *symbols[],
-          Tcl_PackageInitProc **procPtrs[],
-          Tcl_LoadHandle *handlePtr,
-          ClientData *clientDataPtr,
-          Tcl_FSUnloadFileProc **unloadProcPtr);
 MODULE_SCOPE Tcl_Obj *  TclLsetList(Tcl_Interp *interp, Tcl_Obj *listPtr,
           Tcl_Obj *indexPtr, Tcl_Obj *valuePtr);
 MODULE_SCOPE Tcl_Obj *  TclLsetFlat(Tcl_Interp *interp, Tcl_Obj *listPtr,
@@ -2709,13 +3035,14 @@
           Tcl_Obj *valuePtr);
 MODULE_SCOPE Tcl_Command TclMakeEnsemble(Tcl_Interp *interp, const char *name,
           const EnsembleImplMap map[]);
-MODULE_SCOPE int  TclMarkList(Tcl_Interp *interp, const char *list,
-          const char *end, int *argcPtr,
-          const int **argszPtr, const char ***argvPtr);
+MODULE_SCOPE int  TclMaxListLength(const char *bytes, int numBytes,
+          const char **endPtr);
 MODULE_SCOPE int  TclMergeReturnOptions(Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[], Tcl_Obj **optionsPtrPtr,
           int *codePtr, int *levelPtr);
-MODULE_SCOPE int  TclNokia770Doubles();
+MODULE_SCOPE Tcl_Obj *  TclNoErrorStack(Tcl_Interp *interp, Tcl_Obj *options);
+MODULE_SCOPE int  TclNokia770Doubles(void);
+MODULE_SCOPE void  TclNsDecrRefCount(Namespace *nsPtr);
 MODULE_SCOPE void  TclObjVarErrMsg(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
           Tcl_Obj *part2Ptr, const char *operation,
           const char *reason, int index);
@@ -2727,7 +3054,7 @@
 MODULE_SCOPE int  TclParseBackslash(const char *src,
           int numBytes, int *readPtr, char *dst);
 MODULE_SCOPE int  TclParseHex(const char *src, int numBytes,
-          Tcl_UniChar *resultPtr);
+          int *resultPtr);
 MODULE_SCOPE int  TclParseNumber(Tcl_Interp *interp, Tcl_Obj *objPtr,
           const char *expected, const char *bytes,
           int numBytes, const char **endPtrPtr, int flags);
@@ -2738,15 +3065,20 @@
           int code, int level, Tcl_Obj *returnOpts);
 MODULE_SCOPE int  TclpObjLstat(Tcl_Obj *pathPtr, Tcl_StatBuf *buf);
 MODULE_SCOPE Tcl_Obj *  TclpTempFileName(void);
+MODULE_SCOPE Tcl_Obj *  TclpTempFileNameForLibrary(Tcl_Interp *interp, Tcl_Obj* pathPtr);
 MODULE_SCOPE Tcl_Obj *  TclNewFSPathObj(Tcl_Obj *dirPtr, const char *addStrRep,
           int len);
-MODULE_SCOPE int  TclpDeleteFile(const char *path);
+MODULE_SCOPE int  TclpDeleteFile(const void *path);
 MODULE_SCOPE void  TclpFinalizeCondition(Tcl_Condition *condPtr);
 MODULE_SCOPE void  TclpFinalizeMutex(Tcl_Mutex *mutexPtr);
 MODULE_SCOPE void  TclpFinalizePipes(void);
 MODULE_SCOPE void  TclpFinalizeSockets(void);
+MODULE_SCOPE int  TclCreateSocketAddress(Tcl_Interp *interp,
+          struct addrinfo **addrlist,
+          const char *host, int port, int willBind,
+          const char **errorMsgPtr);
 MODULE_SCOPE int  TclpThreadCreate(Tcl_ThreadId *idPtr,
-          Tcl_ThreadCreateProc proc, ClientData clientData,
+          Tcl_ThreadCreateProc *proc, ClientData clientData,
           int stackSize, int flags);
 MODULE_SCOPE int  TclpFindVariable(const char *name, int *lengthPtr);
 MODULE_SCOPE void  TclpInitLibraryPath(char **valuePtr,
@@ -2754,12 +3086,6 @@
 MODULE_SCOPE void  TclpInitLock(void);
 MODULE_SCOPE void  TclpInitPlatform(void);
 MODULE_SCOPE void  TclpInitUnlock(void);
-MODULE_SCOPE int  TclpLoadFile(Tcl_Interp *interp, Tcl_Obj *pathPtr,
-          const char *sym1, const char *sym2,
-          Tcl_PackageInitProc **proc1Ptr,
-          Tcl_PackageInitProc **proc2Ptr,
-          ClientData *clientDataPtr,
-          Tcl_FSUnloadFileProc **unloadProcPtr);
 MODULE_SCOPE Tcl_Obj *  TclpObjListVolumes(void);
 MODULE_SCOPE void  TclpMasterLock(void);
 MODULE_SCOPE void  TclpMasterUnlock(void);
@@ -2767,7 +3093,7 @@
           Tcl_DString *dirPtr, char *pattern, char *tail);
 MODULE_SCOPE int  TclpObjNormalizePath(Tcl_Interp *interp,
           Tcl_Obj *pathPtr, int nextCheckpoint);
-MODULE_SCOPE void  TclpNativeJoinPath(Tcl_Obj *prefix, char *joining);
+MODULE_SCOPE void  TclpNativeJoinPath(Tcl_Obj *prefix, const char *joining);
 MODULE_SCOPE Tcl_Obj *  TclpNativeSplitPath(Tcl_Obj *pathPtr, int *lenPtr);
 MODULE_SCOPE Tcl_PathType TclpGetNativePathType(Tcl_Obj *pathPtr,
           int *driveNameLengthPtr, Tcl_Obj **driveNameRef);
@@ -2781,15 +3107,15 @@
 MODULE_SCOPE Tcl_Obj *  TclpObjLink(Tcl_Obj *pathPtr, Tcl_Obj *toPtr,
           int linkType);
 MODULE_SCOPE int  TclpObjChdir(Tcl_Obj *pathPtr);
+MODULE_SCOPE Tcl_Channel TclpOpenTemporaryFile(Tcl_Obj *dirObj,
+          Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+          Tcl_Obj *resultingNameObj);
 MODULE_SCOPE Tcl_Obj *  TclPathPart(Tcl_Interp *interp, Tcl_Obj *pathPtr,
           Tcl_PathPart portion);
-MODULE_SCOPE void  TclpPanic(const char *format, ...);
 MODULE_SCOPE char *  TclpReadlink(const char *fileName,
           Tcl_DString *linkPtr);
-MODULE_SCOPE void  TclpReleaseFile(TclFile file);
 MODULE_SCOPE void  TclpSetInterfaces(void);
 MODULE_SCOPE void  TclpSetVariables(Tcl_Interp *interp);
-MODULE_SCOPE void  TclpUnloadFile(Tcl_LoadHandle loadHandle);
 MODULE_SCOPE void *  TclThreadStorageKeyGet(Tcl_ThreadDataKey *keyPtr);
 MODULE_SCOPE void  TclThreadStorageKeySet(Tcl_ThreadDataKey *keyPtr,
           void *data);
@@ -2800,12 +3126,15 @@
 MODULE_SCOPE void  TclRemoveScriptLimitCallbacks(Tcl_Interp *interp);
 MODULE_SCOPE int  TclReToGlob(Tcl_Interp *interp, const char *reStr,
           int reStrLen, Tcl_DString *dsPtr, int *flagsPtr);
+MODULE_SCOPE int  TclScanElement(const char *string, int length,
+          int *flagPtr);
 MODULE_SCOPE void  TclSetBgErrorHandler(Tcl_Interp *interp,
           Tcl_Obj *cmdPrefix);
 MODULE_SCOPE void  TclSetBignumIntRep(Tcl_Obj *objPtr,
           mp_int *bignumValue);
 MODULE_SCOPE void  TclSetCmdNameObj(Tcl_Interp *interp, Tcl_Obj *objPtr,
           Command *cmdPtr);
+MODULE_SCOPE void  TclSetDuplicateObj(Tcl_Obj *dupPtr, Tcl_Obj *objPtr);
 MODULE_SCOPE void  TclSetProcessGlobalValue(ProcessGlobalValue *pgvPtr,
           Tcl_Obj *newValue, Tcl_Encoding encoding);
 MODULE_SCOPE void  TclSignalExitThread(Tcl_ThreadId id, int result);
@@ -2816,23 +3145,32 @@
 MODULE_SCOPE int  TclStringMatchObj(Tcl_Obj *stringObj,
           Tcl_Obj *patternObj, int flags);
 MODULE_SCOPE Tcl_Obj *  TclStringObjReverse(Tcl_Obj *objPtr);
+MODULE_SCOPE void  TclSubstCompile(Tcl_Interp *interp, const char *bytes,
+          int numBytes, int flags, int line,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclSubstOptions(Tcl_Interp *interp, int numOpts,
+          Tcl_Obj *const opts[], int *flagPtr);
+MODULE_SCOPE void  TclSubstParse(Tcl_Interp *interp, const char *bytes,
+          int numBytes, int flags, Tcl_Parse *parsePtr,
+          Tcl_InterpState *statePtr);
 MODULE_SCOPE int  TclSubstTokens(Tcl_Interp *interp, Tcl_Token *tokenPtr,
-          int count, int *tokensLeftPtr, int line);
-MODULE_SCOPE void  TclTransferResult(Tcl_Interp *sourceInterp, int result,
-          Tcl_Interp *targetInterp);
+          int count, int *tokensLeftPtr, int line,
+          int *clNextOuter, const char *outerScript);
+MODULE_SCOPE int  TclTrimLeft(const char *bytes, int numBytes,
+          const char *trim, int numTrim);
+MODULE_SCOPE int  TclTrimRight(const char *bytes, int numBytes,
+          const char *trim, int numTrim);
 MODULE_SCOPE Tcl_Obj *  TclpNativeToNormalized(ClientData clientData);
 MODULE_SCOPE Tcl_Obj *  TclpFilesystemPathType(Tcl_Obj *pathPtr);
-MODULE_SCOPE Tcl_PackageInitProc *TclpFindSymbol(Tcl_Interp *interp,
-          Tcl_LoadHandle loadHandle, const char *symbol);
 MODULE_SCOPE int  TclpDlopen(Tcl_Interp *interp, Tcl_Obj *pathPtr,
           Tcl_LoadHandle *loadHandle,
-          Tcl_FSUnloadFileProc **unloadProcPtr);
+          Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
 MODULE_SCOPE int  TclpUtime(Tcl_Obj *pathPtr, struct utimbuf *tval);
 #ifdef TCL_LOAD_FROM_MEMORY
 MODULE_SCOPE void *  TclpLoadMemoryGetBuffer(Tcl_Interp *interp, int size);
 MODULE_SCOPE int  TclpLoadMemory(Tcl_Interp *interp, void *buffer,
           int size, int codeSize, Tcl_LoadHandle *loadHandle,
-          Tcl_FSUnloadFileProc **unloadProcPtr);
+          Tcl_FSUnloadFileProc **unloadProcPtr, int flags);
 #endif
 MODULE_SCOPE void  TclInitThreadStorage(void);
 MODULE_SCOPE void  TclFinalizeThreadDataThread(void);
@@ -2842,12 +3180,14 @@
 MODULE_SCOPE double  TclpWideClicksToNanoseconds(Tcl_WideInt clicks);
 #endif
 MODULE_SCOPE Tcl_Obj *  TclDisassembleByteCodeObj(Tcl_Obj *objPtr);
-
+MODULE_SCOPE int  TclZlibInit(Tcl_Interp *interp);
 MODULE_SCOPE void *  TclpThreadCreateKey(void);
 MODULE_SCOPE void  TclpThreadDeleteKey(void *keyPtr);
 MODULE_SCOPE void  TclpThreadSetMasterTSD(void *tsdKeyPtr, void *ptr);
 MODULE_SCOPE void *  TclpThreadGetMasterTSD(void *tsdKeyPtr);
 
+MODULE_SCOPE void  TclErrorStackResetIf(Tcl_Interp *interp, const char *msg, int length);
+
 /*
  *----------------------------------------------------------------
  * Command procedures in the generic core:
@@ -2863,9 +3203,7 @@
 MODULE_SCOPE int  Tcl_ApplyObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
-MODULE_SCOPE int  Tcl_ArrayObjCmd(ClientData clientData,
-          Tcl_Interp *interp, int objc,
-          Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitArrayCmd(Tcl_Interp *interp);
 MODULE_SCOPE Tcl_Command TclInitBinaryCmd(Tcl_Interp *interp);
 MODULE_SCOPE int  Tcl_BreakObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
@@ -2910,9 +3248,24 @@
           ClientData clientData, Tcl_Interp *interp,
           int objc, Tcl_Obj *const objv[]);
 MODULE_SCOPE Tcl_Command TclInitDictCmd(Tcl_Interp *interp);
+MODULE_SCOPE int  TclDictWithFinish(Tcl_Interp *interp, Var *varPtr,
+          Var *arrayPtr, Tcl_Obj *part1Ptr,
+          Tcl_Obj *part2Ptr, int index, int pathc,
+          Tcl_Obj *const pathv[], Tcl_Obj *keysPtr);
+MODULE_SCOPE Tcl_Obj *  TclDictWithInit(Tcl_Interp *interp, Tcl_Obj *dictPtr,
+          int pathc, Tcl_Obj *const pathv[]);
 MODULE_SCOPE int  Tcl_DisassembleObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
+
+/* Assemble command function */
+MODULE_SCOPE int  Tcl_AssembleObjCmd(ClientData clientData,
+          Tcl_Interp *interp, int objc,
+          Tcl_Obj *const objv[]);
+MODULE_SCOPE int  TclNRAssembleObjCmd(ClientData clientData,
+          Tcl_Interp *interp, int objc,
+          Tcl_Obj *const objv[]);
+
 MODULE_SCOPE int  Tcl_EncodingObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
@@ -2943,9 +3296,8 @@
 MODULE_SCOPE int  Tcl_FcopyObjCmd(ClientData dummy,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
-MODULE_SCOPE int  Tcl_FileObjCmd(ClientData dummy,
-          Tcl_Interp *interp, int objc,
-          Tcl_Obj *const objv[]);
+MODULE_SCOPE Tcl_Command TclInitFileCmd(Tcl_Interp *interp);
+MODULE_SCOPE int  TclMakeFileCommandSafe(Tcl_Interp *interp);
 MODULE_SCOPE int  Tcl_FileEventObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
@@ -3001,6 +3353,9 @@
 MODULE_SCOPE int  Tcl_ListObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
+MODULE_SCOPE int  Tcl_LmapObjCmd(ClientData clientData,
+          Tcl_Interp *interp, int objc,
+          Tcl_Obj *const objv[]);
 MODULE_SCOPE int  Tcl_LoadObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
@@ -3025,7 +3380,8 @@
 MODULE_SCOPE int  Tcl_LsortObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
-MODULE_SCOPE int  Tcl_NamespaceObjCmd(ClientData clientData,
+MODULE_SCOPE Tcl_Command TclInitNamespaceCmd(Tcl_Interp *interp);
+MODULE_SCOPE int  TclNamespaceEnsembleCmd(ClientData dummy,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
 MODULE_SCOPE int  Tcl_OpenObjCmd(ClientData clientData,
@@ -3056,6 +3412,9 @@
 MODULE_SCOPE int  Tcl_RenameObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
+MODULE_SCOPE int  Tcl_RepresentationCmd(ClientData clientData,
+          Tcl_Interp *interp, int objc,
+          Tcl_Obj *const objv[]);
 MODULE_SCOPE int  Tcl_ReturnObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
@@ -3087,12 +3446,17 @@
 MODULE_SCOPE int  Tcl_TellObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
+MODULE_SCOPE int  Tcl_ThrowObjCmd(ClientData dummy, Tcl_Interp *interp,
+          int objc, Tcl_Obj *const objv[]);
 MODULE_SCOPE int  Tcl_TimeObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
 MODULE_SCOPE int  Tcl_TraceObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
+MODULE_SCOPE int  Tcl_TryObjCmd(ClientData clientData,
+          Tcl_Interp *interp, int objc,
+          Tcl_Obj *const objv[]);
 MODULE_SCOPE int  Tcl_UnloadObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
@@ -3127,6 +3491,15 @@
 MODULE_SCOPE int  TclCompileAppendCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileArrayExistsCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileArraySetCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileArrayUnsetCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileBreakCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
@@ -3139,6 +3512,12 @@
 MODULE_SCOPE int  TclCompileDictAppendCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileDictCreateCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileDictExistsCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileDictForCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
@@ -3151,15 +3530,30 @@
 MODULE_SCOPE int  TclCompileDictLappendCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileDictMapCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileDictMergeCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileDictSetCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileDictUnsetCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileDictUpdateCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileDictWithCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileEnsemble(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileErrorCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileExprCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
@@ -3169,15 +3563,36 @@
 MODULE_SCOPE int  TclCompileForeachCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileFormatCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileGlobalCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileIfCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileInfoCommandsCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileInfoCoroutineCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileInfoExistsCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileInfoLevelCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileInfoObjectClassCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileInfoObjectIsACmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileInfoObjectNamespaceCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileIncrCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
@@ -3196,18 +3611,48 @@
 MODULE_SCOPE int  TclCompileLlengthCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileLmapCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileLrangeCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileLreplaceCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileLsetCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
-MODULE_SCOPE int  TclCompileNamespaceCmd(Tcl_Interp *interp,
+MODULE_SCOPE int  TclCompileNamespaceCodeCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileNamespaceCurrentCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileNamespaceQualifiersCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileNamespaceTailCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileNamespaceUpvarCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileNamespaceWhichCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileNoOp(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileObjectSelfCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileRegexpCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileRegsubCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileReturnCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
@@ -3220,18 +3665,45 @@
 MODULE_SCOPE int  TclCompileStringEqualCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileStringFirstCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileStringIndexCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileStringLastCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileStringLenCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileStringMapCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileStringMatchCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileStringRangeCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileSubstCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileSwitchCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileTailcallCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileThrowCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileTryCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileUnsetCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 MODULE_SCOPE int  TclCompileUpvarCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
@@ -3241,6 +3713,9 @@
 MODULE_SCOPE int  TclCompileWhileCmd(Tcl_Interp *interp,
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
+MODULE_SCOPE int  TclCompileYieldCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
 
 MODULE_SCOPE int  TclInvertOpCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
@@ -3381,6 +3856,10 @@
           Tcl_Parse *parsePtr, Command *cmdPtr,
           struct CompileEnv *envPtr);
 
+MODULE_SCOPE int  TclCompileAssembleCmd(Tcl_Interp *interp,
+          Tcl_Parse *parsePtr, Command *cmdPtr,
+          struct CompileEnv *envPtr);
+
 /*
  * Functions defined in generic/tclVar.c and currenttly exported only for use
  * by the bytecode compiler and engine. Some of these could later be placed in
@@ -3409,6 +3888,10 @@
           const int flags, int index);
 MODULE_SCOPE int  TclPtrObjMakeUpvar(Tcl_Interp *interp, Var *otherPtr,
           Tcl_Obj *myNamePtr, int myFlags, int index);
+MODULE_SCOPE int  TclPtrUnsetVar(Tcl_Interp *interp, Var *varPtr,
+          Var *arrayPtr, Tcl_Obj *part1Ptr,
+          Tcl_Obj *part2Ptr, const int flags,
+          int index);
 MODULE_SCOPE void  TclInvalidateNsPath(Namespace *nsPtr);
 
 /*
@@ -3427,6 +3910,8 @@
 MODULE_SCOPE void  TclFreeObjEntry(Tcl_HashEntry *hPtr);
 MODULE_SCOPE unsigned  TclHashObjKey(Tcl_HashTable *tablePtr, void *keyPtr);
 
+MODULE_SCOPE int  TclFullFinalizationRequested(void);
+
 /*
  *----------------------------------------------------------------
  * Macros used by the Tcl core to create and release Tcl objects.
@@ -3454,7 +3939,7 @@
 
 #ifdef USE_DTRACE
 #ifndef _TCLDTRACE_H
-typedef const char* TclDTraceStr;
+typedef const char *TclDTraceStr;
 #include "tclDTrace.h"
 #endif
 #define  TCL_DTRACE_OBJ_CREATE(objPtr)  TCL_OBJ_CREATE(objPtr)
@@ -3494,23 +3979,23 @@
  * Invalidate the string rep first so we can use the bytes value for our
  * pointer chain, and signal an obj deletion (as opposed to shimmering) with
  * 'length == -1'.
- * Use empty 'if ; else' to handle use in unbraced outer if/else conditions
+ * Use empty 'if ; else' to handle use in unbraced outer if/else conditions.
  */
 
 # define TclDecrRefCount(objPtr) \
-    if (--(objPtr)->refCount > 0) ; else {        \
-  if (!(objPtr)->typePtr || !(objPtr)->typePtr->freeIntRepProc) {  \
-      TCL_DTRACE_OBJ_FREE(objPtr);        \
-      if ((objPtr)->bytes            \
-        && ((objPtr)->bytes != tclEmptyStringRep)) {  \
-    ckfree((char *) (objPtr)->bytes);      \
-      }                \
-      (objPtr)->length = -1;          \
-      TclFreeObjStorage(objPtr);          \
-      TclIncrObjsFreed();            \
-  } else {              \
-      TclFreeObj(objPtr);            \
-  }                \
+    if (--(objPtr)->refCount > 0) ; else { \
+  if (!(objPtr)->typePtr || !(objPtr)->typePtr->freeIntRepProc) { \
+      TCL_DTRACE_OBJ_FREE(objPtr); \
+      if ((objPtr)->bytes \
+        && ((objPtr)->bytes != tclEmptyStringRep)) { \
+    ckfree((char *) (objPtr)->bytes); \
+      } \
+      (objPtr)->length = -1; \
+      TclFreeObjStorage(objPtr); \
+      TclIncrObjsFreed(); \
+  } else { \
+      TclFreeObj(objPtr); \
+  } \
     }
 
 #if defined(PURIFY)
@@ -3519,7 +4004,7 @@
  * The PURIFY mode is like the regular mode, but instead of doing block
  * Tcl_Obj allocation and keeping a freed list for efficiency, it always
  * allocates and frees a single Tcl_Obj so that tools like Purify can better
- * track memory leaks
+ * track memory leaks.
  */
 
 #  define TclAllocObjStorageEx(interp, objPtr) \
@@ -3550,7 +4035,7 @@
  * and TclThreadFreeObj().
  *
  * Note that the optimiser should resolve the case (interp==NULL) at compile
- * time. 
+ * time.
  */
 
 #  define ALLOC_NOBJHIGH 1200
@@ -3568,7 +4053,7 @@
       --cachePtr->numObjects;          \
   }                \
     } while (0)
-  
+
 #  define TclFreeObjStorageEx(interp, objPtr)        \
     do {                \
   AllocCache *cachePtr;            \
@@ -3585,36 +4070,51 @@
 
 #else /* not PURIFY or USE_THREAD_ALLOC */
 
+#if defined(USE_TCLALLOC) && USE_TCLALLOC
+    MODULE_SCOPE void TclFinalizeAllocSubsystem();
+    MODULE_SCOPE void TclInitAlloc();
+#else
+#   define USE_TCLALLOC 0
+#endif
+
 #ifdef TCL_THREADS
 /* declared in tclObj.c */
 MODULE_SCOPE Tcl_Mutex  tclObjMutex;
 #endif
 
-#  define TclAllocObjStorageEx(interp, objPtr)  \
-  Tcl_MutexLock(&tclObjMutex); \
-  if (tclFreeObjList == NULL) { \
-      TclAllocateFreeObjects(); \
-  } \
-  (objPtr) = tclFreeObjList; \
-  tclFreeObjList = (Tcl_Obj *) \
-    tclFreeObjList->internalRep.otherValuePtr; \
-  Tcl_MutexUnlock(&tclObjMutex)
+#  define TclAllocObjStorageEx(interp, objPtr) \
+    do {                \
+  Tcl_MutexLock(&tclObjMutex);          \
+  if (tclFreeObjList == NULL) {          \
+      TclAllocateFreeObjects();          \
+  }                \
+  (objPtr) = tclFreeObjList;          \
+  tclFreeObjList = (Tcl_Obj *)          \
+    tclFreeObjList->internalRep.otherValuePtr;    \
+  Tcl_MutexUnlock(&tclObjMutex);          \
+    } while (0)
 
-#  define TclFreeObjStorageEx(interp, objPtr)  \
-  Tcl_MutexLock(&tclObjMutex); \
+#  define TclFreeObjStorageEx(interp, objPtr) \
+    do {                     \
+  Tcl_MutexLock(&tclObjMutex);               \
   (objPtr)->internalRep.otherValuePtr = (void *) tclFreeObjList; \
-  tclFreeObjList = (objPtr); \
-  Tcl_MutexUnlock(&tclObjMutex)
+  tclFreeObjList = (objPtr);               \
+  Tcl_MutexUnlock(&tclObjMutex);               \
+    } while (0)
 #endif
 
 #else /* TCL_MEM_DEBUG */
-MODULE_SCOPE void  TclDbInitNewObj(Tcl_Obj *objPtr);
+MODULE_SCOPE void  TclDbInitNewObj(Tcl_Obj *objPtr, const char *file,
+          int line);
 
 # define TclDbNewObj(objPtr, file, line) \
-    TclIncrObjsAllocated(); \
-    (objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line)); \
-    TclDbInitNewObj(objPtr); \
-    TCL_DTRACE_OBJ_CREATE(objPtr)
+    do { \
+  TclIncrObjsAllocated();            \
+  (objPtr) = (Tcl_Obj *)            \
+    Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line));    \
+  TclDbInitNewObj((objPtr), (file), (line));      \
+  TCL_DTRACE_OBJ_CREATE(objPtr);          \
+    } while (0)
 
 # define TclNewObj(objPtr) \
     TclDbNewObj(objPtr, __FILE__, __LINE__);
@@ -3644,14 +4144,14 @@
  */
 
 #define TclInitStringRep(objPtr, bytePtr, len) \
-    if ((len) == 0) {              \
-  (objPtr)->bytes   = tclEmptyStringRep;        \
-  (objPtr)->length = 0;            \
-    } else {                \
-  (objPtr)->bytes = (char *) ckalloc((unsigned) ((len) + 1));  \
-  memcpy((objPtr)->bytes, (bytePtr), (unsigned) (len));    \
-  (objPtr)->bytes[len] = '\0';          \
-  (objPtr)->length = (len);          \
+    if ((len) == 0) { \
+  (objPtr)->bytes   = tclEmptyStringRep; \
+  (objPtr)->length = 0; \
+    } else { \
+  (objPtr)->bytes = (char *) ckalloc((unsigned) ((len) + 1)); \
+  memcpy((objPtr)->bytes, (bytePtr), (unsigned) (len)); \
+  (objPtr)->bytes[len] = '\0'; \
+  (objPtr)->length = (len); \
     }
 
 /*
@@ -3685,9 +4185,11 @@
  */
 
 #define TclFreeIntRep(objPtr) \
-    if ((objPtr)->typePtr != NULL && \
-      (objPtr)->typePtr->freeIntRepProc != NULL) { \
-  (objPtr)->typePtr->freeIntRepProc(objPtr); \
+    if ((objPtr)->typePtr != NULL) { \
+  if ((objPtr)->typePtr->freeIntRepProc != NULL) { \
+      (objPtr)->typePtr->freeIntRepProc(objPtr); \
+  } \
+  (objPtr)->typePtr = NULL; \
     }
 
 /*
@@ -3700,11 +4202,11 @@
  */
 
 #define TclInvalidateStringRep(objPtr) \
-    if (objPtr->bytes != NULL) {      \
-  if (objPtr->bytes != tclEmptyStringRep) {  \
-      ckfree((char *) objPtr->bytes);    \
-  }            \
-  objPtr->bytes = NULL;        \
+    if (objPtr->bytes != NULL) { \
+  if (objPtr->bytes != tclEmptyStringRep) { \
+      ckfree((char *) objPtr->bytes); \
+  } \
+  objPtr->bytes = NULL; \
     }
 
 /*
@@ -3721,32 +4223,57 @@
  *----------------------------------------------------------------
  */
 
-#define TCL_MIN_TOKEN_GROWTH 50
+/* General tuning for minimum growth in Tcl growth algorithms */
+#ifndef TCL_MIN_GROWTH
+#  ifdef TCL_GROWTH_MIN_ALLOC
+     /* Support for any legacy tuners */
+#    define TCL_MIN_GROWTH TCL_GROWTH_MIN_ALLOC
+#  else
+#    define TCL_MIN_GROWTH 1024
+#  endif
+#endif
+
+/* Token growth tuning, default to the general value. */
+#ifndef TCL_MIN_TOKEN_GROWTH
+#define TCL_MIN_TOKEN_GROWTH TCL_MIN_GROWTH/sizeof(Tcl_Token)
+#endif
+
+#define TCL_MAX_TOKENS (int)(UINT_MAX / sizeof(Tcl_Token))
 #define TclGrowTokenArray(tokenPtr, used, available, append, staticPtr)  \
-{                  \
-    int needed = (used) + (append);          \
-    if (needed > (available)) {            \
-  int allocated = 2 * needed;          \
-  Tcl_Token *oldPtr = (tokenPtr);          \
-  Tcl_Token *newPtr;            \
-  if (oldPtr == (staticPtr)) {          \
-      oldPtr = NULL;            \
-  }                \
-  newPtr = (Tcl_Token *) attemptckrealloc((char *) oldPtr,  \
-    (unsigned) (allocated * sizeof(Tcl_Token)));  \
-  if (newPtr == NULL) {            \
-      allocated = needed + (append) + TCL_MIN_TOKEN_GROWTH;  \
-      newPtr = (Tcl_Token *) ckrealloc((char *) oldPtr,    \
-        (unsigned) (allocated * sizeof(Tcl_Token)));  \
+    do {                \
+  int needed = (used) + (append);          \
+  if (needed > TCL_MAX_TOKENS) {          \
+      Tcl_Panic("max # of tokens for a Tcl parse (%d) exceeded",  \
+        TCL_MAX_TOKENS);          \
   }                \
-  (available) = allocated;          \
-  if (oldPtr == NULL) {            \
-      memcpy(newPtr, staticPtr,          \
-        (size_t) ((used) * sizeof(Tcl_Token)));    \
+  if (needed > (available)) {          \
+      int allocated = 2 * needed;          \
+      Tcl_Token *oldPtr = (tokenPtr);        \
+      Tcl_Token *newPtr;            \
+      if (oldPtr == (staticPtr)) {        \
+    oldPtr = NULL;            \
+      }                \
+      if (allocated > TCL_MAX_TOKENS) {        \
+    allocated = TCL_MAX_TOKENS;        \
+      }                \
+      newPtr = (Tcl_Token *) attemptckrealloc((char *) oldPtr,  \
+        (unsigned int) (allocated * sizeof(Tcl_Token)));  \
+      if (newPtr == NULL) {          \
+    allocated = needed + (append) + TCL_MIN_TOKEN_GROWTH;  \
+    if (allocated > TCL_MAX_TOKENS) {      \
+        allocated = TCL_MAX_TOKENS;        \
+    }              \
+    newPtr = (Tcl_Token *) ckrealloc((char *) oldPtr,  \
+      (unsigned int) (allocated * sizeof(Tcl_Token))); \
+      }                \
+      (available) = allocated;          \
+      if (oldPtr == NULL) {          \
+    memcpy(newPtr, staticPtr,        \
+      (size_t) ((used) * sizeof(Tcl_Token)));    \
+      }                \
+      (tokenPtr) = newPtr;          \
   }                \
-  (tokenPtr) = newPtr;            \
-    }                  \
-}
+    } while (0)
 
 #define TclGrowParseTokenArray(parsePtr, append)      \
     TclGrowTokenArray((parsePtr)->tokenPtr, (parsePtr)->numTokens,  \
@@ -3766,12 +4293,54 @@
  */
 
 #define TclUtfToUniChar(str, chPtr) \
-  ((((unsigned char) *(str)) < 0xC0) ? \
-      ((*(chPtr) = (Tcl_UniChar) *(str)), 1) \
+  ((((unsigned char) *(str)) < 0xC0) ?    \
+      ((*(chPtr) = (Tcl_UniChar) *(str)), 1)  \
       : Tcl_UtfToUniChar(str, chPtr))
 
 /*
  *----------------------------------------------------------------
+ * Macro counterpart of the Tcl_NumUtfChars() function. To be used in speed-
+ * -sensitive points where it pays to avoid a function call in the common case
+ * of counting along a string of all one-byte characters.  The ANSI C
+ * "prototype" for this macro is:
+ *
+ * MODULE_SCOPE void  TclNumUtfChars(int numChars, const char *bytes,
+ *        int numBytes);
+ *----------------------------------------------------------------
+ */
+
+#define TclNumUtfChars(numChars, bytes, numBytes) \
+    do { \
+  int count, i = (numBytes); \
+  unsigned char *str = (unsigned char *) (bytes); \
+  while (i && (*str < 0xC0)) { i--; str++; } \
+  count = (numBytes) - i; \
+  if (i) { \
+      count += Tcl_NumUtfChars((bytes) + count, i); \
+  } \
+  (numChars) = count; \
+    } while (0);
+
+/*
+ *----------------------------------------------------------------
+ * Macro that encapsulates the logic that determines when it is safe to
+ * interpret a string as a byte array directly. In summary, the object must be
+ * a byte array and must not have a string representation (as the operations
+ * that it is used in are defined on strings, not byte arrays). Theoretically
+ * it is possible to also be efficient in the case where the object's bytes
+ * field is filled by generation from the byte array (c.f. list canonicality)
+ * but we don't do that at the moment since this is purely about efficiency.
+ * The ANSI C "prototype" for this macro is:
+ *
+ * MODULE_SCOPE int  TclIsPureByteArray(Tcl_Obj *objPtr);
+ *----------------------------------------------------------------
+ */
+
+#define TclIsPureByteArray(objPtr) \
+  (((objPtr)->typePtr==&tclByteArrayType) && ((objPtr)->bytes==NULL))
+
+/*
+ *----------------------------------------------------------------
  * Macro used by the Tcl core to compare Unicode strings. On big-endian
  * systems we can use the more efficient memcmp, but this would not be
  * lexically correct on little-endian systems. The ANSI C "prototype" for
@@ -3798,8 +4367,11 @@
  */
 
 #define TclInvalidateNsCmdLookup(nsPtr) \
-    if ((nsPtr)->numExportPatterns) { \
-  (nsPtr)->exportLookupEpoch++; \
+    if ((nsPtr)->numExportPatterns) {    \
+  (nsPtr)->exportLookupEpoch++;    \
+    }            \
+    if ((nsPtr)->commandPathLength) {    \
+  (nsPtr)->cmdRefEpoch++;      \
     }
 
 /*
@@ -3810,7 +4382,7 @@
  *----------------------------------------------------------------------
  */
 
-MODULE_SCOPE int  TclTommath_Init(Tcl_Interp *interp);
+MODULE_SCOPE Tcl_PackageInitProc TclTommath_Init;
 MODULE_SCOPE void  TclBNInitBignumFromLong(mp_int *bignum, long initVal);
 MODULE_SCOPE void  TclBNInitBignumFromWideInt(mp_int *bignum,
           Tcl_WideInt initVal);
@@ -3818,26 +4390,32 @@
           Tcl_WideUInt initVal);
 
 /*
- *----------------------------------------------------------------
- * Macro used by the Tcl core to check whether a pattern has any characters
- * special to [string match]. The ANSI C "prototype" for this macro is:
+ *----------------------------------------------------------------------
  *
- * MODULE_SCOPE int  TclMatchIsTrivial(const char *pattern);
- *----------------------------------------------------------------
+ * External (platform specific) initialization routine, these declarations
+ * explicitly don't use EXTERN since this code does not get compiled into the
+ * library:
+ *
+ *----------------------------------------------------------------------
  */
 
-#define TclMatchIsTrivial(pattern)  strpbrk((pattern), "*[?\\") == NULL
+MODULE_SCOPE Tcl_PackageInitProc TclplatformtestInit;
+MODULE_SCOPE Tcl_PackageInitProc TclObjTest_Init;
+MODULE_SCOPE Tcl_PackageInitProc TclThread_Init;
+MODULE_SCOPE Tcl_PackageInitProc Procbodytest_Init;
+MODULE_SCOPE Tcl_PackageInitProc Procbodytest_SafeInit;
 
 /*
  *----------------------------------------------------------------
- * Macro used by the Tcl core to write the string rep of a long integer to a
- * character buffer. The ANSI C "prototype" for this macro is:
+ * Macro used by the Tcl core to check whether a pattern has any characters
+ * special to [string match]. The ANSI C "prototype" for this macro is:
  *
- * MODULE_SCOPE int  TclFormatInt(char *buf, long n);
+ * MODULE_SCOPE int  TclMatchIsTrivial(const char *pattern);
  *----------------------------------------------------------------
  */
 
-#define TclFormatInt(buf, n)    sprintf((buf), "%ld", (long)(n))
+#define TclMatchIsTrivial(pattern) \
+    (strpbrk((pattern), "*[?\\") == NULL)
 
 /*
  *----------------------------------------------------------------
@@ -3855,10 +4433,12 @@
  */
 
 #define TclSetIntObj(objPtr, i) \
-    TclInvalidateStringRep(objPtr);\
-    TclFreeIntRep(objPtr); \
-    (objPtr)->internalRep.longValue = (long)(i); \
-    (objPtr)->typePtr = &tclIntType
+    do {            \
+  TclInvalidateStringRep(objPtr);      \
+  TclFreeIntRep(objPtr);        \
+  (objPtr)->internalRep.longValue = (long)(i);  \
+  (objPtr)->typePtr = &tclIntType;    \
+    } while (0)
 
 #define TclSetLongObj(objPtr, l) \
     TclSetIntObj((objPtr), (l))
@@ -3875,17 +4455,21 @@
 
 #ifndef NO_WIDE_TYPE
 #define TclSetWideIntObj(objPtr, w) \
-    TclInvalidateStringRep(objPtr);\
-    TclFreeIntRep(objPtr); \
-    (objPtr)->internalRep.wideValue = (Tcl_WideInt)(w); \
-    (objPtr)->typePtr = &tclWideIntType
+    do {              \
+  TclInvalidateStringRep(objPtr);        \
+  TclFreeIntRep(objPtr);          \
+  (objPtr)->internalRep.wideValue = (Tcl_WideInt)(w);  \
+  (objPtr)->typePtr = &tclWideIntType;      \
+    } while (0)
 #endif
 
 #define TclSetDoubleObj(objPtr, d) \
-    TclInvalidateStringRep(objPtr);\
-    TclFreeIntRep(objPtr); \
-    (objPtr)->internalRep.doubleValue = (double)(d); \
-    (objPtr)->typePtr = &tclDoubleType
+    do {              \
+  TclInvalidateStringRep(objPtr);        \
+  TclFreeIntRep(objPtr);          \
+  (objPtr)->internalRep.doubleValue = (double)(d);  \
+  (objPtr)->typePtr = &tclDoubleType;      \
+    } while (0)
 
 /*
  *----------------------------------------------------------------
@@ -3906,13 +4490,15 @@
 
 #ifndef TCL_MEM_DEBUG
 #define TclNewIntObj(objPtr, i) \
-    TclIncrObjsAllocated(); \
-    TclAllocObjStorage(objPtr); \
-    (objPtr)->refCount = 0; \
-    (objPtr)->bytes = NULL; \
-    (objPtr)->internalRep.longValue = (long)(i); \
-    (objPtr)->typePtr = &tclIntType; \
-    TCL_DTRACE_OBJ_CREATE(objPtr)
+    do {            \
+  TclIncrObjsAllocated();        \
+  TclAllocObjStorage(objPtr);      \
+  (objPtr)->refCount = 0;        \
+  (objPtr)->bytes = NULL;        \
+  (objPtr)->internalRep.longValue = (long)(i);  \
+  (objPtr)->typePtr = &tclIntType;    \
+  TCL_DTRACE_OBJ_CREATE(objPtr);      \
+    } while (0)
 
 #define TclNewLongObj(objPtr, l) \
     TclNewIntObj((objPtr), (l))
@@ -3925,21 +4511,25 @@
     TclNewIntObj((objPtr), ((b)? 1 : 0))
 
 #define TclNewDoubleObj(objPtr, d) \
-    TclIncrObjsAllocated(); \
-    TclAllocObjStorage(objPtr); \
-    (objPtr)->refCount = 0; \
-    (objPtr)->bytes = NULL; \
-    (objPtr)->internalRep.doubleValue = (double)(d); \
-    (objPtr)->typePtr = &tclDoubleType; \
-    TCL_DTRACE_OBJ_CREATE(objPtr)
+    do {              \
+  TclIncrObjsAllocated();          \
+  TclAllocObjStorage(objPtr);        \
+  (objPtr)->refCount = 0;          \
+  (objPtr)->bytes = NULL;          \
+  (objPtr)->internalRep.doubleValue = (double)(d);  \
+  (objPtr)->typePtr = &tclDoubleType;      \
+  TCL_DTRACE_OBJ_CREATE(objPtr);        \
+    } while (0)
 
 #define TclNewStringObj(objPtr, s, len) \
-    TclIncrObjsAllocated(); \
-    TclAllocObjStorage(objPtr); \
-    (objPtr)->refCount = 0; \
-    TclInitStringRep((objPtr), (s), (len));\
-    (objPtr)->typePtr = NULL; \
-    TCL_DTRACE_OBJ_CREATE(objPtr)
+    do {              \
+  TclIncrObjsAllocated();          \
+  TclAllocObjStorage(objPtr);        \
+  (objPtr)->refCount = 0;          \
+  TclInitStringRep((objPtr), (s), (len));      \
+  (objPtr)->typePtr = NULL;        \
+  TCL_DTRACE_OBJ_CREATE(objPtr);        \
+    } while (0)
 
 #else /* TCL_MEM_DEBUG */
 #define TclNewIntObj(objPtr, i) \
@@ -3967,6 +4557,21 @@
 
 /*
  *----------------------------------------------------------------
+ * Convenience macros for DStrings.
+ * The ANSI C "prototypes" for these macros are:
+ *
+ * MODULE_SCOPE char * TclDStringAppendLiteral(Tcl_DString *dsPtr,
+ *      const char *sLiteral);
+ * MODULE_SCOPE void   TclDStringClear(Tcl_DString *dsPtr);
+ */
+
+#define TclDStringAppendLiteral(dsPtr, sLiteral) \
+    Tcl_DStringAppend((dsPtr), (sLiteral), (int) (sizeof(sLiteral "") - 1))
+#define TclDStringClear(dsPtr) \
+    Tcl_DStringSetLength((dsPtr), 0)
+
+/*
+ *----------------------------------------------------------------
  * Macros used by the Tcl core to test for some special double values.
  * The ANSI C "prototypes" for these macros are:
  *
@@ -4000,7 +4605,7 @@
 
 /*
  *----------------------------------------------------------------
- * Inline version of Tcl_GetCurrentNamespace and Tcl_GetGlobalNamespace
+ * Inline version of Tcl_GetCurrentNamespace and Tcl_GetGlobalNamespace.
  */
 
 #define TclGetCurrentNamespace(interp) \
@@ -4044,11 +4649,11 @@
       ? 1 : 0)))
 
 /*
- * Compile-time assertions: these produce a compile time error if
- * the expression is not known to be true at compile time.
- * If the assertion is known to be false, the compiler (or optimizer?) will
- * error out with "division by zero". If the assertion cannot be evaluated at
- * compile time, the compiler will error out with "non-static initializer".
+ * Compile-time assertions: these produce a compile time error if the
+ * expression is not known to be true at compile time. If the assertion is
+ * known to be false, the compiler (or optimizer?) will error out with
+ * "division by zero". If the assertion cannot be evaluated at compile time,
+ * the compiler will error out with "non-static initializer".
  *
  * Adapted with permission from
  * http://www.pixelbeat.org/programming/gcc/static_assert.html
@@ -4068,46 +4673,65 @@
  *----------------------------------------------------------------
  */
 
-#define TclSmallAlloc(nbytes, memPtr)    \
+#define TclSmallAlloc(nbytes, memPtr) \
     TclSmallAllocEx(NULL, (nbytes), (memPtr))
 
-#define TclSmallFree(memPtr)      \
+#define TclSmallFree(memPtr) \
     TclSmallFreeEx(NULL, (memPtr))
 
 #ifndef TCL_MEM_DEBUG
-#define TclSmallAllocEx(interp, nbytes, memPtr)        \
-    {                  \
+#define TclSmallAllocEx(interp, nbytes, memPtr) \
+    do {                \
   Tcl_Obj *objPtr;            \
   TCL_CT_ASSERT((nbytes)<=sizeof(Tcl_Obj));      \
   TclIncrObjsAllocated();            \
   TclAllocObjStorageEx((interp), (objPtr));      \
   memPtr = (ClientData) (objPtr);          \
-    }
+    } while (0)
 
-#define TclSmallFreeEx(interp, memPtr)    \
-    TclFreeObjStorageEx((interp), (Tcl_Obj *) (memPtr));  \
-    TclIncrObjsFreed()
+#define TclSmallFreeEx(interp, memPtr) \
+    do {                \
+  TclFreeObjStorageEx((interp), (Tcl_Obj *) (memPtr));    \
+  TclIncrObjsFreed();            \
+    } while (0)
 
 #else    /* TCL_MEM_DEBUG */
-#define TclSmallAllocEx(interp, nbytes, memPtr)        \
-    {                  \
+#define TclSmallAllocEx(interp, nbytes, memPtr) \
+    do {                \
   Tcl_Obj *objPtr;            \
   TCL_CT_ASSERT((nbytes)<=sizeof(Tcl_Obj));      \
   TclNewObj(objPtr);            \
   memPtr = (ClientData) objPtr;          \
-    }
+    } while (0)
 
-#define TclSmallFreeEx(interp, memPtr)          \
-    {                  \
+#define TclSmallFreeEx(interp, memPtr) \
+    do {                \
   Tcl_Obj *objPtr = (Tcl_Obj *) memPtr;        \
   objPtr->bytes = NULL;            \
   objPtr->typePtr = NULL;            \
   objPtr->refCount = 1;            \
   TclDecrRefCount(objPtr);          \
-    }
+    } while (0)
 #endif   /* TCL_MEM_DEBUG */
 
 /*
+ * Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>
+ */
+
+#if defined(PURIFY) && defined(__clang__)
+#if __has_feature(attribute_analyzer_noreturn) && \
+  !defined(Tcl_Panic) && defined(Tcl_Panic_TCL_DECLARED)
+void Tcl_Panic(const char *, ...) __attribute__((analyzer_noreturn));
+#endif
+#if !defined(CLANG_ASSERT)
+#include <assert.h>
+#define CLANG_ASSERT(x) assert(x)
+#endif
+#elif !defined(CLANG_ASSERT)
+#define CLANG_ASSERT(x)
+#endif /* PURIFY && __clang__ */
+
+/*
  *----------------------------------------------------------------
  * Parameters, structs and macros for the non-recursive engine (NRE)
  *----------------------------------------------------------------
@@ -4122,44 +4746,67 @@
  * available.
  */
 
-typedef struct TEOV_callback {
+typedef struct NRE_callback {
     Tcl_NRPostProc *procPtr;
     ClientData data[4];
-    struct TEOV_callback *nextPtr;
-} TEOV_callback;
-    
+    struct NRE_callback *nextPtr;
+} NRE_callback;
+
 #define TOP_CB(iPtr) (((Interp *)(iPtr))->execEnvPtr->callbackPtr)
 
 /*
- * Inline version of Tcl_NRAddCallback
+ * Inline version of Tcl_NRAddCallback.
  */
 
-#define TclNRAddCallback(            \
-    interp,                \
-    postProcPtr,              \
-    data0,                \
-    data1,                \
-    data2,                \
-    data3)                \
-    {                  \
-  TEOV_callback *callbackPtr;          \
+#define TclNRAddCallback(interp,postProcPtr,data0,data1,data2,data3) \
+    do {                \
+  NRE_callback *callbackPtr;          \
   TCLNR_ALLOC((interp), (callbackPtr));        \
   callbackPtr->procPtr = (postProcPtr);        \
-  callbackPtr->data[0] = (data0);          \
-  callbackPtr->data[1] = (data1);          \
-  callbackPtr->data[2] = (data2);          \
-  callbackPtr->data[3] = (data3);          \
+  callbackPtr->data[0] = (ClientData)(data0);      \
+  callbackPtr->data[1] = (ClientData)(data1);      \
+  callbackPtr->data[2] = (ClientData)(data2);      \
+  callbackPtr->data[3] = (ClientData)(data3);      \
   callbackPtr->nextPtr = TOP_CB(interp);        \
   TOP_CB(interp) = callbackPtr;          \
+    } while (0)
+
+#define TclNRDeferCallback(interp,postProcPtr,data0,data1,data2,data3) \
+    do {                \
+  NRE_callback *callbackPtr;          \
+  TCLNR_ALLOC((interp), (callbackPtr));        \
+  callbackPtr->procPtr = (postProcPtr);        \
+  callbackPtr->data[0] = (ClientData)(data0);      \
+  callbackPtr->data[1] = (ClientData)(data1);      \
+  callbackPtr->data[2] = (ClientData)(data2);      \
+  callbackPtr->data[3] = (ClientData)(data3);      \
+  callbackPtr->nextPtr = ((Interp *)interp)->deferredCallbacks;  \
+  ((Interp *)interp)->deferredCallbacks = callbackPtr;    \
+    } while (0)
+
+#define TclNRSpliceCallbacks(interp, topPtr) \
+    do {          \
+  NRE_callback *bottomPtr = topPtr;  \
+  while (bottomPtr->nextPtr) {    \
+      bottomPtr = bottomPtr->nextPtr;  \
+  }          \
+  bottomPtr->nextPtr = TOP_CB(interp);  \
+  TOP_CB(interp) = topPtr;    \
+    } while (0)
+
+#define TclNRSpliceDeferred(interp)          \
+    if (((Interp *)interp)->deferredCallbacks) {      \
+  TclNRSpliceCallbacks(interp, ((Interp *)interp)->deferredCallbacks); \
+  ((Interp *)interp)->deferredCallbacks = NULL;      \
     }
 
 #if NRE_USE_SMALL_ALLOC
 #define TCLNR_ALLOC(interp, ptr) \
-    TclSmallAllocEx(interp, sizeof(TEOV_callback), (ptr))
+    TclSmallAllocEx(interp, sizeof(NRE_callback), (ptr))
 #define TCLNR_FREE(interp, ptr)  TclSmallFreeEx((interp), (ptr))
 #else
 #define TCLNR_ALLOC(interp, ptr) \
-    (ptr = ((ClientData) ckalloc(sizeof(TEOV_callback))))
+    (ptr = ((ClientData) ckalloc(sizeof(NRE_callback))))
 #define TCLNR_FREE(interp, ptr)  ckfree((char *) (ptr))
 #endif
 
@@ -4169,13 +4816,18 @@
 #define NRE_ASSERT(expr)
 #endif
 
-#include "tclPort.h"
 #include "tclIntDecls.h"
 #include "tclIntPlatDecls.h"
 #include "tclTomMathDecls.h"
 
+#if !defined(USE_TCL_STUBS) && !defined(TCL_MEM_DEBUG)
+#define Tcl_AttemptAlloc(size)        TclpAlloc(size)
+#define Tcl_AttemptRealloc(ptr, size) TclpRealloc((ptr), (size))
+#define Tcl_Free(ptr)                 TclpFree(ptr)
+#endif
+
 #endif /* _TCLINT */
-
+
 /*
  * Local Variables:
  * mode: c
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclIntDecls.h vtk5.10/Utilities/TclTk/internals/tk8.6/tclIntDecls.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclIntDecls.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tclIntDecls.h	2019-02-01 16:20:04.000000000 +0100
@@ -10,8 +10,6 @@
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TCLINTDECLS
@@ -30,6 +28,21 @@
 #   endif
 #endif
 
+/* [Bug #803489] Tcl_FindNamespace problem in the Stubs table */
+#undef Tcl_AppendExportList
+#undef Tcl_CreateNamespace
+#undef Tcl_DeleteNamespace
+#undef Tcl_Export
+#undef Tcl_FindCommand
+#undef Tcl_FindNamespace
+#undef Tcl_FindNamespaceVar
+#undef Tcl_ForgetImport
+#undef Tcl_GetCommandFromObj
+#undef Tcl_GetCommandFullName
+#undef Tcl_GetCurrentNamespace
+#undef Tcl_GetGlobalNamespace
+#undef Tcl_Import
+
 /*
  * WARNING: This file is automatically generated by the tools/genStubs.tcl
  * script.  Any modifications to the function declarations below should be made
@@ -45,832 +58,403 @@
 /* Slot 0 is reserved */
 /* Slot 1 is reserved */
 /* Slot 2 is reserved */
-#ifndef TclAllocateFreeObjects_TCL_DECLARED
-#define TclAllocateFreeObjects_TCL_DECLARED
 /* 3 */
-EXTERN void    TclAllocateFreeObjects (void);
-#endif
+EXTERN void    TclAllocateFreeObjects(void);
 /* Slot 4 is reserved */
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-#ifndef TclCleanupChildren_TCL_DECLARED
-#define TclCleanupChildren_TCL_DECLARED
 /* 5 */
-EXTERN int    TclCleanupChildren (Tcl_Interp * interp, int numPids, 
-        Tcl_Pid * pidPtr, Tcl_Channel errorChan);
-#endif
-#endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
-#ifndef TclCleanupChildren_TCL_DECLARED
-#define TclCleanupChildren_TCL_DECLARED
-/* 5 */
-EXTERN int    TclCleanupChildren (Tcl_Interp * interp, int numPids, 
-        Tcl_Pid * pidPtr, Tcl_Channel errorChan);
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TCL /* MACOSX */
-#ifndef TclCleanupChildren_TCL_DECLARED
-#define TclCleanupChildren_TCL_DECLARED
-/* 5 */
-EXTERN int    TclCleanupChildren (Tcl_Interp * interp, int numPids, 
-        Tcl_Pid * pidPtr, Tcl_Channel errorChan);
-#endif
-#endif /* MACOSX */
-#ifndef TclCleanupCommand_TCL_DECLARED
-#define TclCleanupCommand_TCL_DECLARED
+EXTERN int    TclCleanupChildren(Tcl_Interp *interp, int numPids,
+        Tcl_Pid *pidPtr, Tcl_Channel errorChan);
 /* 6 */
-EXTERN void    TclCleanupCommand (Command * cmdPtr);
-#endif
-#ifndef TclCopyAndCollapse_TCL_DECLARED
-#define TclCopyAndCollapse_TCL_DECLARED
+EXTERN void    TclCleanupCommand(Command *cmdPtr);
 /* 7 */
-EXTERN int    TclCopyAndCollapse (int count, CONST char * src, 
-        char * dst);
-#endif
-#ifndef TclCopyChannel_TCL_DECLARED
-#define TclCopyChannel_TCL_DECLARED
+EXTERN int    TclCopyAndCollapse(int count, const char *src,
+        char *dst);
 /* 8 */
-EXTERN int    TclCopyChannel (Tcl_Interp * interp, 
-        Tcl_Channel inChan, Tcl_Channel outChan, 
-        int toRead, Tcl_Obj * cmdPtr);
-#endif
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-#ifndef TclCreatePipeline_TCL_DECLARED
-#define TclCreatePipeline_TCL_DECLARED
+EXTERN int    TclCopyChannelOld(Tcl_Interp *interp,
+        Tcl_Channel inChan, Tcl_Channel outChan,
+        int toRead, Tcl_Obj *cmdPtr);
 /* 9 */
-EXTERN int    TclCreatePipeline (Tcl_Interp * interp, int argc, 
-        CONST char ** argv, Tcl_Pid ** pidArrayPtr, 
-        TclFile * inPipePtr, TclFile * outPipePtr, 
-        TclFile * errFilePtr);
-#endif
-#endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
-#ifndef TclCreatePipeline_TCL_DECLARED
-#define TclCreatePipeline_TCL_DECLARED
-/* 9 */
-EXTERN int    TclCreatePipeline (Tcl_Interp * interp, int argc, 
-        CONST char ** argv, Tcl_Pid ** pidArrayPtr, 
-        TclFile * inPipePtr, TclFile * outPipePtr, 
-        TclFile * errFilePtr);
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TCL /* MACOSX */
-#ifndef TclCreatePipeline_TCL_DECLARED
-#define TclCreatePipeline_TCL_DECLARED
-/* 9 */
-EXTERN int    TclCreatePipeline (Tcl_Interp * interp, int argc, 
-        CONST char ** argv, Tcl_Pid ** pidArrayPtr, 
-        TclFile * inPipePtr, TclFile * outPipePtr, 
-        TclFile * errFilePtr);
-#endif
-#endif /* MACOSX */
-#ifndef TclCreateProc_TCL_DECLARED
-#define TclCreateProc_TCL_DECLARED
+EXTERN int    TclCreatePipeline(Tcl_Interp *interp, int argc,
+        const char **argv, Tcl_Pid **pidArrayPtr,
+        TclFile *inPipePtr, TclFile *outPipePtr,
+        TclFile *errFilePtr);
 /* 10 */
-EXTERN int    TclCreateProc (Tcl_Interp * interp, 
-        Namespace * nsPtr, CONST char * procName, 
-        Tcl_Obj * argsPtr, Tcl_Obj * bodyPtr, 
-        Proc ** procPtrPtr);
-#endif
-#ifndef TclDeleteCompiledLocalVars_TCL_DECLARED
-#define TclDeleteCompiledLocalVars_TCL_DECLARED
+EXTERN int    TclCreateProc(Tcl_Interp *interp, Namespace *nsPtr,
+        const char *procName, Tcl_Obj *argsPtr,
+        Tcl_Obj *bodyPtr, Proc **procPtrPtr);
 /* 11 */
-EXTERN void    TclDeleteCompiledLocalVars (Interp * iPtr, 
-        CallFrame * framePtr);
-#endif
-#ifndef TclDeleteVars_TCL_DECLARED
-#define TclDeleteVars_TCL_DECLARED
+EXTERN void    TclDeleteCompiledLocalVars(Interp *iPtr,
+        CallFrame *framePtr);
 /* 12 */
-EXTERN void    TclDeleteVars (Interp * iPtr, 
-        TclVarHashTable * tablePtr);
-#endif
+EXTERN void    TclDeleteVars(Interp *iPtr,
+        TclVarHashTable *tablePtr);
 /* Slot 13 is reserved */
-#ifndef TclDumpMemoryInfo_TCL_DECLARED
-#define TclDumpMemoryInfo_TCL_DECLARED
 /* 14 */
-EXTERN void    TclDumpMemoryInfo (FILE * outFile);
-#endif
+EXTERN int    TclDumpMemoryInfo(ClientData clientData, int flags);
 /* Slot 15 is reserved */
-#ifndef TclExprFloatError_TCL_DECLARED
-#define TclExprFloatError_TCL_DECLARED
 /* 16 */
-EXTERN void    TclExprFloatError (Tcl_Interp * interp, double value);
-#endif
+EXTERN void    TclExprFloatError(Tcl_Interp *interp, double value);
 /* Slot 17 is reserved */
 /* Slot 18 is reserved */
 /* Slot 19 is reserved */
 /* Slot 20 is reserved */
 /* Slot 21 is reserved */
-#ifndef TclFindElement_TCL_DECLARED
-#define TclFindElement_TCL_DECLARED
 /* 22 */
-EXTERN int    TclFindElement (Tcl_Interp * interp, 
-        CONST char * listStr, int listLength, 
-        CONST char ** elementPtr, 
-        CONST char ** nextPtr, int * sizePtr, 
-        int * bracePtr);
-#endif
-#ifndef TclFindProc_TCL_DECLARED
-#define TclFindProc_TCL_DECLARED
+EXTERN int    TclFindElement(Tcl_Interp *interp,
+        const char *listStr, int listLength,
+        const char **elementPtr,
+        const char **nextPtr, int *sizePtr,
+        int *bracePtr);
 /* 23 */
-EXTERN Proc *    TclFindProc (Interp * iPtr, CONST char * procName);
-#endif
-/* Slot 24 is reserved */
-#ifndef TclFreePackageInfo_TCL_DECLARED
-#define TclFreePackageInfo_TCL_DECLARED
+EXTERN Proc *    TclFindProc(Interp *iPtr, const char *procName);
+/* 24 */
+EXTERN int    TclFormatInt(char *buffer, long n);
 /* 25 */
-EXTERN void    TclFreePackageInfo (Interp * iPtr);
-#endif
+EXTERN void    TclFreePackageInfo(Interp *iPtr);
 /* Slot 26 is reserved */
 /* Slot 27 is reserved */
-#ifndef TclpGetDefaultStdChannel_TCL_DECLARED
-#define TclpGetDefaultStdChannel_TCL_DECLARED
 /* 28 */
-EXTERN Tcl_Channel  TclpGetDefaultStdChannel (int type);
-#endif
+EXTERN Tcl_Channel  TclpGetDefaultStdChannel(int type);
 /* Slot 29 is reserved */
 /* Slot 30 is reserved */
-#ifndef TclGetExtension_TCL_DECLARED
-#define TclGetExtension_TCL_DECLARED
 /* 31 */
-EXTERN CONST char *  TclGetExtension (CONST char * name);
-#endif
-#ifndef TclGetFrame_TCL_DECLARED
-#define TclGetFrame_TCL_DECLARED
+EXTERN const char *  TclGetExtension(const char *name);
 /* 32 */
-EXTERN int    TclGetFrame (Tcl_Interp * interp, CONST char * str, 
-        CallFrame ** framePtrPtr);
-#endif
+EXTERN int    TclGetFrame(Tcl_Interp *interp, const char *str,
+        CallFrame **framePtrPtr);
 /* Slot 33 is reserved */
-#ifndef TclGetIntForIndex_TCL_DECLARED
-#define TclGetIntForIndex_TCL_DECLARED
 /* 34 */
-EXTERN int    TclGetIntForIndex (Tcl_Interp * interp, 
-        Tcl_Obj * objPtr, int endValue, 
-        int * indexPtr);
-#endif
+EXTERN int    TclGetIntForIndex(Tcl_Interp *interp,
+        Tcl_Obj *objPtr, int endValue, int *indexPtr);
 /* Slot 35 is reserved */
 /* Slot 36 is reserved */
-#ifndef TclGetLoadedPackages_TCL_DECLARED
-#define TclGetLoadedPackages_TCL_DECLARED
 /* 37 */
-EXTERN int    TclGetLoadedPackages (Tcl_Interp * interp, 
-        char * targetName);
-#endif
-#ifndef TclGetNamespaceForQualName_TCL_DECLARED
-#define TclGetNamespaceForQualName_TCL_DECLARED
+EXTERN int    TclGetLoadedPackages(Tcl_Interp *interp,
+        const char *targetName);
 /* 38 */
-EXTERN int    TclGetNamespaceForQualName (Tcl_Interp * interp, 
-        CONST char * qualName, Namespace * cxtNsPtr, 
-        int flags, Namespace ** nsPtrPtr, 
-        Namespace ** altNsPtrPtr, 
-        Namespace ** actualCxtPtrPtr, 
-        CONST char ** simpleNamePtr);
-#endif
-#ifndef TclGetObjInterpProc_TCL_DECLARED
-#define TclGetObjInterpProc_TCL_DECLARED
+EXTERN int    TclGetNamespaceForQualName(Tcl_Interp *interp,
+        const char *qualName, Namespace *cxtNsPtr,
+        int flags, Namespace **nsPtrPtr,
+        Namespace **altNsPtrPtr,
+        Namespace **actualCxtPtrPtr,
+        const char **simpleNamePtr);
 /* 39 */
-EXTERN TclObjCmdProcType TclGetObjInterpProc (void);
-#endif
-#ifndef TclGetOpenMode_TCL_DECLARED
-#define TclGetOpenMode_TCL_DECLARED
+EXTERN TclObjCmdProcType TclGetObjInterpProc(void);
 /* 40 */
-EXTERN int    TclGetOpenMode (Tcl_Interp * interp, 
-        CONST char * str, int * seekFlagPtr);
-#endif
-#ifndef TclGetOriginalCommand_TCL_DECLARED
-#define TclGetOriginalCommand_TCL_DECLARED
+EXTERN int    TclGetOpenMode(Tcl_Interp *interp, const char *str,
+        int *seekFlagPtr);
 /* 41 */
-EXTERN Tcl_Command  TclGetOriginalCommand (Tcl_Command command);
-#endif
-#ifndef TclpGetUserHome_TCL_DECLARED
-#define TclpGetUserHome_TCL_DECLARED
+EXTERN Tcl_Command  TclGetOriginalCommand(Tcl_Command command);
 /* 42 */
-EXTERN char *    TclpGetUserHome (CONST char * name, 
-        Tcl_DString * bufferPtr);
-#endif
+EXTERN CONST86 char *  TclpGetUserHome(const char *name,
+        Tcl_DString *bufferPtr);
 /* Slot 43 is reserved */
-#ifndef TclGuessPackageName_TCL_DECLARED
-#define TclGuessPackageName_TCL_DECLARED
 /* 44 */
-EXTERN int    TclGuessPackageName (CONST char * fileName, 
-        Tcl_DString * bufPtr);
-#endif
-#ifndef TclHideUnsafeCommands_TCL_DECLARED
-#define TclHideUnsafeCommands_TCL_DECLARED
+EXTERN int    TclGuessPackageName(const char *fileName,
+        Tcl_DString *bufPtr);
 /* 45 */
-EXTERN int    TclHideUnsafeCommands (Tcl_Interp * interp);
-#endif
-#ifndef TclInExit_TCL_DECLARED
-#define TclInExit_TCL_DECLARED
+EXTERN int    TclHideUnsafeCommands(Tcl_Interp *interp);
 /* 46 */
-EXTERN int    TclInExit (void);
-#endif
+EXTERN int    TclInExit(void);
 /* Slot 47 is reserved */
 /* Slot 48 is reserved */
 /* Slot 49 is reserved */
-#ifndef TclInitCompiledLocals_TCL_DECLARED
-#define TclInitCompiledLocals_TCL_DECLARED
 /* 50 */
-EXTERN void    TclInitCompiledLocals (Tcl_Interp * interp, 
-        CallFrame * framePtr, Namespace * nsPtr);
-#endif
-#ifndef TclInterpInit_TCL_DECLARED
-#define TclInterpInit_TCL_DECLARED
+EXTERN void    TclInitCompiledLocals(Tcl_Interp *interp,
+        CallFrame *framePtr, Namespace *nsPtr);
 /* 51 */
-EXTERN int    TclInterpInit (Tcl_Interp * interp);
-#endif
+EXTERN int    TclInterpInit(Tcl_Interp *interp);
 /* Slot 52 is reserved */
-#ifndef TclInvokeObjectCommand_TCL_DECLARED
-#define TclInvokeObjectCommand_TCL_DECLARED
 /* 53 */
-EXTERN int    TclInvokeObjectCommand (ClientData clientData, 
-        Tcl_Interp * interp, int argc, 
-        CONST84 char ** argv);
-#endif
-#ifndef TclInvokeStringCommand_TCL_DECLARED
-#define TclInvokeStringCommand_TCL_DECLARED
+EXTERN int    TclInvokeObjectCommand(ClientData clientData,
+        Tcl_Interp *interp, int argc,
+        CONST84 char **argv);
 /* 54 */
-EXTERN int    TclInvokeStringCommand (ClientData clientData, 
-        Tcl_Interp * interp, int objc, 
-        Tcl_Obj *CONST objv[]);
-#endif
-#ifndef TclIsProc_TCL_DECLARED
-#define TclIsProc_TCL_DECLARED
+EXTERN int    TclInvokeStringCommand(ClientData clientData,
+        Tcl_Interp *interp, int objc,
+        Tcl_Obj *const objv[]);
 /* 55 */
-EXTERN Proc *    TclIsProc (Command * cmdPtr);
-#endif
+EXTERN Proc *    TclIsProc(Command *cmdPtr);
 /* Slot 56 is reserved */
 /* Slot 57 is reserved */
-#ifndef TclLookupVar_TCL_DECLARED
-#define TclLookupVar_TCL_DECLARED
 /* 58 */
-EXTERN Var *    TclLookupVar (Tcl_Interp * interp, 
-        CONST char * part1, CONST char * part2, 
-        int flags, CONST char * msg, int createPart1, 
-        int createPart2, Var ** arrayPtrPtr);
-#endif
+EXTERN Var *    TclLookupVar(Tcl_Interp *interp, const char *part1,
+        const char *part2, int flags,
+        const char *msg, int createPart1,
+        int createPart2, Var **arrayPtrPtr);
 /* Slot 59 is reserved */
-#ifndef TclNeedSpace_TCL_DECLARED
-#define TclNeedSpace_TCL_DECLARED
 /* 60 */
-EXTERN int    TclNeedSpace (CONST char * start, CONST char * end);
-#endif
-#ifndef TclNewProcBodyObj_TCL_DECLARED
-#define TclNewProcBodyObj_TCL_DECLARED
+EXTERN int    TclNeedSpace(const char *start, const char *end);
 /* 61 */
-EXTERN Tcl_Obj *  TclNewProcBodyObj (Proc * procPtr);
-#endif
-#ifndef TclObjCommandComplete_TCL_DECLARED
-#define TclObjCommandComplete_TCL_DECLARED
+EXTERN Tcl_Obj *  TclNewProcBodyObj(Proc *procPtr);
 /* 62 */
-EXTERN int    TclObjCommandComplete (Tcl_Obj * cmdPtr);
-#endif
-#ifndef TclObjInterpProc_TCL_DECLARED
-#define TclObjInterpProc_TCL_DECLARED
+EXTERN int    TclObjCommandComplete(Tcl_Obj *cmdPtr);
 /* 63 */
-EXTERN int    TclObjInterpProc (ClientData clientData, 
-        Tcl_Interp * interp, int objc, 
-        Tcl_Obj *CONST objv[]);
-#endif
-#ifndef TclObjInvoke_TCL_DECLARED
-#define TclObjInvoke_TCL_DECLARED
+EXTERN int    TclObjInterpProc(ClientData clientData,
+        Tcl_Interp *interp, int objc,
+        Tcl_Obj *const objv[]);
 /* 64 */
-EXTERN int    TclObjInvoke (Tcl_Interp * interp, int objc, 
-        Tcl_Obj *CONST objv[], int flags);
-#endif
+EXTERN int    TclObjInvoke(Tcl_Interp *interp, int objc,
+        Tcl_Obj *const objv[], int flags);
 /* Slot 65 is reserved */
 /* Slot 66 is reserved */
 /* Slot 67 is reserved */
 /* Slot 68 is reserved */
-#ifndef TclpAlloc_TCL_DECLARED
-#define TclpAlloc_TCL_DECLARED
 /* 69 */
-EXTERN char *    TclpAlloc (unsigned int size);
-#endif
+EXTERN char *    TclpAlloc(unsigned int size);
 /* Slot 70 is reserved */
 /* Slot 71 is reserved */
 /* Slot 72 is reserved */
 /* Slot 73 is reserved */
-#ifndef TclpFree_TCL_DECLARED
-#define TclpFree_TCL_DECLARED
 /* 74 */
-EXTERN void    TclpFree (char * ptr);
-#endif
-#ifndef TclpGetClicks_TCL_DECLARED
-#define TclpGetClicks_TCL_DECLARED
+EXTERN void    TclpFree(char *ptr);
 /* 75 */
-EXTERN unsigned long  TclpGetClicks (void);
-#endif
-#ifndef TclpGetSeconds_TCL_DECLARED
-#define TclpGetSeconds_TCL_DECLARED
+EXTERN unsigned long  TclpGetClicks(void);
 /* 76 */
-EXTERN unsigned long  TclpGetSeconds (void);
-#endif
-#ifndef TclpGetTime_TCL_DECLARED
-#define TclpGetTime_TCL_DECLARED
+EXTERN unsigned long  TclpGetSeconds(void);
 /* 77 */
-EXTERN void    TclpGetTime (Tcl_Time * time);
-#endif
-#ifndef TclpGetTimeZone_TCL_DECLARED
-#define TclpGetTimeZone_TCL_DECLARED
-/* 78 */
-EXTERN int    TclpGetTimeZone (unsigned long time);
-#endif
+EXTERN void    TclpGetTime(Tcl_Time *time);
+/* Slot 78 is reserved */
 /* Slot 79 is reserved */
 /* Slot 80 is reserved */
-#ifndef TclpRealloc_TCL_DECLARED
-#define TclpRealloc_TCL_DECLARED
 /* 81 */
-EXTERN char *    TclpRealloc (char * ptr, unsigned int size);
-#endif
+EXTERN char *    TclpRealloc(char *ptr, unsigned int size);
 /* Slot 82 is reserved */
 /* Slot 83 is reserved */
 /* Slot 84 is reserved */
 /* Slot 85 is reserved */
 /* Slot 86 is reserved */
 /* Slot 87 is reserved */
-#ifndef TclPrecTraceProc_TCL_DECLARED
-#define TclPrecTraceProc_TCL_DECLARED
 /* 88 */
-EXTERN char *    TclPrecTraceProc (ClientData clientData, 
-        Tcl_Interp * interp, CONST char * name1, 
-        CONST char * name2, int flags);
-#endif
-#ifndef TclPreventAliasLoop_TCL_DECLARED
-#define TclPreventAliasLoop_TCL_DECLARED
+EXTERN char *    TclPrecTraceProc(ClientData clientData,
+        Tcl_Interp *interp, const char *name1,
+        const char *name2, int flags);
 /* 89 */
-EXTERN int    TclPreventAliasLoop (Tcl_Interp * interp, 
-        Tcl_Interp * cmdInterp, Tcl_Command cmd);
-#endif
+EXTERN int    TclPreventAliasLoop(Tcl_Interp *interp,
+        Tcl_Interp *cmdInterp, Tcl_Command cmd);
 /* Slot 90 is reserved */
-#ifndef TclProcCleanupProc_TCL_DECLARED
-#define TclProcCleanupProc_TCL_DECLARED
 /* 91 */
-EXTERN void    TclProcCleanupProc (Proc * procPtr);
-#endif
-#ifndef TclProcCompileProc_TCL_DECLARED
-#define TclProcCompileProc_TCL_DECLARED
+EXTERN void    TclProcCleanupProc(Proc *procPtr);
 /* 92 */
-EXTERN int    TclProcCompileProc (Tcl_Interp * interp, 
-        Proc * procPtr, Tcl_Obj * bodyPtr, 
-        Namespace * nsPtr, CONST char * description, 
-        CONST char * procName);
-#endif
-#ifndef TclProcDeleteProc_TCL_DECLARED
-#define TclProcDeleteProc_TCL_DECLARED
+EXTERN int    TclProcCompileProc(Tcl_Interp *interp, Proc *procPtr,
+        Tcl_Obj *bodyPtr, Namespace *nsPtr,
+        const char *description,
+        const char *procName);
 /* 93 */
-EXTERN void    TclProcDeleteProc (ClientData clientData);
-#endif
+EXTERN void    TclProcDeleteProc(ClientData clientData);
 /* Slot 94 is reserved */
 /* Slot 95 is reserved */
-#ifndef TclRenameCommand_TCL_DECLARED
-#define TclRenameCommand_TCL_DECLARED
 /* 96 */
-EXTERN int    TclRenameCommand (Tcl_Interp * interp, 
-        CONST char * oldName, CONST char * newName);
-#endif
-#ifndef TclResetShadowedCmdRefs_TCL_DECLARED
-#define TclResetShadowedCmdRefs_TCL_DECLARED
+EXTERN int    TclRenameCommand(Tcl_Interp *interp,
+        const char *oldName, const char *newName);
 /* 97 */
-EXTERN void    TclResetShadowedCmdRefs (Tcl_Interp * interp, 
-        Command * newCmdPtr);
-#endif
-#ifndef TclServiceIdle_TCL_DECLARED
-#define TclServiceIdle_TCL_DECLARED
+EXTERN void    TclResetShadowedCmdRefs(Tcl_Interp *interp,
+        Command *newCmdPtr);
 /* 98 */
-EXTERN int    TclServiceIdle (void);
-#endif
+EXTERN int    TclServiceIdle(void);
 /* Slot 99 is reserved */
 /* Slot 100 is reserved */
-#ifndef TclSetPreInitScript_TCL_DECLARED
-#define TclSetPreInitScript_TCL_DECLARED
 /* 101 */
-EXTERN char *    TclSetPreInitScript (char * string);
-#endif
-#ifndef TclSetupEnv_TCL_DECLARED
-#define TclSetupEnv_TCL_DECLARED
+EXTERN CONST86 char *  TclSetPreInitScript(const char *string);
 /* 102 */
-EXTERN void    TclSetupEnv (Tcl_Interp * interp);
-#endif
-#ifndef TclSockGetPort_TCL_DECLARED
-#define TclSockGetPort_TCL_DECLARED
+EXTERN void    TclSetupEnv(Tcl_Interp *interp);
 /* 103 */
-EXTERN int    TclSockGetPort (Tcl_Interp * interp, 
-        CONST char * str, CONST char * proto, 
-        int * portPtr);
-#endif
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-#ifndef TclSockMinimumBuffers_TCL_DECLARED
-#define TclSockMinimumBuffers_TCL_DECLARED
+EXTERN int    TclSockGetPort(Tcl_Interp *interp, const char *str,
+        const char *proto, int *portPtr);
 /* 104 */
-EXTERN int    TclSockMinimumBuffers (int sock, int size);
-#endif
-#endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
-#ifndef TclSockMinimumBuffers_TCL_DECLARED
-#define TclSockMinimumBuffers_TCL_DECLARED
-/* 104 */
-EXTERN int    TclSockMinimumBuffers (int sock, int size);
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TCL /* MACOSX */
-#ifndef TclSockMinimumBuffers_TCL_DECLARED
-#define TclSockMinimumBuffers_TCL_DECLARED
-/* 104 */
-EXTERN int    TclSockMinimumBuffers (int sock, int size);
-#endif
-#endif /* MACOSX */
+EXTERN int    TclSockMinimumBuffersOld(int sock, int size);
 /* Slot 105 is reserved */
 /* Slot 106 is reserved */
 /* Slot 107 is reserved */
-#ifndef TclTeardownNamespace_TCL_DECLARED
-#define TclTeardownNamespace_TCL_DECLARED
 /* 108 */
-EXTERN void    TclTeardownNamespace (Namespace * nsPtr);
-#endif
-#ifndef TclUpdateReturnInfo_TCL_DECLARED
-#define TclUpdateReturnInfo_TCL_DECLARED
+EXTERN void    TclTeardownNamespace(Namespace *nsPtr);
 /* 109 */
-EXTERN int    TclUpdateReturnInfo (Interp * iPtr);
-#endif
-/* Slot 110 is reserved */
-#ifndef Tcl_AddInterpResolvers_TCL_DECLARED
-#define Tcl_AddInterpResolvers_TCL_DECLARED
+EXTERN int    TclUpdateReturnInfo(Interp *iPtr);
+/* 110 */
+EXTERN int    TclSockMinimumBuffers(void *sock, int size);
 /* 111 */
-EXTERN void    Tcl_AddInterpResolvers (Tcl_Interp * interp, 
-        CONST char * name, 
-        Tcl_ResolveCmdProc * cmdProc, 
-        Tcl_ResolveVarProc * varProc, 
-        Tcl_ResolveCompiledVarProc * compiledVarProc);
-#endif
-#ifndef Tcl_AppendExportList_TCL_DECLARED
-#define Tcl_AppendExportList_TCL_DECLARED
+EXTERN void    Tcl_AddInterpResolvers(Tcl_Interp *interp,
+        const char *name,
+        Tcl_ResolveCmdProc *cmdProc,
+        Tcl_ResolveVarProc *varProc,
+        Tcl_ResolveCompiledVarProc *compiledVarProc);
 /* 112 */
-EXTERN int    Tcl_AppendExportList (Tcl_Interp * interp, 
-        Tcl_Namespace * nsPtr, Tcl_Obj * objPtr);
-#endif
-#ifndef Tcl_CreateNamespace_TCL_DECLARED
-#define Tcl_CreateNamespace_TCL_DECLARED
+EXTERN int    Tcl_AppendExportList(Tcl_Interp *interp,
+        Tcl_Namespace *nsPtr, Tcl_Obj *objPtr);
 /* 113 */
-EXTERN Tcl_Namespace *  Tcl_CreateNamespace (Tcl_Interp * interp, 
-        CONST char * name, ClientData clientData, 
-        Tcl_NamespaceDeleteProc * deleteProc);
-#endif
-#ifndef Tcl_DeleteNamespace_TCL_DECLARED
-#define Tcl_DeleteNamespace_TCL_DECLARED
+EXTERN Tcl_Namespace *  Tcl_CreateNamespace(Tcl_Interp *interp,
+        const char *name, ClientData clientData,
+        Tcl_NamespaceDeleteProc *deleteProc);
 /* 114 */
-EXTERN void    Tcl_DeleteNamespace (Tcl_Namespace * nsPtr);
-#endif
-#ifndef Tcl_Export_TCL_DECLARED
-#define Tcl_Export_TCL_DECLARED
+EXTERN void    Tcl_DeleteNamespace(Tcl_Namespace *nsPtr);
 /* 115 */
-EXTERN int    Tcl_Export (Tcl_Interp * interp, 
-        Tcl_Namespace * nsPtr, CONST char * pattern, 
-        int resetListFirst);
-#endif
-#ifndef Tcl_FindCommand_TCL_DECLARED
-#define Tcl_FindCommand_TCL_DECLARED
+EXTERN int    Tcl_Export(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
+        const char *pattern, int resetListFirst);
 /* 116 */
-EXTERN Tcl_Command  Tcl_FindCommand (Tcl_Interp * interp, 
-        CONST char * name, 
-        Tcl_Namespace * contextNsPtr, int flags);
-#endif
-#ifndef Tcl_FindNamespace_TCL_DECLARED
-#define Tcl_FindNamespace_TCL_DECLARED
+EXTERN Tcl_Command  Tcl_FindCommand(Tcl_Interp *interp, const char *name,
+        Tcl_Namespace *contextNsPtr, int flags);
 /* 117 */
-EXTERN Tcl_Namespace *  Tcl_FindNamespace (Tcl_Interp * interp, 
-        CONST char * name, 
-        Tcl_Namespace * contextNsPtr, int flags);
-#endif
-#ifndef Tcl_GetInterpResolvers_TCL_DECLARED
-#define Tcl_GetInterpResolvers_TCL_DECLARED
+EXTERN Tcl_Namespace *  Tcl_FindNamespace(Tcl_Interp *interp,
+        const char *name,
+        Tcl_Namespace *contextNsPtr, int flags);
 /* 118 */
-EXTERN int    Tcl_GetInterpResolvers (Tcl_Interp * interp, 
-        CONST char * name, 
-        Tcl_ResolverInfo * resInfo);
-#endif
-#ifndef Tcl_GetNamespaceResolvers_TCL_DECLARED
-#define Tcl_GetNamespaceResolvers_TCL_DECLARED
+EXTERN int    Tcl_GetInterpResolvers(Tcl_Interp *interp,
+        const char *name, Tcl_ResolverInfo *resInfo);
 /* 119 */
-EXTERN int    Tcl_GetNamespaceResolvers (
-        Tcl_Namespace * namespacePtr, 
-        Tcl_ResolverInfo * resInfo);
-#endif
-#ifndef Tcl_FindNamespaceVar_TCL_DECLARED
-#define Tcl_FindNamespaceVar_TCL_DECLARED
+EXTERN int    Tcl_GetNamespaceResolvers(
+        Tcl_Namespace *namespacePtr,
+        Tcl_ResolverInfo *resInfo);
 /* 120 */
-EXTERN Tcl_Var    Tcl_FindNamespaceVar (Tcl_Interp * interp, 
-        CONST char * name, 
-        Tcl_Namespace * contextNsPtr, int flags);
-#endif
-#ifndef Tcl_ForgetImport_TCL_DECLARED
-#define Tcl_ForgetImport_TCL_DECLARED
+EXTERN Tcl_Var    Tcl_FindNamespaceVar(Tcl_Interp *interp,
+        const char *name,
+        Tcl_Namespace *contextNsPtr, int flags);
 /* 121 */
-EXTERN int    Tcl_ForgetImport (Tcl_Interp * interp, 
-        Tcl_Namespace * nsPtr, CONST char * pattern);
-#endif
-#ifndef Tcl_GetCommandFromObj_TCL_DECLARED
-#define Tcl_GetCommandFromObj_TCL_DECLARED
+EXTERN int    Tcl_ForgetImport(Tcl_Interp *interp,
+        Tcl_Namespace *nsPtr, const char *pattern);
 /* 122 */
-EXTERN Tcl_Command  Tcl_GetCommandFromObj (Tcl_Interp * interp, 
-        Tcl_Obj * objPtr);
-#endif
-#ifndef Tcl_GetCommandFullName_TCL_DECLARED
-#define Tcl_GetCommandFullName_TCL_DECLARED
+EXTERN Tcl_Command  Tcl_GetCommandFromObj(Tcl_Interp *interp,
+        Tcl_Obj *objPtr);
 /* 123 */
-EXTERN void    Tcl_GetCommandFullName (Tcl_Interp * interp, 
-        Tcl_Command command, Tcl_Obj * objPtr);
-#endif
-#ifndef Tcl_GetCurrentNamespace_TCL_DECLARED
-#define Tcl_GetCurrentNamespace_TCL_DECLARED
+EXTERN void    Tcl_GetCommandFullName(Tcl_Interp *interp,
+        Tcl_Command command, Tcl_Obj *objPtr);
 /* 124 */
-EXTERN Tcl_Namespace *  Tcl_GetCurrentNamespace (Tcl_Interp * interp);
-#endif
-#ifndef Tcl_GetGlobalNamespace_TCL_DECLARED
-#define Tcl_GetGlobalNamespace_TCL_DECLARED
+EXTERN Tcl_Namespace *  Tcl_GetCurrentNamespace(Tcl_Interp *interp);
 /* 125 */
-EXTERN Tcl_Namespace *  Tcl_GetGlobalNamespace (Tcl_Interp * interp);
-#endif
-#ifndef Tcl_GetVariableFullName_TCL_DECLARED
-#define Tcl_GetVariableFullName_TCL_DECLARED
+EXTERN Tcl_Namespace *  Tcl_GetGlobalNamespace(Tcl_Interp *interp);
 /* 126 */
-EXTERN void    Tcl_GetVariableFullName (Tcl_Interp * interp, 
-        Tcl_Var variable, Tcl_Obj * objPtr);
-#endif
-#ifndef Tcl_Import_TCL_DECLARED
-#define Tcl_Import_TCL_DECLARED
+EXTERN void    Tcl_GetVariableFullName(Tcl_Interp *interp,
+        Tcl_Var variable, Tcl_Obj *objPtr);
 /* 127 */
-EXTERN int    Tcl_Import (Tcl_Interp * interp, 
-        Tcl_Namespace * nsPtr, CONST char * pattern, 
-        int allowOverwrite);
-#endif
-#ifndef Tcl_PopCallFrame_TCL_DECLARED
-#define Tcl_PopCallFrame_TCL_DECLARED
+EXTERN int    Tcl_Import(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
+        const char *pattern, int allowOverwrite);
 /* 128 */
-EXTERN void    Tcl_PopCallFrame (Tcl_Interp * interp);
-#endif
-#ifndef Tcl_PushCallFrame_TCL_DECLARED
-#define Tcl_PushCallFrame_TCL_DECLARED
+EXTERN void    Tcl_PopCallFrame(Tcl_Interp *interp);
 /* 129 */
-EXTERN int    Tcl_PushCallFrame (Tcl_Interp * interp, 
-        Tcl_CallFrame * framePtr, 
-        Tcl_Namespace * nsPtr, int isProcCallFrame);
-#endif
-#ifndef Tcl_RemoveInterpResolvers_TCL_DECLARED
-#define Tcl_RemoveInterpResolvers_TCL_DECLARED
+EXTERN int    Tcl_PushCallFrame(Tcl_Interp *interp,
+        Tcl_CallFrame *framePtr,
+        Tcl_Namespace *nsPtr, int isProcCallFrame);
 /* 130 */
-EXTERN int    Tcl_RemoveInterpResolvers (Tcl_Interp * interp, 
-        CONST char * name);
-#endif
-#ifndef Tcl_SetNamespaceResolvers_TCL_DECLARED
-#define Tcl_SetNamespaceResolvers_TCL_DECLARED
+EXTERN int    Tcl_RemoveInterpResolvers(Tcl_Interp *interp,
+        const char *name);
 /* 131 */
-EXTERN void    Tcl_SetNamespaceResolvers (
-        Tcl_Namespace * namespacePtr, 
-        Tcl_ResolveCmdProc * cmdProc, 
-        Tcl_ResolveVarProc * varProc, 
-        Tcl_ResolveCompiledVarProc * compiledVarProc);
-#endif
-#ifndef TclpHasSockets_TCL_DECLARED
-#define TclpHasSockets_TCL_DECLARED
+EXTERN void    Tcl_SetNamespaceResolvers(
+        Tcl_Namespace *namespacePtr,
+        Tcl_ResolveCmdProc *cmdProc,
+        Tcl_ResolveVarProc *varProc,
+        Tcl_ResolveCompiledVarProc *compiledVarProc);
 /* 132 */
-EXTERN int    TclpHasSockets (Tcl_Interp * interp);
-#endif
-#ifndef TclpGetDate_TCL_DECLARED
-#define TclpGetDate_TCL_DECLARED
+EXTERN int    TclpHasSockets(Tcl_Interp *interp);
 /* 133 */
-EXTERN struct tm *  TclpGetDate (CONST time_t * time, int useGMT);
-#endif
+EXTERN struct tm *  TclpGetDate(const time_t *time, int useGMT);
 /* Slot 134 is reserved */
 /* Slot 135 is reserved */
 /* Slot 136 is reserved */
 /* Slot 137 is reserved */
-#ifndef TclGetEnv_TCL_DECLARED
-#define TclGetEnv_TCL_DECLARED
 /* 138 */
-EXTERN CONST84_RETURN char * TclGetEnv (CONST char * name, 
-        Tcl_DString * valuePtr);
-#endif
+EXTERN CONST84_RETURN char * TclGetEnv(const char *name,
+        Tcl_DString *valuePtr);
 /* Slot 139 is reserved */
 /* Slot 140 is reserved */
-#ifndef TclpGetCwd_TCL_DECLARED
-#define TclpGetCwd_TCL_DECLARED
 /* 141 */
-EXTERN CONST84_RETURN char * TclpGetCwd (Tcl_Interp * interp, 
-        Tcl_DString * cwdPtr);
-#endif
-#ifndef TclSetByteCodeFromAny_TCL_DECLARED
-#define TclSetByteCodeFromAny_TCL_DECLARED
+EXTERN CONST84_RETURN char * TclpGetCwd(Tcl_Interp *interp,
+        Tcl_DString *cwdPtr);
 /* 142 */
-EXTERN int    TclSetByteCodeFromAny (Tcl_Interp * interp, 
-        Tcl_Obj * objPtr, CompileHookProc * hookProc, 
+EXTERN int    TclSetByteCodeFromAny(Tcl_Interp *interp,
+        Tcl_Obj *objPtr, CompileHookProc *hookProc,
         ClientData clientData);
-#endif
-#ifndef TclAddLiteralObj_TCL_DECLARED
-#define TclAddLiteralObj_TCL_DECLARED
 /* 143 */
-EXTERN int    TclAddLiteralObj (struct CompileEnv * envPtr, 
-        Tcl_Obj * objPtr, LiteralEntry ** litPtrPtr);
-#endif
-#ifndef TclHideLiteral_TCL_DECLARED
-#define TclHideLiteral_TCL_DECLARED
+EXTERN int    TclAddLiteralObj(struct CompileEnv *envPtr,
+        Tcl_Obj *objPtr, LiteralEntry **litPtrPtr);
 /* 144 */
-EXTERN void    TclHideLiteral (Tcl_Interp * interp, 
-        struct CompileEnv * envPtr, int index);
-#endif
-#ifndef TclGetAuxDataType_TCL_DECLARED
-#define TclGetAuxDataType_TCL_DECLARED
+EXTERN void    TclHideLiteral(Tcl_Interp *interp,
+        struct CompileEnv *envPtr, int index);
 /* 145 */
-EXTERN CONST86 struct AuxDataType * TclGetAuxDataType (CONST char * typeName);
-#endif
-#ifndef TclHandleCreate_TCL_DECLARED
-#define TclHandleCreate_TCL_DECLARED
+EXTERN const struct AuxDataType * TclGetAuxDataType(const char *typeName);
 /* 146 */
-EXTERN TclHandle  TclHandleCreate (VOID * ptr);
-#endif
-#ifndef TclHandleFree_TCL_DECLARED
-#define TclHandleFree_TCL_DECLARED
+EXTERN TclHandle  TclHandleCreate(void *ptr);
 /* 147 */
-EXTERN void    TclHandleFree (TclHandle handle);
-#endif
-#ifndef TclHandlePreserve_TCL_DECLARED
-#define TclHandlePreserve_TCL_DECLARED
+EXTERN void    TclHandleFree(TclHandle handle);
 /* 148 */
-EXTERN TclHandle  TclHandlePreserve (TclHandle handle);
-#endif
-#ifndef TclHandleRelease_TCL_DECLARED
-#define TclHandleRelease_TCL_DECLARED
+EXTERN TclHandle  TclHandlePreserve(TclHandle handle);
 /* 149 */
-EXTERN void    TclHandleRelease (TclHandle handle);
-#endif
-#ifndef TclRegAbout_TCL_DECLARED
-#define TclRegAbout_TCL_DECLARED
+EXTERN void    TclHandleRelease(TclHandle handle);
 /* 150 */
-EXTERN int    TclRegAbout (Tcl_Interp * interp, Tcl_RegExp re);
-#endif
-#ifndef TclRegExpRangeUniChar_TCL_DECLARED
-#define TclRegExpRangeUniChar_TCL_DECLARED
+EXTERN int    TclRegAbout(Tcl_Interp *interp, Tcl_RegExp re);
 /* 151 */
-EXTERN void    TclRegExpRangeUniChar (Tcl_RegExp re, int index, 
-        int * startPtr, int * endPtr);
-#endif
-#ifndef TclSetLibraryPath_TCL_DECLARED
-#define TclSetLibraryPath_TCL_DECLARED
+EXTERN void    TclRegExpRangeUniChar(Tcl_RegExp re, int index,
+        int *startPtr, int *endPtr);
 /* 152 */
-EXTERN void    TclSetLibraryPath (Tcl_Obj * pathPtr);
-#endif
-#ifndef TclGetLibraryPath_TCL_DECLARED
-#define TclGetLibraryPath_TCL_DECLARED
+EXTERN void    TclSetLibraryPath(Tcl_Obj *pathPtr);
 /* 153 */
-EXTERN Tcl_Obj *  TclGetLibraryPath (void);
-#endif
+EXTERN Tcl_Obj *  TclGetLibraryPath(void);
 /* Slot 154 is reserved */
 /* Slot 155 is reserved */
-#ifndef TclRegError_TCL_DECLARED
-#define TclRegError_TCL_DECLARED
 /* 156 */
-EXTERN void    TclRegError (Tcl_Interp * interp, CONST char * msg, 
+EXTERN void    TclRegError(Tcl_Interp *interp, const char *msg,
         int status);
-#endif
-#ifndef TclVarTraceExists_TCL_DECLARED
-#define TclVarTraceExists_TCL_DECLARED
 /* 157 */
-EXTERN Var *    TclVarTraceExists (Tcl_Interp * interp, 
-        CONST char * varName);
-#endif
-#ifndef TclSetStartupScriptFileName_TCL_DECLARED
-#define TclSetStartupScriptFileName_TCL_DECLARED
-/* 158 */
-EXTERN void    TclSetStartupScriptFileName (CONST char * filename);
-#endif
-#ifndef TclGetStartupScriptFileName_TCL_DECLARED
-#define TclGetStartupScriptFileName_TCL_DECLARED
-/* 159 */
-EXTERN CONST84_RETURN char * TclGetStartupScriptFileName (void);
-#endif
+EXTERN Var *    TclVarTraceExists(Tcl_Interp *interp,
+        const char *varName);
+/* Slot 158 is reserved */
+/* Slot 159 is reserved */
 /* Slot 160 is reserved */
-#ifndef TclChannelTransform_TCL_DECLARED
-#define TclChannelTransform_TCL_DECLARED
 /* 161 */
-EXTERN int    TclChannelTransform (Tcl_Interp * interp, 
-        Tcl_Channel chan, Tcl_Obj * cmdObjPtr);
-#endif
-#ifndef TclChannelEventScriptInvoker_TCL_DECLARED
-#define TclChannelEventScriptInvoker_TCL_DECLARED
+EXTERN int    TclChannelTransform(Tcl_Interp *interp,
+        Tcl_Channel chan, Tcl_Obj *cmdObjPtr);
 /* 162 */
-EXTERN void    TclChannelEventScriptInvoker (ClientData clientData, 
+EXTERN void    TclChannelEventScriptInvoker(ClientData clientData,
         int flags);
-#endif
-#ifndef TclGetInstructionTable_TCL_DECLARED
-#define TclGetInstructionTable_TCL_DECLARED
 /* 163 */
-EXTERN CONST86 void *  TclGetInstructionTable (void);
-#endif
-#ifndef TclExpandCodeArray_TCL_DECLARED
-#define TclExpandCodeArray_TCL_DECLARED
+EXTERN const void *  TclGetInstructionTable(void);
 /* 164 */
-EXTERN void    TclExpandCodeArray (void * envPtr);
-#endif
-#ifndef TclpSetInitialEncodings_TCL_DECLARED
-#define TclpSetInitialEncodings_TCL_DECLARED
+EXTERN void    TclExpandCodeArray(void *envPtr);
 /* 165 */
-EXTERN void    TclpSetInitialEncodings (void);
-#endif
-#ifndef TclListObjSetElement_TCL_DECLARED
-#define TclListObjSetElement_TCL_DECLARED
+EXTERN void    TclpSetInitialEncodings(void);
 /* 166 */
-EXTERN int    TclListObjSetElement (Tcl_Interp * interp, 
-        Tcl_Obj * listPtr, int index, 
-        Tcl_Obj * valuePtr);
-#endif
-#ifndef TclSetStartupScriptPath_TCL_DECLARED
-#define TclSetStartupScriptPath_TCL_DECLARED
-/* 167 */
-EXTERN void    TclSetStartupScriptPath (Tcl_Obj * pathPtr);
-#endif
-#ifndef TclGetStartupScriptPath_TCL_DECLARED
-#define TclGetStartupScriptPath_TCL_DECLARED
-/* 168 */
-EXTERN Tcl_Obj *  TclGetStartupScriptPath (void);
-#endif
-#ifndef TclpUtfNcmp2_TCL_DECLARED
-#define TclpUtfNcmp2_TCL_DECLARED
+EXTERN int    TclListObjSetElement(Tcl_Interp *interp,
+        Tcl_Obj *listPtr, int index,
+        Tcl_Obj *valuePtr);
+/* Slot 167 is reserved */
+/* Slot 168 is reserved */
 /* 169 */
-EXTERN int    TclpUtfNcmp2 (CONST char * s1, CONST char * s2, 
+EXTERN int    TclpUtfNcmp2(const char *s1, const char *s2,
         unsigned long n);
-#endif
-#ifndef TclCheckInterpTraces_TCL_DECLARED
-#define TclCheckInterpTraces_TCL_DECLARED
 /* 170 */
-EXTERN int    TclCheckInterpTraces (Tcl_Interp * interp, 
-        CONST char * command, int numChars, 
-        Command * cmdPtr, int result, int traceFlags, 
-        int objc, Tcl_Obj *CONST objv[]);
-#endif
-#ifndef TclCheckExecutionTraces_TCL_DECLARED
-#define TclCheckExecutionTraces_TCL_DECLARED
+EXTERN int    TclCheckInterpTraces(Tcl_Interp *interp,
+        const char *command, int numChars,
+        Command *cmdPtr, int result, int traceFlags,
+        int objc, Tcl_Obj *const objv[]);
 /* 171 */
-EXTERN int    TclCheckExecutionTraces (Tcl_Interp * interp, 
-        CONST char * command, int numChars, 
-        Command * cmdPtr, int result, int traceFlags, 
-        int objc, Tcl_Obj *CONST objv[]);
-#endif
-#ifndef TclInThreadExit_TCL_DECLARED
-#define TclInThreadExit_TCL_DECLARED
+EXTERN int    TclCheckExecutionTraces(Tcl_Interp *interp,
+        const char *command, int numChars,
+        Command *cmdPtr, int result, int traceFlags,
+        int objc, Tcl_Obj *const objv[]);
 /* 172 */
-EXTERN int    TclInThreadExit (void);
-#endif
-#ifndef TclUniCharMatch_TCL_DECLARED
-#define TclUniCharMatch_TCL_DECLARED
+EXTERN int    TclInThreadExit(void);
 /* 173 */
-EXTERN int    TclUniCharMatch (CONST Tcl_UniChar * string, 
-        int strLen, CONST Tcl_UniChar * pattern, 
+EXTERN int    TclUniCharMatch(const Tcl_UniChar *string,
+        int strLen, const Tcl_UniChar *pattern,
         int ptnLen, int flags);
-#endif
 /* Slot 174 is reserved */
-#ifndef TclCallVarTraces_TCL_DECLARED
-#define TclCallVarTraces_TCL_DECLARED
 /* 175 */
-EXTERN int    TclCallVarTraces (Interp * iPtr, Var * arrayPtr, 
-        Var * varPtr, CONST char * part1, 
-        CONST char * part2, int flags, 
+EXTERN int    TclCallVarTraces(Interp *iPtr, Var *arrayPtr,
+        Var *varPtr, const char *part1,
+        const char *part2, int flags,
         int leaveErrMsg);
-#endif
-#ifndef TclCleanupVar_TCL_DECLARED
-#define TclCleanupVar_TCL_DECLARED
 /* 176 */
-EXTERN void    TclCleanupVar (Var * varPtr, Var * arrayPtr);
-#endif
-#ifndef TclVarErrMsg_TCL_DECLARED
-#define TclVarErrMsg_TCL_DECLARED
+EXTERN void    TclCleanupVar(Var *varPtr, Var *arrayPtr);
 /* 177 */
-EXTERN void    TclVarErrMsg (Tcl_Interp * interp, 
-        CONST char * part1, CONST char * part2, 
-        CONST char * operation, CONST char * reason);
-#endif
-#ifndef Tcl_SetStartupScript_TCL_DECLARED
-#define Tcl_SetStartupScript_TCL_DECLARED
-/* 178 */
-EXTERN void    Tcl_SetStartupScript (Tcl_Obj * pathPtr, 
-        CONST char* encodingName);
-#endif
-#ifndef Tcl_GetStartupScript_TCL_DECLARED
-#define Tcl_GetStartupScript_TCL_DECLARED
-/* 179 */
-EXTERN Tcl_Obj *  Tcl_GetStartupScript (CONST char ** encodingNamePtr);
-#endif
+EXTERN void    TclVarErrMsg(Tcl_Interp *interp, const char *part1,
+        const char *part2, const char *operation,
+        const char *reason);
+/* Slot 178 is reserved */
+/* Slot 179 is reserved */
 /* Slot 180 is reserved */
 /* Slot 181 is reserved */
-#ifndef TclpLocaltime_TCL_DECLARED
-#define TclpLocaltime_TCL_DECLARED
 /* 182 */
-EXTERN struct tm *  TclpLocaltime (CONST time_t * clock);
-#endif
-#ifndef TclpGmtime_TCL_DECLARED
-#define TclpGmtime_TCL_DECLARED
+EXTERN struct tm *  TclpLocaltime(const time_t *clock);
 /* 183 */
-EXTERN struct tm *  TclpGmtime (CONST time_t * clock);
-#endif
+EXTERN struct tm *  TclpGmtime(const time_t *clock);
 /* Slot 184 is reserved */
 /* Slot 185 is reserved */
 /* Slot 186 is reserved */
@@ -885,504 +469,405 @@
 /* Slot 195 is reserved */
 /* Slot 196 is reserved */
 /* Slot 197 is reserved */
-#ifndef TclObjGetFrame_TCL_DECLARED
-#define TclObjGetFrame_TCL_DECLARED
 /* 198 */
-EXTERN int    TclObjGetFrame (Tcl_Interp * interp, 
-        Tcl_Obj * objPtr, CallFrame ** framePtrPtr);
-#endif
+EXTERN int    TclObjGetFrame(Tcl_Interp *interp, Tcl_Obj *objPtr,
+        CallFrame **framePtrPtr);
 /* Slot 199 is reserved */
-#ifndef TclpObjRemoveDirectory_TCL_DECLARED
-#define TclpObjRemoveDirectory_TCL_DECLARED
 /* 200 */
-EXTERN int    TclpObjRemoveDirectory (Tcl_Obj * pathPtr, 
-        int recursive, Tcl_Obj ** errorPtr);
-#endif
-#ifndef TclpObjCopyDirectory_TCL_DECLARED
-#define TclpObjCopyDirectory_TCL_DECLARED
+EXTERN int    TclpObjRemoveDirectory(Tcl_Obj *pathPtr,
+        int recursive, Tcl_Obj **errorPtr);
 /* 201 */
-EXTERN int    TclpObjCopyDirectory (Tcl_Obj * srcPathPtr, 
-        Tcl_Obj * destPathPtr, Tcl_Obj ** errorPtr);
-#endif
-#ifndef TclpObjCreateDirectory_TCL_DECLARED
-#define TclpObjCreateDirectory_TCL_DECLARED
+EXTERN int    TclpObjCopyDirectory(Tcl_Obj *srcPathPtr,
+        Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr);
 /* 202 */
-EXTERN int    TclpObjCreateDirectory (Tcl_Obj * pathPtr);
-#endif
-#ifndef TclpObjDeleteFile_TCL_DECLARED
-#define TclpObjDeleteFile_TCL_DECLARED
+EXTERN int    TclpObjCreateDirectory(Tcl_Obj *pathPtr);
 /* 203 */
-EXTERN int    TclpObjDeleteFile (Tcl_Obj * pathPtr);
-#endif
-#ifndef TclpObjCopyFile_TCL_DECLARED
-#define TclpObjCopyFile_TCL_DECLARED
+EXTERN int    TclpObjDeleteFile(Tcl_Obj *pathPtr);
 /* 204 */
-EXTERN int    TclpObjCopyFile (Tcl_Obj * srcPathPtr, 
-        Tcl_Obj * destPathPtr);
-#endif
-#ifndef TclpObjRenameFile_TCL_DECLARED
-#define TclpObjRenameFile_TCL_DECLARED
+EXTERN int    TclpObjCopyFile(Tcl_Obj *srcPathPtr,
+        Tcl_Obj *destPathPtr);
 /* 205 */
-EXTERN int    TclpObjRenameFile (Tcl_Obj * srcPathPtr, 
-        Tcl_Obj * destPathPtr);
-#endif
-#ifndef TclpObjStat_TCL_DECLARED
-#define TclpObjStat_TCL_DECLARED
+EXTERN int    TclpObjRenameFile(Tcl_Obj *srcPathPtr,
+        Tcl_Obj *destPathPtr);
 /* 206 */
-EXTERN int    TclpObjStat (Tcl_Obj * pathPtr, Tcl_StatBuf * buf);
-#endif
-#ifndef TclpObjAccess_TCL_DECLARED
-#define TclpObjAccess_TCL_DECLARED
+EXTERN int    TclpObjStat(Tcl_Obj *pathPtr, Tcl_StatBuf *buf);
 /* 207 */
-EXTERN int    TclpObjAccess (Tcl_Obj * pathPtr, int mode);
-#endif
-#ifndef TclpOpenFileChannel_TCL_DECLARED
-#define TclpOpenFileChannel_TCL_DECLARED
+EXTERN int    TclpObjAccess(Tcl_Obj *pathPtr, int mode);
 /* 208 */
-EXTERN Tcl_Channel  TclpOpenFileChannel (Tcl_Interp * interp, 
-        Tcl_Obj * pathPtr, int mode, int permissions);
-#endif
+EXTERN Tcl_Channel  TclpOpenFileChannel(Tcl_Interp *interp,
+        Tcl_Obj *pathPtr, int mode, int permissions);
 /* Slot 209 is reserved */
 /* Slot 210 is reserved */
 /* Slot 211 is reserved */
-#ifndef TclpFindExecutable_TCL_DECLARED
-#define TclpFindExecutable_TCL_DECLARED
 /* 212 */
-EXTERN void    TclpFindExecutable (CONST char * argv0);
-#endif
-#ifndef TclGetObjNameOfExecutable_TCL_DECLARED
-#define TclGetObjNameOfExecutable_TCL_DECLARED
+EXTERN void    TclpFindExecutable(const char *argv0);
 /* 213 */
-EXTERN Tcl_Obj *  TclGetObjNameOfExecutable (void);
-#endif
-#ifndef TclSetObjNameOfExecutable_TCL_DECLARED
-#define TclSetObjNameOfExecutable_TCL_DECLARED
+EXTERN Tcl_Obj *  TclGetObjNameOfExecutable(void);
 /* 214 */
-EXTERN void    TclSetObjNameOfExecutable (Tcl_Obj * name, 
+EXTERN void    TclSetObjNameOfExecutable(Tcl_Obj *name,
         Tcl_Encoding encoding);
-#endif
-#ifndef TclStackAlloc_TCL_DECLARED
-#define TclStackAlloc_TCL_DECLARED
 /* 215 */
-EXTERN void *    TclStackAlloc (Tcl_Interp * interp, int numBytes);
-#endif
-#ifndef TclStackFree_TCL_DECLARED
-#define TclStackFree_TCL_DECLARED
+EXTERN void *    TclStackAlloc(Tcl_Interp *interp, int numBytes);
 /* 216 */
-EXTERN void    TclStackFree (Tcl_Interp * interp, void * freePtr);
-#endif
-#ifndef TclPushStackFrame_TCL_DECLARED
-#define TclPushStackFrame_TCL_DECLARED
+EXTERN void    TclStackFree(Tcl_Interp *interp, void *freePtr);
 /* 217 */
-EXTERN int    TclPushStackFrame (Tcl_Interp * interp, 
-        Tcl_CallFrame ** framePtrPtr, 
-        Tcl_Namespace * namespacePtr, 
+EXTERN int    TclPushStackFrame(Tcl_Interp *interp,
+        Tcl_CallFrame **framePtrPtr,
+        Tcl_Namespace *namespacePtr,
         int isProcCallFrame);
-#endif
-#ifndef TclPopStackFrame_TCL_DECLARED
-#define TclPopStackFrame_TCL_DECLARED
 /* 218 */
-EXTERN void    TclPopStackFrame (Tcl_Interp * interp);
-#endif
+EXTERN void    TclPopStackFrame(Tcl_Interp *interp);
 /* Slot 219 is reserved */
 /* Slot 220 is reserved */
 /* Slot 221 is reserved */
 /* Slot 222 is reserved */
 /* Slot 223 is reserved */
-#ifndef TclGetPlatform_TCL_DECLARED
-#define TclGetPlatform_TCL_DECLARED
 /* 224 */
-EXTERN TclPlatformType * TclGetPlatform (void);
-#endif
-#ifndef TclTraceDictPath_TCL_DECLARED
-#define TclTraceDictPath_TCL_DECLARED
+EXTERN TclPlatformType * TclGetPlatform(void);
 /* 225 */
-EXTERN Tcl_Obj *  TclTraceDictPath (Tcl_Interp * interp, 
-        Tcl_Obj * rootPtr, int keyc, 
-        Tcl_Obj *CONST keyv[], int flags);
-#endif
-#ifndef TclObjBeingDeleted_TCL_DECLARED
-#define TclObjBeingDeleted_TCL_DECLARED
+EXTERN Tcl_Obj *  TclTraceDictPath(Tcl_Interp *interp,
+        Tcl_Obj *rootPtr, int keyc,
+        Tcl_Obj *const keyv[], int flags);
 /* 226 */
-EXTERN int    TclObjBeingDeleted (Tcl_Obj * objPtr);
-#endif
-#ifndef TclSetNsPath_TCL_DECLARED
-#define TclSetNsPath_TCL_DECLARED
+EXTERN int    TclObjBeingDeleted(Tcl_Obj *objPtr);
 /* 227 */
-EXTERN void    TclSetNsPath (Namespace * nsPtr, int pathLength, 
-        Tcl_Namespace * pathAry[]);
-#endif
+EXTERN void    TclSetNsPath(Namespace *nsPtr, int pathLength,
+        Tcl_Namespace *pathAry[]);
 /* Slot 228 is reserved */
-#ifndef TclPtrMakeUpvar_TCL_DECLARED
-#define TclPtrMakeUpvar_TCL_DECLARED
 /* 229 */
-EXTERN int    TclPtrMakeUpvar (Tcl_Interp * interp, 
-        Var * otherP1Ptr, CONST char * myName, 
-        int myFlags, int index);
-#endif
-#ifndef TclObjLookupVar_TCL_DECLARED
-#define TclObjLookupVar_TCL_DECLARED
+EXTERN int    TclPtrMakeUpvar(Tcl_Interp *interp, Var *otherP1Ptr,
+        const char *myName, int myFlags, int index);
 /* 230 */
-EXTERN Var *    TclObjLookupVar (Tcl_Interp * interp, 
-        Tcl_Obj * part1Ptr, CONST char * part2, 
-        int flags, CONST char * msg, 
-        CONST int createPart1, CONST int createPart2, 
-        Var ** arrayPtrPtr);
-#endif
-#ifndef TclGetNamespaceFromObj_TCL_DECLARED
-#define TclGetNamespaceFromObj_TCL_DECLARED
+EXTERN Var *    TclObjLookupVar(Tcl_Interp *interp,
+        Tcl_Obj *part1Ptr, const char *part2,
+        int flags, const char *msg,
+        const int createPart1, const int createPart2,
+        Var **arrayPtrPtr);
 /* 231 */
-EXTERN int    TclGetNamespaceFromObj (Tcl_Interp * interp, 
-        Tcl_Obj * objPtr, Tcl_Namespace ** nsPtrPtr);
-#endif
-#ifndef TclEvalObjEx_TCL_DECLARED
-#define TclEvalObjEx_TCL_DECLARED
+EXTERN int    TclGetNamespaceFromObj(Tcl_Interp *interp,
+        Tcl_Obj *objPtr, Tcl_Namespace **nsPtrPtr);
 /* 232 */
-EXTERN int    TclEvalObjEx (Tcl_Interp * interp, Tcl_Obj * objPtr, 
-        int flags, CONST CmdFrame * invoker, 
-        int word);
-#endif
-#ifndef TclGetSrcInfoForPc_TCL_DECLARED
-#define TclGetSrcInfoForPc_TCL_DECLARED
+EXTERN int    TclEvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr,
+        int flags, const CmdFrame *invoker, int word);
 /* 233 */
-EXTERN void    TclGetSrcInfoForPc (CmdFrame * contextPtr);
-#endif
-#ifndef TclVarHashCreateVar_TCL_DECLARED
-#define TclVarHashCreateVar_TCL_DECLARED
+EXTERN void    TclGetSrcInfoForPc(CmdFrame *contextPtr);
 /* 234 */
-EXTERN Var *    TclVarHashCreateVar (TclVarHashTable * tablePtr, 
-        CONST char * key, int * newPtr);
-#endif
-#ifndef TclInitVarHashTable_TCL_DECLARED
-#define TclInitVarHashTable_TCL_DECLARED
+EXTERN Var *    TclVarHashCreateVar(TclVarHashTable *tablePtr,
+        const char *key, int *newPtr);
 /* 235 */
-EXTERN void    TclInitVarHashTable (TclVarHashTable * tablePtr, 
-        Namespace * nsPtr);
-#endif
-#ifndef TclBackgroundException_TCL_DECLARED
-#define TclBackgroundException_TCL_DECLARED
-/* 236 */
-EXTERN void    TclBackgroundException (Tcl_Interp * interp, 
-        int code);
-#endif
-#ifndef TclResetCancellation_TCL_DECLARED
-#define TclResetCancellation_TCL_DECLARED
+EXTERN void    TclInitVarHashTable(TclVarHashTable *tablePtr,
+        Namespace *nsPtr);
+/* Slot 236 is reserved */
 /* 237 */
-EXTERN int    TclResetCancellation (Tcl_Interp * interp, int force);
-#endif
-#ifndef TclNRInterpProc_TCL_DECLARED
-#define TclNRInterpProc_TCL_DECLARED
+EXTERN int    TclResetCancellation(Tcl_Interp *interp, int force);
 /* 238 */
-EXTERN int    TclNRInterpProc (ClientData clientData, 
-        Tcl_Interp * interp, int objc, 
-        Tcl_Obj *CONST objv[]);
-#endif
-#ifndef TclNRInterpProcCore_TCL_DECLARED
-#define TclNRInterpProcCore_TCL_DECLARED
+EXTERN int    TclNRInterpProc(ClientData clientData,
+        Tcl_Interp *interp, int objc,
+        Tcl_Obj *const objv[]);
 /* 239 */
-EXTERN int    TclNRInterpProcCore (Tcl_Interp * interp, 
-        Tcl_Obj * procNameObj, int skip, 
-        ProcErrorProc errorProc);
-#endif
-#ifndef TclNRRunCallbacks_TCL_DECLARED
-#define TclNRRunCallbacks_TCL_DECLARED
+EXTERN int    TclNRInterpProcCore(Tcl_Interp *interp,
+        Tcl_Obj *procNameObj, int skip,
+        ProcErrorProc *errorProc);
 /* 240 */
-EXTERN int    TclNRRunCallbacks (Tcl_Interp * interp, int result, 
-        struct TEOV_callback * rootPtr, int tebcCall);
-#endif
-#ifndef TclNREvalObjEx_TCL_DECLARED
-#define TclNREvalObjEx_TCL_DECLARED
+EXTERN int    TclNRRunCallbacks(Tcl_Interp *interp, int result,
+        struct NRE_callback *rootPtr);
 /* 241 */
-EXTERN int    TclNREvalObjEx (Tcl_Interp * interp, 
-        Tcl_Obj * objPtr, int flags, 
-        CONST CmdFrame * invoker, int word);
-#endif
-#ifndef TclNREvalObjv_TCL_DECLARED
-#define TclNREvalObjv_TCL_DECLARED
+EXTERN int    TclNREvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr,
+        int flags, const CmdFrame *invoker, int word);
 /* 242 */
-EXTERN int    TclNREvalObjv (Tcl_Interp * interp, int objc, 
-        Tcl_Obj *const objv[], int flags, 
-        Command * cmdPtr);
-#endif
+EXTERN int    TclNREvalObjv(Tcl_Interp *interp, int objc,
+        Tcl_Obj *const objv[], int flags,
+        Command *cmdPtr);
+/* 243 */
+EXTERN void    TclDbDumpActiveObjects(FILE *outFile);
+/* 244 */
+EXTERN Tcl_HashTable *  TclGetNamespaceChildTable(Tcl_Namespace *nsPtr);
+/* 245 */
+EXTERN Tcl_HashTable *  TclGetNamespaceCommandTable(Tcl_Namespace *nsPtr);
+/* 246 */
+EXTERN int    TclInitRewriteEnsemble(Tcl_Interp *interp,
+        int numRemoved, int numInserted,
+        Tcl_Obj *const *objv);
+/* 247 */
+EXTERN void    TclResetRewriteEnsemble(Tcl_Interp *interp,
+        int isRootEnsemble);
+/* 248 */
+EXTERN int    TclCopyChannel(Tcl_Interp *interp,
+        Tcl_Channel inChan, Tcl_Channel outChan,
+        Tcl_WideInt toRead, Tcl_Obj *cmdPtr);
+/* 249 */
+EXTERN char *    TclDoubleDigits(double dv, int ndigits, int flags,
+        int *decpt, int *signum, char **endPtr);
+/* 250 */
+EXTERN void    TclSetSlaveCancelFlags(Tcl_Interp *interp, int flags,
+        int force);
 
 typedef struct TclIntStubs {
     int magic;
-    CONST struct TclIntStubHooks *hooks;
+    void *hooks;
 
-    void *reserved0;
-    void *reserved1;
-    void *reserved2;
+    void (*reserved0)(void);
+    void (*reserved1)(void);
+    void (*reserved2)(void);
     void (*tclAllocateFreeObjects) (void); /* 3 */
-    void *reserved4;
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-    int (*tclCleanupChildren) (Tcl_Interp * interp, int numPids, Tcl_Pid * pidPtr, Tcl_Channel errorChan); /* 5 */
-#endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
-    int (*tclCleanupChildren) (Tcl_Interp * interp, int numPids, Tcl_Pid * pidPtr, Tcl_Channel errorChan); /* 5 */
-#endif /* WIN */
-#ifdef MAC_OSX_TCL /* MACOSX */
-    int (*tclCleanupChildren) (Tcl_Interp * interp, int numPids, Tcl_Pid * pidPtr, Tcl_Channel errorChan); /* 5 */
-#endif /* MACOSX */
-    void (*tclCleanupCommand) (Command * cmdPtr); /* 6 */
-    int (*tclCopyAndCollapse) (int count, CONST char * src, char * dst); /* 7 */
-    int (*tclCopyChannel) (Tcl_Interp * interp, Tcl_Channel inChan, Tcl_Channel outChan, int toRead, Tcl_Obj * cmdPtr); /* 8 */
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-    int (*tclCreatePipeline) (Tcl_Interp * interp, int argc, CONST char ** argv, Tcl_Pid ** pidArrayPtr, TclFile * inPipePtr, TclFile * outPipePtr, TclFile * errFilePtr); /* 9 */
-#endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
-    int (*tclCreatePipeline) (Tcl_Interp * interp, int argc, CONST char ** argv, Tcl_Pid ** pidArrayPtr, TclFile * inPipePtr, TclFile * outPipePtr, TclFile * errFilePtr); /* 9 */
-#endif /* WIN */
-#ifdef MAC_OSX_TCL /* MACOSX */
-    int (*tclCreatePipeline) (Tcl_Interp * interp, int argc, CONST char ** argv, Tcl_Pid ** pidArrayPtr, TclFile * inPipePtr, TclFile * outPipePtr, TclFile * errFilePtr); /* 9 */
-#endif /* MACOSX */
-    int (*tclCreateProc) (Tcl_Interp * interp, Namespace * nsPtr, CONST char * procName, Tcl_Obj * argsPtr, Tcl_Obj * bodyPtr, Proc ** procPtrPtr); /* 10 */
-    void (*tclDeleteCompiledLocalVars) (Interp * iPtr, CallFrame * framePtr); /* 11 */
-    void (*tclDeleteVars) (Interp * iPtr, TclVarHashTable * tablePtr); /* 12 */
-    void *reserved13;
-    void (*tclDumpMemoryInfo) (FILE * outFile); /* 14 */
-    void *reserved15;
-    void (*tclExprFloatError) (Tcl_Interp * interp, double value); /* 16 */
-    void *reserved17;
-    void *reserved18;
-    void *reserved19;
-    void *reserved20;
-    void *reserved21;
-    int (*tclFindElement) (Tcl_Interp * interp, CONST char * listStr, int listLength, CONST char ** elementPtr, CONST char ** nextPtr, int * sizePtr, int * bracePtr); /* 22 */
-    Proc * (*tclFindProc) (Interp * iPtr, CONST char * procName); /* 23 */
-    void *reserved24;
-    void (*tclFreePackageInfo) (Interp * iPtr); /* 25 */
-    void *reserved26;
-    void *reserved27;
+    void (*reserved4)(void);
+    int (*tclCleanupChildren) (Tcl_Interp *interp, int numPids, Tcl_Pid *pidPtr, Tcl_Channel errorChan); /* 5 */
+    void (*tclCleanupCommand) (Command *cmdPtr); /* 6 */
+    int (*tclCopyAndCollapse) (int count, const char *src, char *dst); /* 7 */
+    int (*tclCopyChannelOld) (Tcl_Interp *interp, Tcl_Channel inChan, Tcl_Channel outChan, int toRead, Tcl_Obj *cmdPtr); /* 8 */
+    int (*tclCreatePipeline) (Tcl_Interp *interp, int argc, const char **argv, Tcl_Pid **pidArrayPtr, TclFile *inPipePtr, TclFile *outPipePtr, TclFile *errFilePtr); /* 9 */
+    int (*tclCreateProc) (Tcl_Interp *interp, Namespace *nsPtr, const char *procName, Tcl_Obj *argsPtr, Tcl_Obj *bodyPtr, Proc **procPtrPtr); /* 10 */
+    void (*tclDeleteCompiledLocalVars) (Interp *iPtr, CallFrame *framePtr); /* 11 */
+    void (*tclDeleteVars) (Interp *iPtr, TclVarHashTable *tablePtr); /* 12 */
+    void (*reserved13)(void);
+    int (*tclDumpMemoryInfo) (ClientData clientData, int flags); /* 14 */
+    void (*reserved15)(void);
+    void (*tclExprFloatError) (Tcl_Interp *interp, double value); /* 16 */
+    void (*reserved17)(void);
+    void (*reserved18)(void);
+    void (*reserved19)(void);
+    void (*reserved20)(void);
+    void (*reserved21)(void);
+    int (*tclFindElement) (Tcl_Interp *interp, const char *listStr, int listLength, const char **elementPtr, const char **nextPtr, int *sizePtr, int *bracePtr); /* 22 */
+    Proc * (*tclFindProc) (Interp *iPtr, const char *procName); /* 23 */
+    int (*tclFormatInt) (char *buffer, long n); /* 24 */
+    void (*tclFreePackageInfo) (Interp *iPtr); /* 25 */
+    void (*reserved26)(void);
+    void (*reserved27)(void);
     Tcl_Channel (*tclpGetDefaultStdChannel) (int type); /* 28 */
-    void *reserved29;
-    void *reserved30;
-    CONST char * (*tclGetExtension) (CONST char * name); /* 31 */
-    int (*tclGetFrame) (Tcl_Interp * interp, CONST char * str, CallFrame ** framePtrPtr); /* 32 */
-    void *reserved33;
-    int (*tclGetIntForIndex) (Tcl_Interp * interp, Tcl_Obj * objPtr, int endValue, int * indexPtr); /* 34 */
-    void *reserved35;
-    void *reserved36;
-    int (*tclGetLoadedPackages) (Tcl_Interp * interp, char * targetName); /* 37 */
-    int (*tclGetNamespaceForQualName) (Tcl_Interp * interp, CONST char * qualName, Namespace * cxtNsPtr, int flags, Namespace ** nsPtrPtr, Namespace ** altNsPtrPtr, Namespace ** actualCxtPtrPtr, CONST char ** simpleNamePtr); /* 38 */
+    void (*reserved29)(void);
+    void (*reserved30)(void);
+    const char * (*tclGetExtension) (const char *name); /* 31 */
+    int (*tclGetFrame) (Tcl_Interp *interp, const char *str, CallFrame **framePtrPtr); /* 32 */
+    void (*reserved33)(void);
+    int (*tclGetIntForIndex) (Tcl_Interp *interp, Tcl_Obj *objPtr, int endValue, int *indexPtr); /* 34 */
+    void (*reserved35)(void);
+    void (*reserved36)(void);
+    int (*tclGetLoadedPackages) (Tcl_Interp *interp, const char *targetName); /* 37 */
+    int (*tclGetNamespaceForQualName) (Tcl_Interp *interp, const char *qualName, Namespace *cxtNsPtr, int flags, Namespace **nsPtrPtr, Namespace **altNsPtrPtr, Namespace **actualCxtPtrPtr, const char **simpleNamePtr); /* 38 */
     TclObjCmdProcType (*tclGetObjInterpProc) (void); /* 39 */
-    int (*tclGetOpenMode) (Tcl_Interp * interp, CONST char * str, int * seekFlagPtr); /* 40 */
+    int (*tclGetOpenMode) (Tcl_Interp *interp, const char *str, int *seekFlagPtr); /* 40 */
     Tcl_Command (*tclGetOriginalCommand) (Tcl_Command command); /* 41 */
-    char * (*tclpGetUserHome) (CONST char * name, Tcl_DString * bufferPtr); /* 42 */
-    void *reserved43;
-    int (*tclGuessPackageName) (CONST char * fileName, Tcl_DString * bufPtr); /* 44 */
-    int (*tclHideUnsafeCommands) (Tcl_Interp * interp); /* 45 */
+    CONST86 char * (*tclpGetUserHome) (const char *name, Tcl_DString *bufferPtr); /* 42 */
+    void (*reserved43)(void);
+    int (*tclGuessPackageName) (const char *fileName, Tcl_DString *bufPtr); /* 44 */
+    int (*tclHideUnsafeCommands) (Tcl_Interp *interp); /* 45 */
     int (*tclInExit) (void); /* 46 */
-    void *reserved47;
-    void *reserved48;
-    void *reserved49;
-    void (*tclInitCompiledLocals) (Tcl_Interp * interp, CallFrame * framePtr, Namespace * nsPtr); /* 50 */
-    int (*tclInterpInit) (Tcl_Interp * interp); /* 51 */
-    void *reserved52;
-    int (*tclInvokeObjectCommand) (ClientData clientData, Tcl_Interp * interp, int argc, CONST84 char ** argv); /* 53 */
-    int (*tclInvokeStringCommand) (ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[]); /* 54 */
-    Proc * (*tclIsProc) (Command * cmdPtr); /* 55 */
-    void *reserved56;
-    void *reserved57;
-    Var * (*tclLookupVar) (Tcl_Interp * interp, CONST char * part1, CONST char * part2, int flags, CONST char * msg, int createPart1, int createPart2, Var ** arrayPtrPtr); /* 58 */
-    void *reserved59;
-    int (*tclNeedSpace) (CONST char * start, CONST char * end); /* 60 */
-    Tcl_Obj * (*tclNewProcBodyObj) (Proc * procPtr); /* 61 */
-    int (*tclObjCommandComplete) (Tcl_Obj * cmdPtr); /* 62 */
-    int (*tclObjInterpProc) (ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[]); /* 63 */
-    int (*tclObjInvoke) (Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[], int flags); /* 64 */
-    void *reserved65;
-    void *reserved66;
-    void *reserved67;
-    void *reserved68;
+    void (*reserved47)(void);
+    void (*reserved48)(void);
+    void (*reserved49)(void);
+    void (*tclInitCompiledLocals) (Tcl_Interp *interp, CallFrame *framePtr, Namespace *nsPtr); /* 50 */
+    int (*tclInterpInit) (Tcl_Interp *interp); /* 51 */
+    void (*reserved52)(void);
+    int (*tclInvokeObjectCommand) (ClientData clientData, Tcl_Interp *interp, int argc, CONST84 char **argv); /* 53 */
+    int (*tclInvokeStringCommand) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 54 */
+    Proc * (*tclIsProc) (Command *cmdPtr); /* 55 */
+    void (*reserved56)(void);
+    void (*reserved57)(void);
+    Var * (*tclLookupVar) (Tcl_Interp *interp, const char *part1, const char *part2, int flags, const char *msg, int createPart1, int createPart2, Var **arrayPtrPtr); /* 58 */
+    void (*reserved59)(void);
+    int (*tclNeedSpace) (const char *start, const char *end); /* 60 */
+    Tcl_Obj * (*tclNewProcBodyObj) (Proc *procPtr); /* 61 */
+    int (*tclObjCommandComplete) (Tcl_Obj *cmdPtr); /* 62 */
+    int (*tclObjInterpProc) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 63 */
+    int (*tclObjInvoke) (Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], int flags); /* 64 */
+    void (*reserved65)(void);
+    void (*reserved66)(void);
+    void (*reserved67)(void);
+    void (*reserved68)(void);
     char * (*tclpAlloc) (unsigned int size); /* 69 */
-    void *reserved70;
-    void *reserved71;
-    void *reserved72;
-    void *reserved73;
-    void (*tclpFree) (char * ptr); /* 74 */
+    void (*reserved70)(void);
+    void (*reserved71)(void);
+    void (*reserved72)(void);
+    void (*reserved73)(void);
+    void (*tclpFree) (char *ptr); /* 74 */
     unsigned long (*tclpGetClicks) (void); /* 75 */
     unsigned long (*tclpGetSeconds) (void); /* 76 */
-    void (*tclpGetTime) (Tcl_Time * time); /* 77 */
-    int (*tclpGetTimeZone) (unsigned long time); /* 78 */
-    void *reserved79;
-    void *reserved80;
-    char * (*tclpRealloc) (char * ptr, unsigned int size); /* 81 */
-    void *reserved82;
-    void *reserved83;
-    void *reserved84;
-    void *reserved85;
-    void *reserved86;
-    void *reserved87;
-    char * (*tclPrecTraceProc) (ClientData clientData, Tcl_Interp * interp, CONST char * name1, CONST char * name2, int flags); /* 88 */
-    int (*tclPreventAliasLoop) (Tcl_Interp * interp, Tcl_Interp * cmdInterp, Tcl_Command cmd); /* 89 */
-    void *reserved90;
-    void (*tclProcCleanupProc) (Proc * procPtr); /* 91 */
-    int (*tclProcCompileProc) (Tcl_Interp * interp, Proc * procPtr, Tcl_Obj * bodyPtr, Namespace * nsPtr, CONST char * description, CONST char * procName); /* 92 */
+    void (*tclpGetTime) (Tcl_Time *time); /* 77 */
+    void (*reserved78)(void);
+    void (*reserved79)(void);
+    void (*reserved80)(void);
+    char * (*tclpRealloc) (char *ptr, unsigned int size); /* 81 */
+    void (*reserved82)(void);
+    void (*reserved83)(void);
+    void (*reserved84)(void);
+    void (*reserved85)(void);
+    void (*reserved86)(void);
+    void (*reserved87)(void);
+    char * (*tclPrecTraceProc) (ClientData clientData, Tcl_Interp *interp, const char *name1, const char *name2, int flags); /* 88 */
+    int (*tclPreventAliasLoop) (Tcl_Interp *interp, Tcl_Interp *cmdInterp, Tcl_Command cmd); /* 89 */
+    void (*reserved90)(void);
+    void (*tclProcCleanupProc) (Proc *procPtr); /* 91 */
+    int (*tclProcCompileProc) (Tcl_Interp *interp, Proc *procPtr, Tcl_Obj *bodyPtr, Namespace *nsPtr, const char *description, const char *procName); /* 92 */
     void (*tclProcDeleteProc) (ClientData clientData); /* 93 */
-    void *reserved94;
-    void *reserved95;
-    int (*tclRenameCommand) (Tcl_Interp * interp, CONST char * oldName, CONST char * newName); /* 96 */
-    void (*tclResetShadowedCmdRefs) (Tcl_Interp * interp, Command * newCmdPtr); /* 97 */
+    void (*reserved94)(void);
+    void (*reserved95)(void);
+    int (*tclRenameCommand) (Tcl_Interp *interp, const char *oldName, const char *newName); /* 96 */
+    void (*tclResetShadowedCmdRefs) (Tcl_Interp *interp, Command *newCmdPtr); /* 97 */
     int (*tclServiceIdle) (void); /* 98 */
-    void *reserved99;
-    void *reserved100;
-    char * (*tclSetPreInitScript) (char * string); /* 101 */
-    void (*tclSetupEnv) (Tcl_Interp * interp); /* 102 */
-    int (*tclSockGetPort) (Tcl_Interp * interp, CONST char * str, CONST char * proto, int * portPtr); /* 103 */
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-    int (*tclSockMinimumBuffers) (int sock, int size); /* 104 */
-#endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
-    int (*tclSockMinimumBuffers) (int sock, int size); /* 104 */
-#endif /* WIN */
-#ifdef MAC_OSX_TCL /* MACOSX */
-    int (*tclSockMinimumBuffers) (int sock, int size); /* 104 */
-#endif /* MACOSX */
-    void *reserved105;
-    void *reserved106;
-    void *reserved107;
-    void (*tclTeardownNamespace) (Namespace * nsPtr); /* 108 */
-    int (*tclUpdateReturnInfo) (Interp * iPtr); /* 109 */
-    void *reserved110;
-    void (*tcl_AddInterpResolvers) (Tcl_Interp * interp, CONST char * name, Tcl_ResolveCmdProc * cmdProc, Tcl_ResolveVarProc * varProc, Tcl_ResolveCompiledVarProc * compiledVarProc); /* 111 */
-    int (*tcl_AppendExportList) (Tcl_Interp * interp, Tcl_Namespace * nsPtr, Tcl_Obj * objPtr); /* 112 */
-    Tcl_Namespace * (*tcl_CreateNamespace) (Tcl_Interp * interp, CONST char * name, ClientData clientData, Tcl_NamespaceDeleteProc * deleteProc); /* 113 */
-    void (*tcl_DeleteNamespace) (Tcl_Namespace * nsPtr); /* 114 */
-    int (*tcl_Export) (Tcl_Interp * interp, Tcl_Namespace * nsPtr, CONST char * pattern, int resetListFirst); /* 115 */
-    Tcl_Command (*tcl_FindCommand) (Tcl_Interp * interp, CONST char * name, Tcl_Namespace * contextNsPtr, int flags); /* 116 */
-    Tcl_Namespace * (*tcl_FindNamespace) (Tcl_Interp * interp, CONST char * name, Tcl_Namespace * contextNsPtr, int flags); /* 117 */
-    int (*tcl_GetInterpResolvers) (Tcl_Interp * interp, CONST char * name, Tcl_ResolverInfo * resInfo); /* 118 */
-    int (*tcl_GetNamespaceResolvers) (Tcl_Namespace * namespacePtr, Tcl_ResolverInfo * resInfo); /* 119 */
-    Tcl_Var (*tcl_FindNamespaceVar) (Tcl_Interp * interp, CONST char * name, Tcl_Namespace * contextNsPtr, int flags); /* 120 */
-    int (*tcl_ForgetImport) (Tcl_Interp * interp, Tcl_Namespace * nsPtr, CONST char * pattern); /* 121 */
-    Tcl_Command (*tcl_GetCommandFromObj) (Tcl_Interp * interp, Tcl_Obj * objPtr); /* 122 */
-    void (*tcl_GetCommandFullName) (Tcl_Interp * interp, Tcl_Command command, Tcl_Obj * objPtr); /* 123 */
-    Tcl_Namespace * (*tcl_GetCurrentNamespace) (Tcl_Interp * interp); /* 124 */
-    Tcl_Namespace * (*tcl_GetGlobalNamespace) (Tcl_Interp * interp); /* 125 */
-    void (*tcl_GetVariableFullName) (Tcl_Interp * interp, Tcl_Var variable, Tcl_Obj * objPtr); /* 126 */
-    int (*tcl_Import) (Tcl_Interp * interp, Tcl_Namespace * nsPtr, CONST char * pattern, int allowOverwrite); /* 127 */
-    void (*tcl_PopCallFrame) (Tcl_Interp * interp); /* 128 */
-    int (*tcl_PushCallFrame) (Tcl_Interp * interp, Tcl_CallFrame * framePtr, Tcl_Namespace * nsPtr, int isProcCallFrame); /* 129 */
-    int (*tcl_RemoveInterpResolvers) (Tcl_Interp * interp, CONST char * name); /* 130 */
-    void (*tcl_SetNamespaceResolvers) (Tcl_Namespace * namespacePtr, Tcl_ResolveCmdProc * cmdProc, Tcl_ResolveVarProc * varProc, Tcl_ResolveCompiledVarProc * compiledVarProc); /* 131 */
-    int (*tclpHasSockets) (Tcl_Interp * interp); /* 132 */
-    struct tm * (*tclpGetDate) (CONST time_t * time, int useGMT); /* 133 */
-    void *reserved134;
-    void *reserved135;
-    void *reserved136;
-    void *reserved137;
-    CONST84_RETURN char * (*tclGetEnv) (CONST char * name, Tcl_DString * valuePtr); /* 138 */
-    void *reserved139;
-    void *reserved140;
-    CONST84_RETURN char * (*tclpGetCwd) (Tcl_Interp * interp, Tcl_DString * cwdPtr); /* 141 */
-    int (*tclSetByteCodeFromAny) (Tcl_Interp * interp, Tcl_Obj * objPtr, CompileHookProc * hookProc, ClientData clientData); /* 142 */
-    int (*tclAddLiteralObj) (struct CompileEnv * envPtr, Tcl_Obj * objPtr, LiteralEntry ** litPtrPtr); /* 143 */
-    void (*tclHideLiteral) (Tcl_Interp * interp, struct CompileEnv * envPtr, int index); /* 144 */
-    CONST86 struct AuxDataType * (*tclGetAuxDataType) (CONST char * typeName); /* 145 */
-    TclHandle (*tclHandleCreate) (VOID * ptr); /* 146 */
+    void (*reserved99)(void);
+    void (*reserved100)(void);
+    CONST86 char * (*tclSetPreInitScript) (const char *string); /* 101 */
+    void (*tclSetupEnv) (Tcl_Interp *interp); /* 102 */
+    int (*tclSockGetPort) (Tcl_Interp *interp, const char *str, const char *proto, int *portPtr); /* 103 */
+    int (*tclSockMinimumBuffersOld) (int sock, int size); /* 104 */
+    void (*reserved105)(void);
+    void (*reserved106)(void);
+    void (*reserved107)(void);
+    void (*tclTeardownNamespace) (Namespace *nsPtr); /* 108 */
+    int (*tclUpdateReturnInfo) (Interp *iPtr); /* 109 */
+    int (*tclSockMinimumBuffers) (void *sock, int size); /* 110 */
+    void (*tcl_AddInterpResolvers) (Tcl_Interp *interp, const char *name, Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc, Tcl_ResolveCompiledVarProc *compiledVarProc); /* 111 */
+    int (*tcl_AppendExportList) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, Tcl_Obj *objPtr); /* 112 */
+    Tcl_Namespace * (*tcl_CreateNamespace) (Tcl_Interp *interp, const char *name, ClientData clientData, Tcl_NamespaceDeleteProc *deleteProc); /* 113 */
+    void (*tcl_DeleteNamespace) (Tcl_Namespace *nsPtr); /* 114 */
+    int (*tcl_Export) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, const char *pattern, int resetListFirst); /* 115 */
+    Tcl_Command (*tcl_FindCommand) (Tcl_Interp *interp, const char *name, Tcl_Namespace *contextNsPtr, int flags); /* 116 */
+    Tcl_Namespace * (*tcl_FindNamespace) (Tcl_Interp *interp, const char *name, Tcl_Namespace *contextNsPtr, int flags); /* 117 */
+    int (*tcl_GetInterpResolvers) (Tcl_Interp *interp, const char *name, Tcl_ResolverInfo *resInfo); /* 118 */
+    int (*tcl_GetNamespaceResolvers) (Tcl_Namespace *namespacePtr, Tcl_ResolverInfo *resInfo); /* 119 */
+    Tcl_Var (*tcl_FindNamespaceVar) (Tcl_Interp *interp, const char *name, Tcl_Namespace *contextNsPtr, int flags); /* 120 */
+    int (*tcl_ForgetImport) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, const char *pattern); /* 121 */
+    Tcl_Command (*tcl_GetCommandFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr); /* 122 */
+    void (*tcl_GetCommandFullName) (Tcl_Interp *interp, Tcl_Command command, Tcl_Obj *objPtr); /* 123 */
+    Tcl_Namespace * (*tcl_GetCurrentNamespace) (Tcl_Interp *interp); /* 124 */
+    Tcl_Namespace * (*tcl_GetGlobalNamespace) (Tcl_Interp *interp); /* 125 */
+    void (*tcl_GetVariableFullName) (Tcl_Interp *interp, Tcl_Var variable, Tcl_Obj *objPtr); /* 126 */
+    int (*tcl_Import) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, const char *pattern, int allowOverwrite); /* 127 */
+    void (*tcl_PopCallFrame) (Tcl_Interp *interp); /* 128 */
+    int (*tcl_PushCallFrame) (Tcl_Interp *interp, Tcl_CallFrame *framePtr, Tcl_Namespace *nsPtr, int isProcCallFrame); /* 129 */
+    int (*tcl_RemoveInterpResolvers) (Tcl_Interp *interp, const char *name); /* 130 */
+    void (*tcl_SetNamespaceResolvers) (Tcl_Namespace *namespacePtr, Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc, Tcl_ResolveCompiledVarProc *compiledVarProc); /* 131 */
+    int (*tclpHasSockets) (Tcl_Interp *interp); /* 132 */
+    struct tm * (*tclpGetDate) (const time_t *time, int useGMT); /* 133 */
+    void (*reserved134)(void);
+    void (*reserved135)(void);
+    void (*reserved136)(void);
+    void (*reserved137)(void);
+    CONST84_RETURN char * (*tclGetEnv) (const char *name, Tcl_DString *valuePtr); /* 138 */
+    void (*reserved139)(void);
+    void (*reserved140)(void);
+    CONST84_RETURN char * (*tclpGetCwd) (Tcl_Interp *interp, Tcl_DString *cwdPtr); /* 141 */
+    int (*tclSetByteCodeFromAny) (Tcl_Interp *interp, Tcl_Obj *objPtr, CompileHookProc *hookProc, ClientData clientData); /* 142 */
+    int (*tclAddLiteralObj) (struct CompileEnv *envPtr, Tcl_Obj *objPtr, LiteralEntry **litPtrPtr); /* 143 */
+    void (*tclHideLiteral) (Tcl_Interp *interp, struct CompileEnv *envPtr, int index); /* 144 */
+    const struct AuxDataType * (*tclGetAuxDataType) (const char *typeName); /* 145 */
+    TclHandle (*tclHandleCreate) (void *ptr); /* 146 */
     void (*tclHandleFree) (TclHandle handle); /* 147 */
     TclHandle (*tclHandlePreserve) (TclHandle handle); /* 148 */
     void (*tclHandleRelease) (TclHandle handle); /* 149 */
-    int (*tclRegAbout) (Tcl_Interp * interp, Tcl_RegExp re); /* 150 */
-    void (*tclRegExpRangeUniChar) (Tcl_RegExp re, int index, int * startPtr, int * endPtr); /* 151 */
-    void (*tclSetLibraryPath) (Tcl_Obj * pathPtr); /* 152 */
+    int (*tclRegAbout) (Tcl_Interp *interp, Tcl_RegExp re); /* 150 */
+    void (*tclRegExpRangeUniChar) (Tcl_RegExp re, int index, int *startPtr, int *endPtr); /* 151 */
+    void (*tclSetLibraryPath) (Tcl_Obj *pathPtr); /* 152 */
     Tcl_Obj * (*tclGetLibraryPath) (void); /* 153 */
-    void *reserved154;
-    void *reserved155;
-    void (*tclRegError) (Tcl_Interp * interp, CONST char * msg, int status); /* 156 */
-    Var * (*tclVarTraceExists) (Tcl_Interp * interp, CONST char * varName); /* 157 */
-    void (*tclSetStartupScriptFileName) (CONST char * filename); /* 158 */
-    CONST84_RETURN char * (*tclGetStartupScriptFileName) (void); /* 159 */
-    void *reserved160;
-    int (*tclChannelTransform) (Tcl_Interp * interp, Tcl_Channel chan, Tcl_Obj * cmdObjPtr); /* 161 */
+    void (*reserved154)(void);
+    void (*reserved155)(void);
+    void (*tclRegError) (Tcl_Interp *interp, const char *msg, int status); /* 156 */
+    Var * (*tclVarTraceExists) (Tcl_Interp *interp, const char *varName); /* 157 */
+    void (*reserved158)(void);
+    void (*reserved159)(void);
+    void (*reserved160)(void);
+    int (*tclChannelTransform) (Tcl_Interp *interp, Tcl_Channel chan, Tcl_Obj *cmdObjPtr); /* 161 */
     void (*tclChannelEventScriptInvoker) (ClientData clientData, int flags); /* 162 */
-    CONST86 void * (*tclGetInstructionTable) (void); /* 163 */
-    void (*tclExpandCodeArray) (void * envPtr); /* 164 */
+    const void * (*tclGetInstructionTable) (void); /* 163 */
+    void (*tclExpandCodeArray) (void *envPtr); /* 164 */
     void (*tclpSetInitialEncodings) (void); /* 165 */
-    int (*tclListObjSetElement) (Tcl_Interp * interp, Tcl_Obj * listPtr, int index, Tcl_Obj * valuePtr); /* 166 */
-    void (*tclSetStartupScriptPath) (Tcl_Obj * pathPtr); /* 167 */
-    Tcl_Obj * (*tclGetStartupScriptPath) (void); /* 168 */
-    int (*tclpUtfNcmp2) (CONST char * s1, CONST char * s2, unsigned long n); /* 169 */
-    int (*tclCheckInterpTraces) (Tcl_Interp * interp, CONST char * command, int numChars, Command * cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *CONST objv[]); /* 170 */
-    int (*tclCheckExecutionTraces) (Tcl_Interp * interp, CONST char * command, int numChars, Command * cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *CONST objv[]); /* 171 */
+    int (*tclListObjSetElement) (Tcl_Interp *interp, Tcl_Obj *listPtr, int index, Tcl_Obj *valuePtr); /* 166 */
+    void (*reserved167)(void);
+    void (*reserved168)(void);
+    int (*tclpUtfNcmp2) (const char *s1, const char *s2, unsigned long n); /* 169 */
+    int (*tclCheckInterpTraces) (Tcl_Interp *interp, const char *command, int numChars, Command *cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *const objv[]); /* 170 */
+    int (*tclCheckExecutionTraces) (Tcl_Interp *interp, const char *command, int numChars, Command *cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *const objv[]); /* 171 */
     int (*tclInThreadExit) (void); /* 172 */
-    int (*tclUniCharMatch) (CONST Tcl_UniChar * string, int strLen, CONST Tcl_UniChar * pattern, int ptnLen, int flags); /* 173 */
-    void *reserved174;
-    int (*tclCallVarTraces) (Interp * iPtr, Var * arrayPtr, Var * varPtr, CONST char * part1, CONST char * part2, int flags, int leaveErrMsg); /* 175 */
-    void (*tclCleanupVar) (Var * varPtr, Var * arrayPtr); /* 176 */
-    void (*tclVarErrMsg) (Tcl_Interp * interp, CONST char * part1, CONST char * part2, CONST char * operation, CONST char * reason); /* 177 */
-    void (*tcl_SetStartupScript) (Tcl_Obj * pathPtr, CONST char* encodingName); /* 178 */
-    Tcl_Obj * (*tcl_GetStartupScript) (CONST char ** encodingNamePtr); /* 179 */
-    void *reserved180;
-    void *reserved181;
-    struct tm * (*tclpLocaltime) (CONST time_t * clock); /* 182 */
-    struct tm * (*tclpGmtime) (CONST time_t * clock); /* 183 */
-    void *reserved184;
-    void *reserved185;
-    void *reserved186;
-    void *reserved187;
-    void *reserved188;
-    void *reserved189;
-    void *reserved190;
-    void *reserved191;
-    void *reserved192;
-    void *reserved193;
-    void *reserved194;
-    void *reserved195;
-    void *reserved196;
-    void *reserved197;
-    int (*tclObjGetFrame) (Tcl_Interp * interp, Tcl_Obj * objPtr, CallFrame ** framePtrPtr); /* 198 */
-    void *reserved199;
-    int (*tclpObjRemoveDirectory) (Tcl_Obj * pathPtr, int recursive, Tcl_Obj ** errorPtr); /* 200 */
-    int (*tclpObjCopyDirectory) (Tcl_Obj * srcPathPtr, Tcl_Obj * destPathPtr, Tcl_Obj ** errorPtr); /* 201 */
-    int (*tclpObjCreateDirectory) (Tcl_Obj * pathPtr); /* 202 */
-    int (*tclpObjDeleteFile) (Tcl_Obj * pathPtr); /* 203 */
-    int (*tclpObjCopyFile) (Tcl_Obj * srcPathPtr, Tcl_Obj * destPathPtr); /* 204 */
-    int (*tclpObjRenameFile) (Tcl_Obj * srcPathPtr, Tcl_Obj * destPathPtr); /* 205 */
-    int (*tclpObjStat) (Tcl_Obj * pathPtr, Tcl_StatBuf * buf); /* 206 */
-    int (*tclpObjAccess) (Tcl_Obj * pathPtr, int mode); /* 207 */
-    Tcl_Channel (*tclpOpenFileChannel) (Tcl_Interp * interp, Tcl_Obj * pathPtr, int mode, int permissions); /* 208 */
-    void *reserved209;
-    void *reserved210;
-    void *reserved211;
-    void (*tclpFindExecutable) (CONST char * argv0); /* 212 */
+    int (*tclUniCharMatch) (const Tcl_UniChar *string, int strLen, const Tcl_UniChar *pattern, int ptnLen, int flags); /* 173 */
+    void (*reserved174)(void);
+    int (*tclCallVarTraces) (Interp *iPtr, Var *arrayPtr, Var *varPtr, const char *part1, const char *part2, int flags, int leaveErrMsg); /* 175 */
+    void (*tclCleanupVar) (Var *varPtr, Var *arrayPtr); /* 176 */
+    void (*tclVarErrMsg) (Tcl_Interp *interp, const char *part1, const char *part2, const char *operation, const char *reason); /* 177 */
+    void (*reserved178)(void);
+    void (*reserved179)(void);
+    void (*reserved180)(void);
+    void (*reserved181)(void);
+    struct tm * (*tclpLocaltime) (const time_t *clock); /* 182 */
+    struct tm * (*tclpGmtime) (const time_t *clock); /* 183 */
+    void (*reserved184)(void);
+    void (*reserved185)(void);
+    void (*reserved186)(void);
+    void (*reserved187)(void);
+    void (*reserved188)(void);
+    void (*reserved189)(void);
+    void (*reserved190)(void);
+    void (*reserved191)(void);
+    void (*reserved192)(void);
+    void (*reserved193)(void);
+    void (*reserved194)(void);
+    void (*reserved195)(void);
+    void (*reserved196)(void);
+    void (*reserved197)(void);
+    int (*tclObjGetFrame) (Tcl_Interp *interp, Tcl_Obj *objPtr, CallFrame **framePtrPtr); /* 198 */
+    void (*reserved199)(void);
+    int (*tclpObjRemoveDirectory) (Tcl_Obj *pathPtr, int recursive, Tcl_Obj **errorPtr); /* 200 */
+    int (*tclpObjCopyDirectory) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr); /* 201 */
+    int (*tclpObjCreateDirectory) (Tcl_Obj *pathPtr); /* 202 */
+    int (*tclpObjDeleteFile) (Tcl_Obj *pathPtr); /* 203 */
+    int (*tclpObjCopyFile) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr); /* 204 */
+    int (*tclpObjRenameFile) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr); /* 205 */
+    int (*tclpObjStat) (Tcl_Obj *pathPtr, Tcl_StatBuf *buf); /* 206 */
+    int (*tclpObjAccess) (Tcl_Obj *pathPtr, int mode); /* 207 */
+    Tcl_Channel (*tclpOpenFileChannel) (Tcl_Interp *interp, Tcl_Obj *pathPtr, int mode, int permissions); /* 208 */
+    void (*reserved209)(void);
+    void (*reserved210)(void);
+    void (*reserved211)(void);
+    void (*tclpFindExecutable) (const char *argv0); /* 212 */
     Tcl_Obj * (*tclGetObjNameOfExecutable) (void); /* 213 */
-    void (*tclSetObjNameOfExecutable) (Tcl_Obj * name, Tcl_Encoding encoding); /* 214 */
-    void * (*tclStackAlloc) (Tcl_Interp * interp, int numBytes); /* 215 */
-    void (*tclStackFree) (Tcl_Interp * interp, void * freePtr); /* 216 */
-    int (*tclPushStackFrame) (Tcl_Interp * interp, Tcl_CallFrame ** framePtrPtr, Tcl_Namespace * namespacePtr, int isProcCallFrame); /* 217 */
-    void (*tclPopStackFrame) (Tcl_Interp * interp); /* 218 */
-    void *reserved219;
-    void *reserved220;
-    void *reserved221;
-    void *reserved222;
-    void *reserved223;
+    void (*tclSetObjNameOfExecutable) (Tcl_Obj *name, Tcl_Encoding encoding); /* 214 */
+    void * (*tclStackAlloc) (Tcl_Interp *interp, int numBytes); /* 215 */
+    void (*tclStackFree) (Tcl_Interp *interp, void *freePtr); /* 216 */
+    int (*tclPushStackFrame) (Tcl_Interp *interp, Tcl_CallFrame **framePtrPtr, Tcl_Namespace *namespacePtr, int isProcCallFrame); /* 217 */
+    void (*tclPopStackFrame) (Tcl_Interp *interp); /* 218 */
+    void (*reserved219)(void);
+    void (*reserved220)(void);
+    void (*reserved221)(void);
+    void (*reserved222)(void);
+    void (*reserved223)(void);
     TclPlatformType * (*tclGetPlatform) (void); /* 224 */
-    Tcl_Obj * (*tclTraceDictPath) (Tcl_Interp * interp, Tcl_Obj * rootPtr, int keyc, Tcl_Obj *CONST keyv[], int flags); /* 225 */
-    int (*tclObjBeingDeleted) (Tcl_Obj * objPtr); /* 226 */
-    void (*tclSetNsPath) (Namespace * nsPtr, int pathLength, Tcl_Namespace * pathAry[]); /* 227 */
-    void *reserved228;
-    int (*tclPtrMakeUpvar) (Tcl_Interp * interp, Var * otherP1Ptr, CONST char * myName, int myFlags, int index); /* 229 */
-    Var * (*tclObjLookupVar) (Tcl_Interp * interp, Tcl_Obj * part1Ptr, CONST char * part2, int flags, CONST char * msg, CONST int createPart1, CONST int createPart2, Var ** arrayPtrPtr); /* 230 */
-    int (*tclGetNamespaceFromObj) (Tcl_Interp * interp, Tcl_Obj * objPtr, Tcl_Namespace ** nsPtrPtr); /* 231 */
-    int (*tclEvalObjEx) (Tcl_Interp * interp, Tcl_Obj * objPtr, int flags, CONST CmdFrame * invoker, int word); /* 232 */
-    void (*tclGetSrcInfoForPc) (CmdFrame * contextPtr); /* 233 */
-    Var * (*tclVarHashCreateVar) (TclVarHashTable * tablePtr, CONST char * key, int * newPtr); /* 234 */
-    void (*tclInitVarHashTable) (TclVarHashTable * tablePtr, Namespace * nsPtr); /* 235 */
-    void (*tclBackgroundException) (Tcl_Interp * interp, int code); /* 236 */
-    int (*tclResetCancellation) (Tcl_Interp * interp, int force); /* 237 */
-    int (*tclNRInterpProc) (ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[]); /* 238 */
-    int (*tclNRInterpProcCore) (Tcl_Interp * interp, Tcl_Obj * procNameObj, int skip, ProcErrorProc errorProc); /* 239 */
-    int (*tclNRRunCallbacks) (Tcl_Interp * interp, int result, struct TEOV_callback * rootPtr, int tebcCall); /* 240 */
-    int (*tclNREvalObjEx) (Tcl_Interp * interp, Tcl_Obj * objPtr, int flags, CONST CmdFrame * invoker, int word); /* 241 */
-    int (*tclNREvalObjv) (Tcl_Interp * interp, int objc, Tcl_Obj *const objv[], int flags, Command * cmdPtr); /* 242 */
+    Tcl_Obj * (*tclTraceDictPath) (Tcl_Interp *interp, Tcl_Obj *rootPtr, int keyc, Tcl_Obj *const keyv[], int flags); /* 225 */
+    int (*tclObjBeingDeleted) (Tcl_Obj *objPtr); /* 226 */
+    void (*tclSetNsPath) (Namespace *nsPtr, int pathLength, Tcl_Namespace *pathAry[]); /* 227 */
+    void (*reserved228)(void);
+    int (*tclPtrMakeUpvar) (Tcl_Interp *interp, Var *otherP1Ptr, const char *myName, int myFlags, int index); /* 229 */
+    Var * (*tclObjLookupVar) (Tcl_Interp *interp, Tcl_Obj *part1Ptr, const char *part2, int flags, const char *msg, const int createPart1, const int createPart2, Var **arrayPtrPtr); /* 230 */
+    int (*tclGetNamespaceFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_Namespace **nsPtrPtr); /* 231 */
+    int (*tclEvalObjEx) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags, const CmdFrame *invoker, int word); /* 232 */
+    void (*tclGetSrcInfoForPc) (CmdFrame *contextPtr); /* 233 */
+    Var * (*tclVarHashCreateVar) (TclVarHashTable *tablePtr, const char *key, int *newPtr); /* 234 */
+    void (*tclInitVarHashTable) (TclVarHashTable *tablePtr, Namespace *nsPtr); /* 235 */
+    void (*reserved236)(void);
+    int (*tclResetCancellation) (Tcl_Interp *interp, int force); /* 237 */
+    int (*tclNRInterpProc) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 238 */
+    int (*tclNRInterpProcCore) (Tcl_Interp *interp, Tcl_Obj *procNameObj, int skip, ProcErrorProc *errorProc); /* 239 */
+    int (*tclNRRunCallbacks) (Tcl_Interp *interp, int result, struct NRE_callback *rootPtr); /* 240 */
+    int (*tclNREvalObjEx) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags, const CmdFrame *invoker, int word); /* 241 */
+    int (*tclNREvalObjv) (Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], int flags, Command *cmdPtr); /* 242 */
+    void (*tclDbDumpActiveObjects) (FILE *outFile); /* 243 */
+    Tcl_HashTable * (*tclGetNamespaceChildTable) (Tcl_Namespace *nsPtr); /* 244 */
+    Tcl_HashTable * (*tclGetNamespaceCommandTable) (Tcl_Namespace *nsPtr); /* 245 */
+    int (*tclInitRewriteEnsemble) (Tcl_Interp *interp, int numRemoved, int numInserted, Tcl_Obj *const *objv); /* 246 */
+    void (*tclResetRewriteEnsemble) (Tcl_Interp *interp, int isRootEnsemble); /* 247 */
+    int (*tclCopyChannel) (Tcl_Interp *interp, Tcl_Channel inChan, Tcl_Channel outChan, Tcl_WideInt toRead, Tcl_Obj *cmdPtr); /* 248 */
+    char * (*tclDoubleDigits) (double dv, int ndigits, int flags, int *decpt, int *signum, char **endPtr); /* 249 */
+    void (*tclSetSlaveCancelFlags) (Tcl_Interp *interp, int flags, int force); /* 250 */
 } TclIntStubs;
 
-#if defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS)
-extern CONST TclIntStubs *tclIntStubsPtr;
-#endif /* defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS) */
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern const TclIntStubs *tclIntStubsPtr;
+#ifdef __cplusplus
+}
+#endif
 
-#if defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS)
+#if defined(USE_TCL_STUBS)
 
 /*
  * Inline function declarations:
@@ -1391,589 +876,302 @@
 /* Slot 0 is reserved */
 /* Slot 1 is reserved */
 /* Slot 2 is reserved */
-#ifndef TclAllocateFreeObjects
 #define TclAllocateFreeObjects \
   (tclIntStubsPtr->tclAllocateFreeObjects) /* 3 */
-#endif
 /* Slot 4 is reserved */
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-#ifndef TclCleanupChildren
-#define TclCleanupChildren \
-  (tclIntStubsPtr->tclCleanupChildren) /* 5 */
-#endif
-#endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
-#ifndef TclCleanupChildren
-#define TclCleanupChildren \
-  (tclIntStubsPtr->tclCleanupChildren) /* 5 */
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TCL /* MACOSX */
-#ifndef TclCleanupChildren
 #define TclCleanupChildren \
   (tclIntStubsPtr->tclCleanupChildren) /* 5 */
-#endif
-#endif /* MACOSX */
-#ifndef TclCleanupCommand
 #define TclCleanupCommand \
   (tclIntStubsPtr->tclCleanupCommand) /* 6 */
-#endif
-#ifndef TclCopyAndCollapse
 #define TclCopyAndCollapse \
   (tclIntStubsPtr->tclCopyAndCollapse) /* 7 */
-#endif
-#ifndef TclCopyChannel
-#define TclCopyChannel \
-  (tclIntStubsPtr->tclCopyChannel) /* 8 */
-#endif
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-#ifndef TclCreatePipeline
-#define TclCreatePipeline \
-  (tclIntStubsPtr->tclCreatePipeline) /* 9 */
-#endif
-#endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
-#ifndef TclCreatePipeline
-#define TclCreatePipeline \
-  (tclIntStubsPtr->tclCreatePipeline) /* 9 */
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TCL /* MACOSX */
-#ifndef TclCreatePipeline
+#define TclCopyChannelOld \
+  (tclIntStubsPtr->tclCopyChannelOld) /* 8 */
 #define TclCreatePipeline \
   (tclIntStubsPtr->tclCreatePipeline) /* 9 */
-#endif
-#endif /* MACOSX */
-#ifndef TclCreateProc
 #define TclCreateProc \
   (tclIntStubsPtr->tclCreateProc) /* 10 */
-#endif
-#ifndef TclDeleteCompiledLocalVars
 #define TclDeleteCompiledLocalVars \
   (tclIntStubsPtr->tclDeleteCompiledLocalVars) /* 11 */
-#endif
-#ifndef TclDeleteVars
 #define TclDeleteVars \
   (tclIntStubsPtr->tclDeleteVars) /* 12 */
-#endif
 /* Slot 13 is reserved */
-#ifndef TclDumpMemoryInfo
 #define TclDumpMemoryInfo \
   (tclIntStubsPtr->tclDumpMemoryInfo) /* 14 */
-#endif
 /* Slot 15 is reserved */
-#ifndef TclExprFloatError
 #define TclExprFloatError \
   (tclIntStubsPtr->tclExprFloatError) /* 16 */
-#endif
 /* Slot 17 is reserved */
 /* Slot 18 is reserved */
 /* Slot 19 is reserved */
 /* Slot 20 is reserved */
 /* Slot 21 is reserved */
-#ifndef TclFindElement
 #define TclFindElement \
   (tclIntStubsPtr->tclFindElement) /* 22 */
-#endif
-#ifndef TclFindProc
 #define TclFindProc \
   (tclIntStubsPtr->tclFindProc) /* 23 */
-#endif
-/* Slot 24 is reserved */
-#ifndef TclFreePackageInfo
+#define TclFormatInt \
+  (tclIntStubsPtr->tclFormatInt) /* 24 */
 #define TclFreePackageInfo \
   (tclIntStubsPtr->tclFreePackageInfo) /* 25 */
-#endif
 /* Slot 26 is reserved */
 /* Slot 27 is reserved */
-#ifndef TclpGetDefaultStdChannel
 #define TclpGetDefaultStdChannel \
   (tclIntStubsPtr->tclpGetDefaultStdChannel) /* 28 */
-#endif
 /* Slot 29 is reserved */
 /* Slot 30 is reserved */
-#ifndef TclGetExtension
 #define TclGetExtension \
   (tclIntStubsPtr->tclGetExtension) /* 31 */
-#endif
-#ifndef TclGetFrame
 #define TclGetFrame \
   (tclIntStubsPtr->tclGetFrame) /* 32 */
-#endif
 /* Slot 33 is reserved */
-#ifndef TclGetIntForIndex
 #define TclGetIntForIndex \
   (tclIntStubsPtr->tclGetIntForIndex) /* 34 */
-#endif
 /* Slot 35 is reserved */
 /* Slot 36 is reserved */
-#ifndef TclGetLoadedPackages
 #define TclGetLoadedPackages \
   (tclIntStubsPtr->tclGetLoadedPackages) /* 37 */
-#endif
-#ifndef TclGetNamespaceForQualName
 #define TclGetNamespaceForQualName \
   (tclIntStubsPtr->tclGetNamespaceForQualName) /* 38 */
-#endif
-#ifndef TclGetObjInterpProc
 #define TclGetObjInterpProc \
   (tclIntStubsPtr->tclGetObjInterpProc) /* 39 */
-#endif
-#ifndef TclGetOpenMode
 #define TclGetOpenMode \
   (tclIntStubsPtr->tclGetOpenMode) /* 40 */
-#endif
-#ifndef TclGetOriginalCommand
 #define TclGetOriginalCommand \
   (tclIntStubsPtr->tclGetOriginalCommand) /* 41 */
-#endif
-#ifndef TclpGetUserHome
 #define TclpGetUserHome \
   (tclIntStubsPtr->tclpGetUserHome) /* 42 */
-#endif
 /* Slot 43 is reserved */
-#ifndef TclGuessPackageName
 #define TclGuessPackageName \
   (tclIntStubsPtr->tclGuessPackageName) /* 44 */
-#endif
-#ifndef TclHideUnsafeCommands
 #define TclHideUnsafeCommands \
   (tclIntStubsPtr->tclHideUnsafeCommands) /* 45 */
-#endif
-#ifndef TclInExit
 #define TclInExit \
   (tclIntStubsPtr->tclInExit) /* 46 */
-#endif
 /* Slot 47 is reserved */
 /* Slot 48 is reserved */
 /* Slot 49 is reserved */
-#ifndef TclInitCompiledLocals
 #define TclInitCompiledLocals \
   (tclIntStubsPtr->tclInitCompiledLocals) /* 50 */
-#endif
-#ifndef TclInterpInit
 #define TclInterpInit \
   (tclIntStubsPtr->tclInterpInit) /* 51 */
-#endif
 /* Slot 52 is reserved */
-#ifndef TclInvokeObjectCommand
 #define TclInvokeObjectCommand \
   (tclIntStubsPtr->tclInvokeObjectCommand) /* 53 */
-#endif
-#ifndef TclInvokeStringCommand
 #define TclInvokeStringCommand \
   (tclIntStubsPtr->tclInvokeStringCommand) /* 54 */
-#endif
-#ifndef TclIsProc
 #define TclIsProc \
   (tclIntStubsPtr->tclIsProc) /* 55 */
-#endif
 /* Slot 56 is reserved */
 /* Slot 57 is reserved */
-#ifndef TclLookupVar
 #define TclLookupVar \
   (tclIntStubsPtr->tclLookupVar) /* 58 */
-#endif
 /* Slot 59 is reserved */
-#ifndef TclNeedSpace
 #define TclNeedSpace \
   (tclIntStubsPtr->tclNeedSpace) /* 60 */
-#endif
-#ifndef TclNewProcBodyObj
 #define TclNewProcBodyObj \
   (tclIntStubsPtr->tclNewProcBodyObj) /* 61 */
-#endif
-#ifndef TclObjCommandComplete
 #define TclObjCommandComplete \
   (tclIntStubsPtr->tclObjCommandComplete) /* 62 */
-#endif
-#ifndef TclObjInterpProc
 #define TclObjInterpProc \
   (tclIntStubsPtr->tclObjInterpProc) /* 63 */
-#endif
-#ifndef TclObjInvoke
 #define TclObjInvoke \
   (tclIntStubsPtr->tclObjInvoke) /* 64 */
-#endif
 /* Slot 65 is reserved */
 /* Slot 66 is reserved */
 /* Slot 67 is reserved */
 /* Slot 68 is reserved */
-#ifndef TclpAlloc
 #define TclpAlloc \
   (tclIntStubsPtr->tclpAlloc) /* 69 */
-#endif
 /* Slot 70 is reserved */
 /* Slot 71 is reserved */
 /* Slot 72 is reserved */
 /* Slot 73 is reserved */
-#ifndef TclpFree
 #define TclpFree \
   (tclIntStubsPtr->tclpFree) /* 74 */
-#endif
-#ifndef TclpGetClicks
 #define TclpGetClicks \
   (tclIntStubsPtr->tclpGetClicks) /* 75 */
-#endif
-#ifndef TclpGetSeconds
 #define TclpGetSeconds \
   (tclIntStubsPtr->tclpGetSeconds) /* 76 */
-#endif
-#ifndef TclpGetTime
 #define TclpGetTime \
   (tclIntStubsPtr->tclpGetTime) /* 77 */
-#endif
-#ifndef TclpGetTimeZone
-#define TclpGetTimeZone \
-  (tclIntStubsPtr->tclpGetTimeZone) /* 78 */
-#endif
+/* Slot 78 is reserved */
 /* Slot 79 is reserved */
 /* Slot 80 is reserved */
-#ifndef TclpRealloc
 #define TclpRealloc \
   (tclIntStubsPtr->tclpRealloc) /* 81 */
-#endif
 /* Slot 82 is reserved */
 /* Slot 83 is reserved */
 /* Slot 84 is reserved */
 /* Slot 85 is reserved */
 /* Slot 86 is reserved */
 /* Slot 87 is reserved */
-#ifndef TclPrecTraceProc
 #define TclPrecTraceProc \
   (tclIntStubsPtr->tclPrecTraceProc) /* 88 */
-#endif
-#ifndef TclPreventAliasLoop
 #define TclPreventAliasLoop \
   (tclIntStubsPtr->tclPreventAliasLoop) /* 89 */
-#endif
 /* Slot 90 is reserved */
-#ifndef TclProcCleanupProc
 #define TclProcCleanupProc \
   (tclIntStubsPtr->tclProcCleanupProc) /* 91 */
-#endif
-#ifndef TclProcCompileProc
 #define TclProcCompileProc \
   (tclIntStubsPtr->tclProcCompileProc) /* 92 */
-#endif
-#ifndef TclProcDeleteProc
 #define TclProcDeleteProc \
   (tclIntStubsPtr->tclProcDeleteProc) /* 93 */
-#endif
 /* Slot 94 is reserved */
 /* Slot 95 is reserved */
-#ifndef TclRenameCommand
 #define TclRenameCommand \
   (tclIntStubsPtr->tclRenameCommand) /* 96 */
-#endif
-#ifndef TclResetShadowedCmdRefs
 #define TclResetShadowedCmdRefs \
   (tclIntStubsPtr->tclResetShadowedCmdRefs) /* 97 */
-#endif
-#ifndef TclServiceIdle
 #define TclServiceIdle \
   (tclIntStubsPtr->tclServiceIdle) /* 98 */
-#endif
 /* Slot 99 is reserved */
 /* Slot 100 is reserved */
-#ifndef TclSetPreInitScript
 #define TclSetPreInitScript \
   (tclIntStubsPtr->tclSetPreInitScript) /* 101 */
-#endif
-#ifndef TclSetupEnv
 #define TclSetupEnv \
   (tclIntStubsPtr->tclSetupEnv) /* 102 */
-#endif
-#ifndef TclSockGetPort
 #define TclSockGetPort \
   (tclIntStubsPtr->tclSockGetPort) /* 103 */
-#endif
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-#ifndef TclSockMinimumBuffers
-#define TclSockMinimumBuffers \
-  (tclIntStubsPtr->tclSockMinimumBuffers) /* 104 */
-#endif
-#endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
-#ifndef TclSockMinimumBuffers
-#define TclSockMinimumBuffers \
-  (tclIntStubsPtr->tclSockMinimumBuffers) /* 104 */
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TCL /* MACOSX */
-#ifndef TclSockMinimumBuffers
-#define TclSockMinimumBuffers \
-  (tclIntStubsPtr->tclSockMinimumBuffers) /* 104 */
-#endif
-#endif /* MACOSX */
+#define TclSockMinimumBuffersOld \
+  (tclIntStubsPtr->tclSockMinimumBuffersOld) /* 104 */
 /* Slot 105 is reserved */
 /* Slot 106 is reserved */
 /* Slot 107 is reserved */
-#ifndef TclTeardownNamespace
 #define TclTeardownNamespace \
   (tclIntStubsPtr->tclTeardownNamespace) /* 108 */
-#endif
-#ifndef TclUpdateReturnInfo
 #define TclUpdateReturnInfo \
   (tclIntStubsPtr->tclUpdateReturnInfo) /* 109 */
-#endif
-/* Slot 110 is reserved */
-#ifndef Tcl_AddInterpResolvers
+#define TclSockMinimumBuffers \
+  (tclIntStubsPtr->tclSockMinimumBuffers) /* 110 */
 #define Tcl_AddInterpResolvers \
   (tclIntStubsPtr->tcl_AddInterpResolvers) /* 111 */
-#endif
-#ifndef Tcl_AppendExportList
 #define Tcl_AppendExportList \
   (tclIntStubsPtr->tcl_AppendExportList) /* 112 */
-#endif
-#ifndef Tcl_CreateNamespace
 #define Tcl_CreateNamespace \
   (tclIntStubsPtr->tcl_CreateNamespace) /* 113 */
-#endif
-#ifndef Tcl_DeleteNamespace
 #define Tcl_DeleteNamespace \
   (tclIntStubsPtr->tcl_DeleteNamespace) /* 114 */
-#endif
-#ifndef Tcl_Export
 #define Tcl_Export \
   (tclIntStubsPtr->tcl_Export) /* 115 */
-#endif
-#ifndef Tcl_FindCommand
 #define Tcl_FindCommand \
   (tclIntStubsPtr->tcl_FindCommand) /* 116 */
-#endif
-#ifndef Tcl_FindNamespace
 #define Tcl_FindNamespace \
   (tclIntStubsPtr->tcl_FindNamespace) /* 117 */
-#endif
-#ifndef Tcl_GetInterpResolvers
 #define Tcl_GetInterpResolvers \
   (tclIntStubsPtr->tcl_GetInterpResolvers) /* 118 */
-#endif
-#ifndef Tcl_GetNamespaceResolvers
 #define Tcl_GetNamespaceResolvers \
   (tclIntStubsPtr->tcl_GetNamespaceResolvers) /* 119 */
-#endif
-#ifndef Tcl_FindNamespaceVar
 #define Tcl_FindNamespaceVar \
   (tclIntStubsPtr->tcl_FindNamespaceVar) /* 120 */
-#endif
-#ifndef Tcl_ForgetImport
 #define Tcl_ForgetImport \
   (tclIntStubsPtr->tcl_ForgetImport) /* 121 */
-#endif
-#ifndef Tcl_GetCommandFromObj
 #define Tcl_GetCommandFromObj \
   (tclIntStubsPtr->tcl_GetCommandFromObj) /* 122 */
-#endif
-#ifndef Tcl_GetCommandFullName
 #define Tcl_GetCommandFullName \
   (tclIntStubsPtr->tcl_GetCommandFullName) /* 123 */
-#endif
-#ifndef Tcl_GetCurrentNamespace
 #define Tcl_GetCurrentNamespace \
   (tclIntStubsPtr->tcl_GetCurrentNamespace) /* 124 */
-#endif
-#ifndef Tcl_GetGlobalNamespace
 #define Tcl_GetGlobalNamespace \
   (tclIntStubsPtr->tcl_GetGlobalNamespace) /* 125 */
-#endif
-#ifndef Tcl_GetVariableFullName
 #define Tcl_GetVariableFullName \
   (tclIntStubsPtr->tcl_GetVariableFullName) /* 126 */
-#endif
-#ifndef Tcl_Import
 #define Tcl_Import \
   (tclIntStubsPtr->tcl_Import) /* 127 */
-#endif
-#ifndef Tcl_PopCallFrame
 #define Tcl_PopCallFrame \
   (tclIntStubsPtr->tcl_PopCallFrame) /* 128 */
-#endif
-#ifndef Tcl_PushCallFrame
 #define Tcl_PushCallFrame \
   (tclIntStubsPtr->tcl_PushCallFrame) /* 129 */
-#endif
-#ifndef Tcl_RemoveInterpResolvers
 #define Tcl_RemoveInterpResolvers \
   (tclIntStubsPtr->tcl_RemoveInterpResolvers) /* 130 */
-#endif
-#ifndef Tcl_SetNamespaceResolvers
 #define Tcl_SetNamespaceResolvers \
   (tclIntStubsPtr->tcl_SetNamespaceResolvers) /* 131 */
-#endif
-#ifndef TclpHasSockets
 #define TclpHasSockets \
   (tclIntStubsPtr->tclpHasSockets) /* 132 */
-#endif
-#ifndef TclpGetDate
 #define TclpGetDate \
   (tclIntStubsPtr->tclpGetDate) /* 133 */
-#endif
 /* Slot 134 is reserved */
 /* Slot 135 is reserved */
 /* Slot 136 is reserved */
 /* Slot 137 is reserved */
-#ifndef TclGetEnv
 #define TclGetEnv \
   (tclIntStubsPtr->tclGetEnv) /* 138 */
-#endif
 /* Slot 139 is reserved */
 /* Slot 140 is reserved */
-#ifndef TclpGetCwd
 #define TclpGetCwd \
   (tclIntStubsPtr->tclpGetCwd) /* 141 */
-#endif
-#ifndef TclSetByteCodeFromAny
 #define TclSetByteCodeFromAny \
   (tclIntStubsPtr->tclSetByteCodeFromAny) /* 142 */
-#endif
-#ifndef TclAddLiteralObj
 #define TclAddLiteralObj \
   (tclIntStubsPtr->tclAddLiteralObj) /* 143 */
-#endif
-#ifndef TclHideLiteral
 #define TclHideLiteral \
   (tclIntStubsPtr->tclHideLiteral) /* 144 */
-#endif
-#ifndef TclGetAuxDataType
 #define TclGetAuxDataType \
   (tclIntStubsPtr->tclGetAuxDataType) /* 145 */
-#endif
-#ifndef TclHandleCreate
 #define TclHandleCreate \
   (tclIntStubsPtr->tclHandleCreate) /* 146 */
-#endif
-#ifndef TclHandleFree
 #define TclHandleFree \
   (tclIntStubsPtr->tclHandleFree) /* 147 */
-#endif
-#ifndef TclHandlePreserve
 #define TclHandlePreserve \
   (tclIntStubsPtr->tclHandlePreserve) /* 148 */
-#endif
-#ifndef TclHandleRelease
 #define TclHandleRelease \
   (tclIntStubsPtr->tclHandleRelease) /* 149 */
-#endif
-#ifndef TclRegAbout
 #define TclRegAbout \
   (tclIntStubsPtr->tclRegAbout) /* 150 */
-#endif
-#ifndef TclRegExpRangeUniChar
 #define TclRegExpRangeUniChar \
   (tclIntStubsPtr->tclRegExpRangeUniChar) /* 151 */
-#endif
-#ifndef TclSetLibraryPath
 #define TclSetLibraryPath \
   (tclIntStubsPtr->tclSetLibraryPath) /* 152 */
-#endif
-#ifndef TclGetLibraryPath
 #define TclGetLibraryPath \
   (tclIntStubsPtr->tclGetLibraryPath) /* 153 */
-#endif
 /* Slot 154 is reserved */
 /* Slot 155 is reserved */
-#ifndef TclRegError
 #define TclRegError \
   (tclIntStubsPtr->tclRegError) /* 156 */
-#endif
-#ifndef TclVarTraceExists
 #define TclVarTraceExists \
   (tclIntStubsPtr->tclVarTraceExists) /* 157 */
-#endif
-#ifndef TclSetStartupScriptFileName
-#define TclSetStartupScriptFileName \
-  (tclIntStubsPtr->tclSetStartupScriptFileName) /* 158 */
-#endif
-#ifndef TclGetStartupScriptFileName
-#define TclGetStartupScriptFileName \
-  (tclIntStubsPtr->tclGetStartupScriptFileName) /* 159 */
-#endif
+/* Slot 158 is reserved */
+/* Slot 159 is reserved */
 /* Slot 160 is reserved */
-#ifndef TclChannelTransform
 #define TclChannelTransform \
   (tclIntStubsPtr->tclChannelTransform) /* 161 */
-#endif
-#ifndef TclChannelEventScriptInvoker
 #define TclChannelEventScriptInvoker \
   (tclIntStubsPtr->tclChannelEventScriptInvoker) /* 162 */
-#endif
-#ifndef TclGetInstructionTable
 #define TclGetInstructionTable \
   (tclIntStubsPtr->tclGetInstructionTable) /* 163 */
-#endif
-#ifndef TclExpandCodeArray
 #define TclExpandCodeArray \
   (tclIntStubsPtr->tclExpandCodeArray) /* 164 */
-#endif
-#ifndef TclpSetInitialEncodings
 #define TclpSetInitialEncodings \
   (tclIntStubsPtr->tclpSetInitialEncodings) /* 165 */
-#endif
-#ifndef TclListObjSetElement
 #define TclListObjSetElement \
   (tclIntStubsPtr->tclListObjSetElement) /* 166 */
-#endif
-#ifndef TclSetStartupScriptPath
-#define TclSetStartupScriptPath \
-  (tclIntStubsPtr->tclSetStartupScriptPath) /* 167 */
-#endif
-#ifndef TclGetStartupScriptPath
-#define TclGetStartupScriptPath \
-  (tclIntStubsPtr->tclGetStartupScriptPath) /* 168 */
-#endif
-#ifndef TclpUtfNcmp2
+/* Slot 167 is reserved */
+/* Slot 168 is reserved */
 #define TclpUtfNcmp2 \
   (tclIntStubsPtr->tclpUtfNcmp2) /* 169 */
-#endif
-#ifndef TclCheckInterpTraces
 #define TclCheckInterpTraces \
   (tclIntStubsPtr->tclCheckInterpTraces) /* 170 */
-#endif
-#ifndef TclCheckExecutionTraces
 #define TclCheckExecutionTraces \
   (tclIntStubsPtr->tclCheckExecutionTraces) /* 171 */
-#endif
-#ifndef TclInThreadExit
 #define TclInThreadExit \
   (tclIntStubsPtr->tclInThreadExit) /* 172 */
-#endif
-#ifndef TclUniCharMatch
 #define TclUniCharMatch \
   (tclIntStubsPtr->tclUniCharMatch) /* 173 */
-#endif
 /* Slot 174 is reserved */
-#ifndef TclCallVarTraces
 #define TclCallVarTraces \
   (tclIntStubsPtr->tclCallVarTraces) /* 175 */
-#endif
-#ifndef TclCleanupVar
 #define TclCleanupVar \
   (tclIntStubsPtr->tclCleanupVar) /* 176 */
-#endif
-#ifndef TclVarErrMsg
 #define TclVarErrMsg \
   (tclIntStubsPtr->tclVarErrMsg) /* 177 */
-#endif
-#ifndef Tcl_SetStartupScript
-#define Tcl_SetStartupScript \
-  (tclIntStubsPtr->tcl_SetStartupScript) /* 178 */
-#endif
-#ifndef Tcl_GetStartupScript
-#define Tcl_GetStartupScript \
-  (tclIntStubsPtr->tcl_GetStartupScript) /* 179 */
-#endif
+/* Slot 178 is reserved */
+/* Slot 179 is reserved */
 /* Slot 180 is reserved */
 /* Slot 181 is reserved */
-#ifndef TclpLocaltime
 #define TclpLocaltime \
   (tclIntStubsPtr->tclpLocaltime) /* 182 */
-#endif
-#ifndef TclpGmtime
 #define TclpGmtime \
   (tclIntStubsPtr->tclpGmtime) /* 183 */
-#endif
 /* Slot 184 is reserved */
 /* Slot 185 is reserved */
 /* Slot 186 is reserved */
@@ -1988,158 +1186,103 @@
 /* Slot 195 is reserved */
 /* Slot 196 is reserved */
 /* Slot 197 is reserved */
-#ifndef TclObjGetFrame
 #define TclObjGetFrame \
   (tclIntStubsPtr->tclObjGetFrame) /* 198 */
-#endif
 /* Slot 199 is reserved */
-#ifndef TclpObjRemoveDirectory
 #define TclpObjRemoveDirectory \
   (tclIntStubsPtr->tclpObjRemoveDirectory) /* 200 */
-#endif
-#ifndef TclpObjCopyDirectory
 #define TclpObjCopyDirectory \
   (tclIntStubsPtr->tclpObjCopyDirectory) /* 201 */
-#endif
-#ifndef TclpObjCreateDirectory
 #define TclpObjCreateDirectory \
   (tclIntStubsPtr->tclpObjCreateDirectory) /* 202 */
-#endif
-#ifndef TclpObjDeleteFile
 #define TclpObjDeleteFile \
   (tclIntStubsPtr->tclpObjDeleteFile) /* 203 */
-#endif
-#ifndef TclpObjCopyFile
 #define TclpObjCopyFile \
   (tclIntStubsPtr->tclpObjCopyFile) /* 204 */
-#endif
-#ifndef TclpObjRenameFile
 #define TclpObjRenameFile \
   (tclIntStubsPtr->tclpObjRenameFile) /* 205 */
-#endif
-#ifndef TclpObjStat
 #define TclpObjStat \
   (tclIntStubsPtr->tclpObjStat) /* 206 */
-#endif
-#ifndef TclpObjAccess
 #define TclpObjAccess \
   (tclIntStubsPtr->tclpObjAccess) /* 207 */
-#endif
-#ifndef TclpOpenFileChannel
 #define TclpOpenFileChannel \
   (tclIntStubsPtr->tclpOpenFileChannel) /* 208 */
-#endif
 /* Slot 209 is reserved */
 /* Slot 210 is reserved */
 /* Slot 211 is reserved */
-#ifndef TclpFindExecutable
 #define TclpFindExecutable \
   (tclIntStubsPtr->tclpFindExecutable) /* 212 */
-#endif
-#ifndef TclGetObjNameOfExecutable
 #define TclGetObjNameOfExecutable \
   (tclIntStubsPtr->tclGetObjNameOfExecutable) /* 213 */
-#endif
-#ifndef TclSetObjNameOfExecutable
 #define TclSetObjNameOfExecutable \
   (tclIntStubsPtr->tclSetObjNameOfExecutable) /* 214 */
-#endif
-#ifndef TclStackAlloc
 #define TclStackAlloc \
   (tclIntStubsPtr->tclStackAlloc) /* 215 */
-#endif
-#ifndef TclStackFree
 #define TclStackFree \
   (tclIntStubsPtr->tclStackFree) /* 216 */
-#endif
-#ifndef TclPushStackFrame
 #define TclPushStackFrame \
   (tclIntStubsPtr->tclPushStackFrame) /* 217 */
-#endif
-#ifndef TclPopStackFrame
 #define TclPopStackFrame \
   (tclIntStubsPtr->tclPopStackFrame) /* 218 */
-#endif
 /* Slot 219 is reserved */
 /* Slot 220 is reserved */
 /* Slot 221 is reserved */
 /* Slot 222 is reserved */
 /* Slot 223 is reserved */
-#ifndef TclGetPlatform
 #define TclGetPlatform \
   (tclIntStubsPtr->tclGetPlatform) /* 224 */
-#endif
-#ifndef TclTraceDictPath
 #define TclTraceDictPath \
   (tclIntStubsPtr->tclTraceDictPath) /* 225 */
-#endif
-#ifndef TclObjBeingDeleted
 #define TclObjBeingDeleted \
   (tclIntStubsPtr->tclObjBeingDeleted) /* 226 */
-#endif
-#ifndef TclSetNsPath
 #define TclSetNsPath \
   (tclIntStubsPtr->tclSetNsPath) /* 227 */
-#endif
 /* Slot 228 is reserved */
-#ifndef TclPtrMakeUpvar
 #define TclPtrMakeUpvar \
   (tclIntStubsPtr->tclPtrMakeUpvar) /* 229 */
-#endif
-#ifndef TclObjLookupVar
 #define TclObjLookupVar \
   (tclIntStubsPtr->tclObjLookupVar) /* 230 */
-#endif
-#ifndef TclGetNamespaceFromObj
 #define TclGetNamespaceFromObj \
   (tclIntStubsPtr->tclGetNamespaceFromObj) /* 231 */
-#endif
-#ifndef TclEvalObjEx
 #define TclEvalObjEx \
   (tclIntStubsPtr->tclEvalObjEx) /* 232 */
-#endif
-#ifndef TclGetSrcInfoForPc
 #define TclGetSrcInfoForPc \
   (tclIntStubsPtr->tclGetSrcInfoForPc) /* 233 */
-#endif
-#ifndef TclVarHashCreateVar
 #define TclVarHashCreateVar \
   (tclIntStubsPtr->tclVarHashCreateVar) /* 234 */
-#endif
-#ifndef TclInitVarHashTable
 #define TclInitVarHashTable \
   (tclIntStubsPtr->tclInitVarHashTable) /* 235 */
-#endif
-#ifndef TclBackgroundException
-#define TclBackgroundException \
-  (tclIntStubsPtr->tclBackgroundException) /* 236 */
-#endif
-#ifndef TclResetCancellation
+/* Slot 236 is reserved */
 #define TclResetCancellation \
   (tclIntStubsPtr->tclResetCancellation) /* 237 */
-#endif
-#ifndef TclNRInterpProc
 #define TclNRInterpProc \
   (tclIntStubsPtr->tclNRInterpProc) /* 238 */
-#endif
-#ifndef TclNRInterpProcCore
 #define TclNRInterpProcCore \
   (tclIntStubsPtr->tclNRInterpProcCore) /* 239 */
-#endif
-#ifndef TclNRRunCallbacks
 #define TclNRRunCallbacks \
   (tclIntStubsPtr->tclNRRunCallbacks) /* 240 */
-#endif
-#ifndef TclNREvalObjEx
 #define TclNREvalObjEx \
   (tclIntStubsPtr->tclNREvalObjEx) /* 241 */
-#endif
-#ifndef TclNREvalObjv
 #define TclNREvalObjv \
   (tclIntStubsPtr->tclNREvalObjv) /* 242 */
-#endif
+#define TclDbDumpActiveObjects \
+  (tclIntStubsPtr->tclDbDumpActiveObjects) /* 243 */
+#define TclGetNamespaceChildTable \
+  (tclIntStubsPtr->tclGetNamespaceChildTable) /* 244 */
+#define TclGetNamespaceCommandTable \
+  (tclIntStubsPtr->tclGetNamespaceCommandTable) /* 245 */
+#define TclInitRewriteEnsemble \
+  (tclIntStubsPtr->tclInitRewriteEnsemble) /* 246 */
+#define TclResetRewriteEnsemble \
+  (tclIntStubsPtr->tclResetRewriteEnsemble) /* 247 */
+#define TclCopyChannel \
+  (tclIntStubsPtr->tclCopyChannel) /* 248 */
+#define TclDoubleDigits \
+  (tclIntStubsPtr->tclDoubleDigits) /* 249 */
+#define TclSetSlaveCancelFlags \
+  (tclIntStubsPtr->tclSetSlaveCancelFlags) /* 250 */
 
-#endif /* defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS) */
+#endif /* defined(USE_TCL_STUBS) */
 
 /* !END!: Do not edit above this line. */
 
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclIntPlatDecls.h vtk5.10/Utilities/TclTk/internals/tk8.6/tclIntPlatDecls.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclIntPlatDecls.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tclIntPlatDecls.h	2019-02-01 16:20:04.000000000 +0100
@@ -8,13 +8,16 @@
  *
  * Copyright (c) 1998-1999 by Scriptics Corporation.
  * All rights reserved.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TCLINTPLATDECLS
 #define _TCLINTPLATDECLS
 
+#ifdef __WIN32__
+#   define Tcl_DirEntry void
+#   define DIR void
+#endif
+
 #undef TCL_STORAGE_CLASS
 #ifdef BUILD_tcl
 #   define TCL_STORAGE_CLASS DLLEXPORT
@@ -38,668 +41,517 @@
  * Exported function declarations:
  */
 
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-#ifndef TclGetAndDetachPids_TCL_DECLARED
-#define TclGetAndDetachPids_TCL_DECLARED
+#if !defined(__WIN32__) && !defined(__CYGWIN__) && !defined(MAC_OSX_TCL) /* UNIX */
 /* 0 */
-EXTERN void    TclGetAndDetachPids (Tcl_Interp * interp, 
+EXTERN void    TclGetAndDetachPids(Tcl_Interp *interp,
         Tcl_Channel chan);
-#endif
-#ifndef TclpCloseFile_TCL_DECLARED
-#define TclpCloseFile_TCL_DECLARED
 /* 1 */
-EXTERN int    TclpCloseFile (TclFile file);
-#endif
-#ifndef TclpCreateCommandChannel_TCL_DECLARED
-#define TclpCreateCommandChannel_TCL_DECLARED
+EXTERN int    TclpCloseFile(TclFile file);
 /* 2 */
-EXTERN Tcl_Channel  TclpCreateCommandChannel (TclFile readFile, 
-        TclFile writeFile, TclFile errorFile, 
-        int numPids, Tcl_Pid * pidPtr);
-#endif
-#ifndef TclpCreatePipe_TCL_DECLARED
-#define TclpCreatePipe_TCL_DECLARED
+EXTERN Tcl_Channel  TclpCreateCommandChannel(TclFile readFile,
+        TclFile writeFile, TclFile errorFile,
+        int numPids, Tcl_Pid *pidPtr);
 /* 3 */
-EXTERN int    TclpCreatePipe (TclFile * readPipe, 
-        TclFile * writePipe);
-#endif
-#ifndef TclpCreateProcess_TCL_DECLARED
-#define TclpCreateProcess_TCL_DECLARED
+EXTERN int    TclpCreatePipe(TclFile *readPipe, TclFile *writePipe);
 /* 4 */
-EXTERN int    TclpCreateProcess (Tcl_Interp * interp, int argc, 
-        CONST char ** argv, TclFile inputFile, 
-        TclFile outputFile, TclFile errorFile, 
-        Tcl_Pid * pidPtr);
-#endif
+EXTERN int    TclpCreateProcess(Tcl_Interp *interp, int argc,
+        const char **argv, TclFile inputFile,
+        TclFile outputFile, TclFile errorFile,
+        Tcl_Pid *pidPtr);
 /* Slot 5 is reserved */
-#ifndef TclpMakeFile_TCL_DECLARED
-#define TclpMakeFile_TCL_DECLARED
 /* 6 */
-EXTERN TclFile    TclpMakeFile (Tcl_Channel channel, int direction);
-#endif
-#ifndef TclpOpenFile_TCL_DECLARED
-#define TclpOpenFile_TCL_DECLARED
+EXTERN TclFile    TclpMakeFile(Tcl_Channel channel, int direction);
 /* 7 */
-EXTERN TclFile    TclpOpenFile (CONST char * fname, int mode);
-#endif
-#ifndef TclUnixWaitForFile_TCL_DECLARED
-#define TclUnixWaitForFile_TCL_DECLARED
+EXTERN TclFile    TclpOpenFile(const char *fname, int mode);
 /* 8 */
-EXTERN int    TclUnixWaitForFile (int fd, int mask, int timeout);
-#endif
-#ifndef TclpCreateTempFile_TCL_DECLARED
-#define TclpCreateTempFile_TCL_DECLARED
+EXTERN int    TclUnixWaitForFile(int fd, int mask, int timeout);
 /* 9 */
-EXTERN TclFile    TclpCreateTempFile (CONST char * contents);
-#endif
-#ifndef TclpReaddir_TCL_DECLARED
-#define TclpReaddir_TCL_DECLARED
+EXTERN TclFile    TclpCreateTempFile(const char *contents);
 /* 10 */
-EXTERN Tcl_DirEntry *  TclpReaddir (DIR * dir);
-#endif
-#ifndef TclpLocaltime_unix_TCL_DECLARED
-#define TclpLocaltime_unix_TCL_DECLARED
+EXTERN Tcl_DirEntry *  TclpReaddir(DIR *dir);
 /* 11 */
-EXTERN struct tm *  TclpLocaltime_unix (CONST time_t * clock);
-#endif
-#ifndef TclpGmtime_unix_TCL_DECLARED
-#define TclpGmtime_unix_TCL_DECLARED
+EXTERN struct tm *  TclpLocaltime_unix(const time_t *clock);
 /* 12 */
-EXTERN struct tm *  TclpGmtime_unix (CONST time_t * clock);
-#endif
-#ifndef TclpInetNtoa_TCL_DECLARED
-#define TclpInetNtoa_TCL_DECLARED
+EXTERN struct tm *  TclpGmtime_unix(const time_t *clock);
 /* 13 */
-EXTERN char *    TclpInetNtoa (struct in_addr addr);
-#endif
-#ifndef TclUnixCopyFile_TCL_DECLARED
-#define TclUnixCopyFile_TCL_DECLARED
+EXTERN char *    TclpInetNtoa(struct in_addr addr);
 /* 14 */
-EXTERN int    TclUnixCopyFile (CONST char * src, CONST char * dst, 
-        CONST Tcl_StatBuf * statBufPtr, 
+EXTERN int    TclUnixCopyFile(const char *src, const char *dst,
+        const Tcl_StatBuf *statBufPtr,
         int dontCopyAtts);
-#endif
+/* Slot 15 is reserved */
+/* Slot 16 is reserved */
+/* Slot 17 is reserved */
+/* Slot 18 is reserved */
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* Slot 22 is reserved */
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+/* 29 */
+EXTERN int    TclWinCPUID(unsigned int index, unsigned int *regs);
+/* 30 */
+EXTERN int    TclUnixOpenTemporaryFile(Tcl_Obj *dirObj,
+        Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+        Tcl_Obj *resultingNameObj);
 #endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
-#ifndef TclWinConvertError_TCL_DECLARED
-#define TclWinConvertError_TCL_DECLARED
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
 /* 0 */
-EXTERN void    TclWinConvertError (DWORD errCode);
-#endif
-#ifndef TclWinConvertWSAError_TCL_DECLARED
-#define TclWinConvertWSAError_TCL_DECLARED
+EXTERN void    TclWinConvertError(DWORD errCode);
 /* 1 */
-EXTERN void    TclWinConvertWSAError (DWORD errCode);
-#endif
-#ifndef TclWinGetServByName_TCL_DECLARED
-#define TclWinGetServByName_TCL_DECLARED
+EXTERN void    TclWinConvertWSAError(DWORD errCode);
 /* 2 */
-EXTERN struct servent *   TclWinGetServByName (CONST char * nm, 
-        CONST char * proto);
-#endif
-#ifndef TclWinGetSockOpt_TCL_DECLARED
-#define TclWinGetSockOpt_TCL_DECLARED
+EXTERN struct servent *   TclWinGetServByName(const char *nm,
+        const char *proto);
 /* 3 */
-EXTERN int    TclWinGetSockOpt (int s, int level, int optname, 
-        char FAR * optval, int FAR * optlen);
-#endif
-#ifndef TclWinGetTclInstance_TCL_DECLARED
-#define TclWinGetTclInstance_TCL_DECLARED
+EXTERN int    TclWinGetSockOpt(SOCKET s, int level, int optname,
+        char *optval, int *optlen);
 /* 4 */
-EXTERN HINSTANCE  TclWinGetTclInstance (void);
-#endif
-/* Slot 5 is reserved */
-#ifndef TclWinNToHS_TCL_DECLARED
-#define TclWinNToHS_TCL_DECLARED
+EXTERN HINSTANCE  TclWinGetTclInstance(void);
+/* 5 */
+EXTERN int    TclUnixWaitForFile(int fd, int mask, int timeout);
 /* 6 */
-EXTERN u_short    TclWinNToHS (u_short ns);
-#endif
-#ifndef TclWinSetSockOpt_TCL_DECLARED
-#define TclWinSetSockOpt_TCL_DECLARED
+EXTERN unsigned short  TclWinNToHS(unsigned short ns);
 /* 7 */
-EXTERN int    TclWinSetSockOpt (int s, int level, int optname, 
-        CONST char FAR * optval, int optlen);
-#endif
-#ifndef TclpGetPid_TCL_DECLARED
-#define TclpGetPid_TCL_DECLARED
+EXTERN int    TclWinSetSockOpt(SOCKET s, int level, int optname,
+        const char *optval, int optlen);
 /* 8 */
-EXTERN unsigned long  TclpGetPid (Tcl_Pid pid);
-#endif
-#ifndef TclWinGetPlatformId_TCL_DECLARED
-#define TclWinGetPlatformId_TCL_DECLARED
+EXTERN int    TclpGetPid(Tcl_Pid pid);
 /* 9 */
-EXTERN int    TclWinGetPlatformId (void);
-#endif
-/* Slot 10 is reserved */
-#ifndef TclGetAndDetachPids_TCL_DECLARED
-#define TclGetAndDetachPids_TCL_DECLARED
+EXTERN int    TclWinGetPlatformId(void);
+/* 10 */
+EXTERN Tcl_DirEntry *  TclpReaddir(DIR *dir);
 /* 11 */
-EXTERN void    TclGetAndDetachPids (Tcl_Interp * interp, 
+EXTERN void    TclGetAndDetachPids(Tcl_Interp *interp,
         Tcl_Channel chan);
-#endif
-#ifndef TclpCloseFile_TCL_DECLARED
-#define TclpCloseFile_TCL_DECLARED
 /* 12 */
-EXTERN int    TclpCloseFile (TclFile file);
-#endif
-#ifndef TclpCreateCommandChannel_TCL_DECLARED
-#define TclpCreateCommandChannel_TCL_DECLARED
+EXTERN int    TclpCloseFile(TclFile file);
 /* 13 */
-EXTERN Tcl_Channel  TclpCreateCommandChannel (TclFile readFile, 
-        TclFile writeFile, TclFile errorFile, 
-        int numPids, Tcl_Pid * pidPtr);
-#endif
-#ifndef TclpCreatePipe_TCL_DECLARED
-#define TclpCreatePipe_TCL_DECLARED
+EXTERN Tcl_Channel  TclpCreateCommandChannel(TclFile readFile,
+        TclFile writeFile, TclFile errorFile,
+        int numPids, Tcl_Pid *pidPtr);
 /* 14 */
-EXTERN int    TclpCreatePipe (TclFile * readPipe, 
-        TclFile * writePipe);
-#endif
-#ifndef TclpCreateProcess_TCL_DECLARED
-#define TclpCreateProcess_TCL_DECLARED
+EXTERN int    TclpCreatePipe(TclFile *readPipe, TclFile *writePipe);
 /* 15 */
-EXTERN int    TclpCreateProcess (Tcl_Interp * interp, int argc, 
-        CONST char ** argv, TclFile inputFile, 
-        TclFile outputFile, TclFile errorFile, 
-        Tcl_Pid * pidPtr);
-#endif
-/* Slot 16 is reserved */
-/* Slot 17 is reserved */
-#ifndef TclpMakeFile_TCL_DECLARED
-#define TclpMakeFile_TCL_DECLARED
+EXTERN int    TclpCreateProcess(Tcl_Interp *interp, int argc,
+        const char **argv, TclFile inputFile,
+        TclFile outputFile, TclFile errorFile,
+        Tcl_Pid *pidPtr);
+/* 16 */
+EXTERN int    TclpIsAtty(int fd);
+/* 17 */
+EXTERN int    TclUnixCopyFile(const char *src, const char *dst,
+        const Tcl_StatBuf *statBufPtr,
+        int dontCopyAtts);
 /* 18 */
-EXTERN TclFile    TclpMakeFile (Tcl_Channel channel, int direction);
-#endif
-#ifndef TclpOpenFile_TCL_DECLARED
-#define TclpOpenFile_TCL_DECLARED
+EXTERN TclFile    TclpMakeFile(Tcl_Channel channel, int direction);
 /* 19 */
-EXTERN TclFile    TclpOpenFile (CONST char * fname, int mode);
-#endif
-#ifndef TclWinAddProcess_TCL_DECLARED
-#define TclWinAddProcess_TCL_DECLARED
+EXTERN TclFile    TclpOpenFile(const char *fname, int mode);
 /* 20 */
-EXTERN void    TclWinAddProcess (HANDLE hProcess, DWORD id);
-#endif
-/* Slot 21 is reserved */
-#ifndef TclpCreateTempFile_TCL_DECLARED
-#define TclpCreateTempFile_TCL_DECLARED
+EXTERN void    TclWinAddProcess(HANDLE hProcess, DWORD id);
+/* 21 */
+EXTERN char *    TclpInetNtoa(struct in_addr addr);
 /* 22 */
-EXTERN TclFile    TclpCreateTempFile (CONST char * contents);
-#endif
-#ifndef TclpGetTZName_TCL_DECLARED
-#define TclpGetTZName_TCL_DECLARED
-/* 23 */
-EXTERN char *    TclpGetTZName (int isdst);
-#endif
-#ifndef TclWinNoBackslash_TCL_DECLARED
-#define TclWinNoBackslash_TCL_DECLARED
+EXTERN TclFile    TclpCreateTempFile(const char *contents);
+/* Slot 23 is reserved */
 /* 24 */
-EXTERN char *    TclWinNoBackslash (char * path);
-#endif
+EXTERN char *    TclWinNoBackslash(char *path);
 /* Slot 25 is reserved */
-#ifndef TclWinSetInterfaces_TCL_DECLARED
-#define TclWinSetInterfaces_TCL_DECLARED
 /* 26 */
-EXTERN void    TclWinSetInterfaces (int wide);
-#endif
-#ifndef TclWinFlushDirtyChannels_TCL_DECLARED
-#define TclWinFlushDirtyChannels_TCL_DECLARED
+EXTERN void    TclWinSetInterfaces(int wide);
 /* 27 */
-EXTERN void    TclWinFlushDirtyChannels (void);
-#endif
-#ifndef TclWinResetInterfaces_TCL_DECLARED
-#define TclWinResetInterfaces_TCL_DECLARED
+EXTERN void    TclWinFlushDirtyChannels(void);
 /* 28 */
-EXTERN void    TclWinResetInterfaces (void);
-#endif
-#ifndef TclWinCPUID_TCL_DECLARED
-#define TclWinCPUID_TCL_DECLARED
+EXTERN void    TclWinResetInterfaces(void);
 /* 29 */
-EXTERN int    TclWinCPUID (unsigned int index, unsigned int * regs);
-#endif
+EXTERN int    TclWinCPUID(unsigned int index, unsigned int *regs);
+/* 30 */
+EXTERN int    TclUnixOpenTemporaryFile(Tcl_Obj *dirObj,
+        Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+        Tcl_Obj *resultingNameObj);
 #endif /* WIN */
 #ifdef MAC_OSX_TCL /* MACOSX */
-#ifndef TclGetAndDetachPids_TCL_DECLARED
-#define TclGetAndDetachPids_TCL_DECLARED
 /* 0 */
-EXTERN void    TclGetAndDetachPids (Tcl_Interp * interp, 
+EXTERN void    TclGetAndDetachPids(Tcl_Interp *interp,
         Tcl_Channel chan);
-#endif
-#ifndef TclpCloseFile_TCL_DECLARED
-#define TclpCloseFile_TCL_DECLARED
 /* 1 */
-EXTERN int    TclpCloseFile (TclFile file);
-#endif
-#ifndef TclpCreateCommandChannel_TCL_DECLARED
-#define TclpCreateCommandChannel_TCL_DECLARED
+EXTERN int    TclpCloseFile(TclFile file);
 /* 2 */
-EXTERN Tcl_Channel  TclpCreateCommandChannel (TclFile readFile, 
-        TclFile writeFile, TclFile errorFile, 
-        int numPids, Tcl_Pid * pidPtr);
-#endif
-#ifndef TclpCreatePipe_TCL_DECLARED
-#define TclpCreatePipe_TCL_DECLARED
+EXTERN Tcl_Channel  TclpCreateCommandChannel(TclFile readFile,
+        TclFile writeFile, TclFile errorFile,
+        int numPids, Tcl_Pid *pidPtr);
 /* 3 */
-EXTERN int    TclpCreatePipe (TclFile * readPipe, 
-        TclFile * writePipe);
-#endif
-#ifndef TclpCreateProcess_TCL_DECLARED
-#define TclpCreateProcess_TCL_DECLARED
+EXTERN int    TclpCreatePipe(TclFile *readPipe, TclFile *writePipe);
 /* 4 */
-EXTERN int    TclpCreateProcess (Tcl_Interp * interp, int argc, 
-        CONST char ** argv, TclFile inputFile, 
-        TclFile outputFile, TclFile errorFile, 
-        Tcl_Pid * pidPtr);
-#endif
+EXTERN int    TclpCreateProcess(Tcl_Interp *interp, int argc,
+        const char **argv, TclFile inputFile,
+        TclFile outputFile, TclFile errorFile,
+        Tcl_Pid *pidPtr);
 /* Slot 5 is reserved */
-#ifndef TclpMakeFile_TCL_DECLARED
-#define TclpMakeFile_TCL_DECLARED
 /* 6 */
-EXTERN TclFile    TclpMakeFile (Tcl_Channel channel, int direction);
-#endif
-#ifndef TclpOpenFile_TCL_DECLARED
-#define TclpOpenFile_TCL_DECLARED
+EXTERN TclFile    TclpMakeFile(Tcl_Channel channel, int direction);
 /* 7 */
-EXTERN TclFile    TclpOpenFile (CONST char * fname, int mode);
-#endif
-#ifndef TclUnixWaitForFile_TCL_DECLARED
-#define TclUnixWaitForFile_TCL_DECLARED
+EXTERN TclFile    TclpOpenFile(const char *fname, int mode);
 /* 8 */
-EXTERN int    TclUnixWaitForFile (int fd, int mask, int timeout);
-#endif
-#ifndef TclpCreateTempFile_TCL_DECLARED
-#define TclpCreateTempFile_TCL_DECLARED
+EXTERN int    TclUnixWaitForFile(int fd, int mask, int timeout);
 /* 9 */
-EXTERN TclFile    TclpCreateTempFile (CONST char * contents);
-#endif
-#ifndef TclpReaddir_TCL_DECLARED
-#define TclpReaddir_TCL_DECLARED
+EXTERN TclFile    TclpCreateTempFile(const char *contents);
 /* 10 */
-EXTERN Tcl_DirEntry *  TclpReaddir (DIR * dir);
-#endif
-#ifndef TclpLocaltime_unix_TCL_DECLARED
-#define TclpLocaltime_unix_TCL_DECLARED
+EXTERN Tcl_DirEntry *  TclpReaddir(DIR *dir);
 /* 11 */
-EXTERN struct tm *  TclpLocaltime_unix (CONST time_t * clock);
-#endif
-#ifndef TclpGmtime_unix_TCL_DECLARED
-#define TclpGmtime_unix_TCL_DECLARED
+EXTERN struct tm *  TclpLocaltime_unix(const time_t *clock);
 /* 12 */
-EXTERN struct tm *  TclpGmtime_unix (CONST time_t * clock);
-#endif
-#ifndef TclpInetNtoa_TCL_DECLARED
-#define TclpInetNtoa_TCL_DECLARED
+EXTERN struct tm *  TclpGmtime_unix(const time_t *clock);
 /* 13 */
-EXTERN char *    TclpInetNtoa (struct in_addr addr);
-#endif
-#ifndef TclUnixCopyFile_TCL_DECLARED
-#define TclUnixCopyFile_TCL_DECLARED
+EXTERN char *    TclpInetNtoa(struct in_addr addr);
 /* 14 */
-EXTERN int    TclUnixCopyFile (CONST char * src, CONST char * dst, 
-        CONST Tcl_StatBuf * statBufPtr, 
+EXTERN int    TclUnixCopyFile(const char *src, const char *dst,
+        const Tcl_StatBuf *statBufPtr,
         int dontCopyAtts);
-#endif
-#ifndef TclMacOSXGetFileAttribute_TCL_DECLARED
-#define TclMacOSXGetFileAttribute_TCL_DECLARED
 /* 15 */
-EXTERN int    TclMacOSXGetFileAttribute (Tcl_Interp * interp, 
-        int objIndex, Tcl_Obj * fileName, 
-        Tcl_Obj ** attributePtrPtr);
-#endif
-#ifndef TclMacOSXSetFileAttribute_TCL_DECLARED
-#define TclMacOSXSetFileAttribute_TCL_DECLARED
+EXTERN int    TclMacOSXGetFileAttribute(Tcl_Interp *interp,
+        int objIndex, Tcl_Obj *fileName,
+        Tcl_Obj **attributePtrPtr);
 /* 16 */
-EXTERN int    TclMacOSXSetFileAttribute (Tcl_Interp * interp, 
-        int objIndex, Tcl_Obj * fileName, 
-        Tcl_Obj * attributePtr);
-#endif
-#ifndef TclMacOSXCopyFileAttributes_TCL_DECLARED
-#define TclMacOSXCopyFileAttributes_TCL_DECLARED
+EXTERN int    TclMacOSXSetFileAttribute(Tcl_Interp *interp,
+        int objIndex, Tcl_Obj *fileName,
+        Tcl_Obj *attributePtr);
 /* 17 */
-EXTERN int    TclMacOSXCopyFileAttributes (CONST char * src, 
-        CONST char * dst, 
-        CONST Tcl_StatBuf * statBufPtr);
-#endif
-#ifndef TclMacOSXMatchType_TCL_DECLARED
-#define TclMacOSXMatchType_TCL_DECLARED
+EXTERN int    TclMacOSXCopyFileAttributes(const char *src,
+        const char *dst,
+        const Tcl_StatBuf *statBufPtr);
 /* 18 */
-EXTERN int    TclMacOSXMatchType (Tcl_Interp * interp, 
-        CONST char * pathName, CONST char * fileName, 
-        Tcl_StatBuf * statBufPtr, 
-        Tcl_GlobTypeData * types);
-#endif
+EXTERN int    TclMacOSXMatchType(Tcl_Interp *interp,
+        const char *pathName, const char *fileName,
+        Tcl_StatBuf *statBufPtr,
+        Tcl_GlobTypeData *types);
+/* 19 */
+EXTERN void    TclMacOSXNotifierAddRunLoopMode(
+        const void *runLoopMode);
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* Slot 22 is reserved */
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+/* 29 */
+EXTERN int    TclWinCPUID(unsigned int index, unsigned int *regs);
+/* 30 */
+EXTERN int    TclUnixOpenTemporaryFile(Tcl_Obj *dirObj,
+        Tcl_Obj *basenameObj, Tcl_Obj *extensionObj,
+        Tcl_Obj *resultingNameObj);
 #endif /* MACOSX */
 
 typedef struct TclIntPlatStubs {
     int magic;
-    CONST struct TclIntPlatStubHooks *hooks;
+    void *hooks;
 
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-    void (*tclGetAndDetachPids) (Tcl_Interp * interp, Tcl_Channel chan); /* 0 */
+#if !defined(__WIN32__) && !defined(__CYGWIN__) && !defined(MAC_OSX_TCL) /* UNIX */
+    void (*tclGetAndDetachPids) (Tcl_Interp *interp, Tcl_Channel chan); /* 0 */
     int (*tclpCloseFile) (TclFile file); /* 1 */
-    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid * pidPtr); /* 2 */
-    int (*tclpCreatePipe) (TclFile * readPipe, TclFile * writePipe); /* 3 */
-    int (*tclpCreateProcess) (Tcl_Interp * interp, int argc, CONST char ** argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid * pidPtr); /* 4 */
-    void *reserved5;
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid *pidPtr); /* 2 */
+    int (*tclpCreatePipe) (TclFile *readPipe, TclFile *writePipe); /* 3 */
+    int (*tclpCreateProcess) (Tcl_Interp *interp, int argc, const char **argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid *pidPtr); /* 4 */
+    void (*reserved5)(void);
     TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 6 */
-    TclFile (*tclpOpenFile) (CONST char * fname, int mode); /* 7 */
+    TclFile (*tclpOpenFile) (const char *fname, int mode); /* 7 */
     int (*tclUnixWaitForFile) (int fd, int mask, int timeout); /* 8 */
-    TclFile (*tclpCreateTempFile) (CONST char * contents); /* 9 */
-    Tcl_DirEntry * (*tclpReaddir) (DIR * dir); /* 10 */
-    struct tm * (*tclpLocaltime_unix) (CONST time_t * clock); /* 11 */
-    struct tm * (*tclpGmtime_unix) (CONST time_t * clock); /* 12 */
+    TclFile (*tclpCreateTempFile) (const char *contents); /* 9 */
+    Tcl_DirEntry * (*tclpReaddir) (DIR *dir); /* 10 */
+    struct tm * (*tclpLocaltime_unix) (const time_t *clock); /* 11 */
+    struct tm * (*tclpGmtime_unix) (const time_t *clock); /* 12 */
     char * (*tclpInetNtoa) (struct in_addr addr); /* 13 */
-    int (*tclUnixCopyFile) (CONST char * src, CONST char * dst, CONST Tcl_StatBuf * statBufPtr, int dontCopyAtts); /* 14 */
+    int (*tclUnixCopyFile) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr, int dontCopyAtts); /* 14 */
+    void (*reserved15)(void);
+    void (*reserved16)(void);
+    void (*reserved17)(void);
+    void (*reserved18)(void);
+    void (*reserved19)(void);
+    void (*reserved20)(void);
+    void (*reserved21)(void);
+    void (*reserved22)(void);
+    void (*reserved23)(void);
+    void (*reserved24)(void);
+    void (*reserved25)(void);
+    void (*reserved26)(void);
+    void (*reserved27)(void);
+    void (*reserved28)(void);
+    int (*tclWinCPUID) (unsigned int index, unsigned int *regs); /* 29 */
+    int (*tclUnixOpenTemporaryFile) (Tcl_Obj *dirObj, Tcl_Obj *basenameObj, Tcl_Obj *extensionObj, Tcl_Obj *resultingNameObj); /* 30 */
 #endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
     void (*tclWinConvertError) (DWORD errCode); /* 0 */
     void (*tclWinConvertWSAError) (DWORD errCode); /* 1 */
-    struct servent * (*tclWinGetServByName) (CONST char * nm, CONST char * proto); /* 2 */
-    int (*tclWinGetSockOpt) (int s, int level, int optname, char FAR * optval, int FAR * optlen); /* 3 */
+    struct servent * (*tclWinGetServByName) (const char *nm, const char *proto); /* 2 */
+    int (*tclWinGetSockOpt) (SOCKET s, int level, int optname, char *optval, int *optlen); /* 3 */
     HINSTANCE (*tclWinGetTclInstance) (void); /* 4 */
-    void *reserved5;
-    u_short (*tclWinNToHS) (u_short ns); /* 6 */
-    int (*tclWinSetSockOpt) (int s, int level, int optname, CONST char FAR * optval, int optlen); /* 7 */
-    unsigned long (*tclpGetPid) (Tcl_Pid pid); /* 8 */
+    int (*tclUnixWaitForFile) (int fd, int mask, int timeout); /* 5 */
+    unsigned short (*tclWinNToHS) (unsigned short ns); /* 6 */
+    int (*tclWinSetSockOpt) (SOCKET s, int level, int optname, const char *optval, int optlen); /* 7 */
+    int (*tclpGetPid) (Tcl_Pid pid); /* 8 */
     int (*tclWinGetPlatformId) (void); /* 9 */
-    void *reserved10;
-    void (*tclGetAndDetachPids) (Tcl_Interp * interp, Tcl_Channel chan); /* 11 */
+    Tcl_DirEntry * (*tclpReaddir) (DIR *dir); /* 10 */
+    void (*tclGetAndDetachPids) (Tcl_Interp *interp, Tcl_Channel chan); /* 11 */
     int (*tclpCloseFile) (TclFile file); /* 12 */
-    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid * pidPtr); /* 13 */
-    int (*tclpCreatePipe) (TclFile * readPipe, TclFile * writePipe); /* 14 */
-    int (*tclpCreateProcess) (Tcl_Interp * interp, int argc, CONST char ** argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid * pidPtr); /* 15 */
-    void *reserved16;
-    void *reserved17;
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid *pidPtr); /* 13 */
+    int (*tclpCreatePipe) (TclFile *readPipe, TclFile *writePipe); /* 14 */
+    int (*tclpCreateProcess) (Tcl_Interp *interp, int argc, const char **argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid *pidPtr); /* 15 */
+    int (*tclpIsAtty) (int fd); /* 16 */
+    int (*tclUnixCopyFile) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr, int dontCopyAtts); /* 17 */
     TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 18 */
-    TclFile (*tclpOpenFile) (CONST char * fname, int mode); /* 19 */
+    TclFile (*tclpOpenFile) (const char *fname, int mode); /* 19 */
     void (*tclWinAddProcess) (HANDLE hProcess, DWORD id); /* 20 */
-    void *reserved21;
-    TclFile (*tclpCreateTempFile) (CONST char * contents); /* 22 */
-    char * (*tclpGetTZName) (int isdst); /* 23 */
-    char * (*tclWinNoBackslash) (char * path); /* 24 */
-    void *reserved25;
+    char * (*tclpInetNtoa) (struct in_addr addr); /* 21 */
+    TclFile (*tclpCreateTempFile) (const char *contents); /* 22 */
+    void (*reserved23)(void);
+    char * (*tclWinNoBackslash) (char *path); /* 24 */
+    void (*reserved25)(void);
     void (*tclWinSetInterfaces) (int wide); /* 26 */
     void (*tclWinFlushDirtyChannels) (void); /* 27 */
     void (*tclWinResetInterfaces) (void); /* 28 */
-    int (*tclWinCPUID) (unsigned int index, unsigned int * regs); /* 29 */
+    int (*tclWinCPUID) (unsigned int index, unsigned int *regs); /* 29 */
+    int (*tclUnixOpenTemporaryFile) (Tcl_Obj *dirObj, Tcl_Obj *basenameObj, Tcl_Obj *extensionObj, Tcl_Obj *resultingNameObj); /* 30 */
 #endif /* WIN */
 #ifdef MAC_OSX_TCL /* MACOSX */
-    void (*tclGetAndDetachPids) (Tcl_Interp * interp, Tcl_Channel chan); /* 0 */
+    void (*tclGetAndDetachPids) (Tcl_Interp *interp, Tcl_Channel chan); /* 0 */
     int (*tclpCloseFile) (TclFile file); /* 1 */
-    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid * pidPtr); /* 2 */
-    int (*tclpCreatePipe) (TclFile * readPipe, TclFile * writePipe); /* 3 */
-    int (*tclpCreateProcess) (Tcl_Interp * interp, int argc, CONST char ** argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid * pidPtr); /* 4 */
-    void *reserved5;
+    Tcl_Channel (*tclpCreateCommandChannel) (TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid *pidPtr); /* 2 */
+    int (*tclpCreatePipe) (TclFile *readPipe, TclFile *writePipe); /* 3 */
+    int (*tclpCreateProcess) (Tcl_Interp *interp, int argc, const char **argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid *pidPtr); /* 4 */
+    void (*reserved5)(void);
     TclFile (*tclpMakeFile) (Tcl_Channel channel, int direction); /* 6 */
-    TclFile (*tclpOpenFile) (CONST char * fname, int mode); /* 7 */
+    TclFile (*tclpOpenFile) (const char *fname, int mode); /* 7 */
     int (*tclUnixWaitForFile) (int fd, int mask, int timeout); /* 8 */
-    TclFile (*tclpCreateTempFile) (CONST char * contents); /* 9 */
-    Tcl_DirEntry * (*tclpReaddir) (DIR * dir); /* 10 */
-    struct tm * (*tclpLocaltime_unix) (CONST time_t * clock); /* 11 */
-    struct tm * (*tclpGmtime_unix) (CONST time_t * clock); /* 12 */
+    TclFile (*tclpCreateTempFile) (const char *contents); /* 9 */
+    Tcl_DirEntry * (*tclpReaddir) (DIR *dir); /* 10 */
+    struct tm * (*tclpLocaltime_unix) (const time_t *clock); /* 11 */
+    struct tm * (*tclpGmtime_unix) (const time_t *clock); /* 12 */
     char * (*tclpInetNtoa) (struct in_addr addr); /* 13 */
-    int (*tclUnixCopyFile) (CONST char * src, CONST char * dst, CONST Tcl_StatBuf * statBufPtr, int dontCopyAtts); /* 14 */
-    int (*tclMacOSXGetFileAttribute) (Tcl_Interp * interp, int objIndex, Tcl_Obj * fileName, Tcl_Obj ** attributePtrPtr); /* 15 */
-    int (*tclMacOSXSetFileAttribute) (Tcl_Interp * interp, int objIndex, Tcl_Obj * fileName, Tcl_Obj * attributePtr); /* 16 */
-    int (*tclMacOSXCopyFileAttributes) (CONST char * src, CONST char * dst, CONST Tcl_StatBuf * statBufPtr); /* 17 */
-    int (*tclMacOSXMatchType) (Tcl_Interp * interp, CONST char * pathName, CONST char * fileName, Tcl_StatBuf * statBufPtr, Tcl_GlobTypeData * types); /* 18 */
+    int (*tclUnixCopyFile) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr, int dontCopyAtts); /* 14 */
+    int (*tclMacOSXGetFileAttribute) (Tcl_Interp *interp, int objIndex, Tcl_Obj *fileName, Tcl_Obj **attributePtrPtr); /* 15 */
+    int (*tclMacOSXSetFileAttribute) (Tcl_Interp *interp, int objIndex, Tcl_Obj *fileName, Tcl_Obj *attributePtr); /* 16 */
+    int (*tclMacOSXCopyFileAttributes) (const char *src, const char *dst, const Tcl_StatBuf *statBufPtr); /* 17 */
+    int (*tclMacOSXMatchType) (Tcl_Interp *interp, const char *pathName, const char *fileName, Tcl_StatBuf *statBufPtr, Tcl_GlobTypeData *types); /* 18 */
+    void (*tclMacOSXNotifierAddRunLoopMode) (const void *runLoopMode); /* 19 */
+    void (*reserved20)(void);
+    void (*reserved21)(void);
+    void (*reserved22)(void);
+    void (*reserved23)(void);
+    void (*reserved24)(void);
+    void (*reserved25)(void);
+    void (*reserved26)(void);
+    void (*reserved27)(void);
+    void (*reserved28)(void);
+    int (*tclWinCPUID) (unsigned int index, unsigned int *regs); /* 29 */
+    int (*tclUnixOpenTemporaryFile) (Tcl_Obj *dirObj, Tcl_Obj *basenameObj, Tcl_Obj *extensionObj, Tcl_Obj *resultingNameObj); /* 30 */
 #endif /* MACOSX */
 } TclIntPlatStubs;
 
-#if defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS)
-extern CONST TclIntPlatStubs *tclIntPlatStubsPtr;
-#endif /* defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS) */
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern const TclIntPlatStubs *tclIntPlatStubsPtr;
+#ifdef __cplusplus
+}
+#endif
 
-#if defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS)
+#if defined(USE_TCL_STUBS)
 
 /*
  * Inline function declarations:
  */
 
-#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */
-#ifndef TclGetAndDetachPids
+#if !defined(__WIN32__) && !defined(__CYGWIN__) && !defined(MAC_OSX_TCL) /* UNIX */
 #define TclGetAndDetachPids \
   (tclIntPlatStubsPtr->tclGetAndDetachPids) /* 0 */
-#endif
-#ifndef TclpCloseFile
 #define TclpCloseFile \
   (tclIntPlatStubsPtr->tclpCloseFile) /* 1 */
-#endif
-#ifndef TclpCreateCommandChannel
 #define TclpCreateCommandChannel \
   (tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 2 */
-#endif
-#ifndef TclpCreatePipe
 #define TclpCreatePipe \
   (tclIntPlatStubsPtr->tclpCreatePipe) /* 3 */
-#endif
-#ifndef TclpCreateProcess
 #define TclpCreateProcess \
   (tclIntPlatStubsPtr->tclpCreateProcess) /* 4 */
-#endif
 /* Slot 5 is reserved */
-#ifndef TclpMakeFile
 #define TclpMakeFile \
   (tclIntPlatStubsPtr->tclpMakeFile) /* 6 */
-#endif
-#ifndef TclpOpenFile
 #define TclpOpenFile \
   (tclIntPlatStubsPtr->tclpOpenFile) /* 7 */
-#endif
-#ifndef TclUnixWaitForFile
 #define TclUnixWaitForFile \
   (tclIntPlatStubsPtr->tclUnixWaitForFile) /* 8 */
-#endif
-#ifndef TclpCreateTempFile
 #define TclpCreateTempFile \
   (tclIntPlatStubsPtr->tclpCreateTempFile) /* 9 */
-#endif
-#ifndef TclpReaddir
 #define TclpReaddir \
   (tclIntPlatStubsPtr->tclpReaddir) /* 10 */
-#endif
-#ifndef TclpLocaltime_unix
 #define TclpLocaltime_unix \
   (tclIntPlatStubsPtr->tclpLocaltime_unix) /* 11 */
-#endif
-#ifndef TclpGmtime_unix
 #define TclpGmtime_unix \
   (tclIntPlatStubsPtr->tclpGmtime_unix) /* 12 */
-#endif
-#ifndef TclpInetNtoa
 #define TclpInetNtoa \
   (tclIntPlatStubsPtr->tclpInetNtoa) /* 13 */
-#endif
-#ifndef TclUnixCopyFile
 #define TclUnixCopyFile \
   (tclIntPlatStubsPtr->tclUnixCopyFile) /* 14 */
-#endif
+/* Slot 15 is reserved */
+/* Slot 16 is reserved */
+/* Slot 17 is reserved */
+/* Slot 18 is reserved */
+/* Slot 19 is reserved */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* Slot 22 is reserved */
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+#define TclWinCPUID \
+  (tclIntPlatStubsPtr->tclWinCPUID) /* 29 */
+#define TclUnixOpenTemporaryFile \
+  (tclIntPlatStubsPtr->tclUnixOpenTemporaryFile) /* 30 */
 #endif /* UNIX */
-#ifdef __WIN32__ /* WIN */
-#ifndef TclWinConvertError
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
 #define TclWinConvertError \
   (tclIntPlatStubsPtr->tclWinConvertError) /* 0 */
-#endif
-#ifndef TclWinConvertWSAError
 #define TclWinConvertWSAError \
   (tclIntPlatStubsPtr->tclWinConvertWSAError) /* 1 */
-#endif
-#ifndef TclWinGetServByName
 #define TclWinGetServByName \
   (tclIntPlatStubsPtr->tclWinGetServByName) /* 2 */
-#endif
-#ifndef TclWinGetSockOpt
 #define TclWinGetSockOpt \
   (tclIntPlatStubsPtr->tclWinGetSockOpt) /* 3 */
-#endif
-#ifndef TclWinGetTclInstance
 #define TclWinGetTclInstance \
   (tclIntPlatStubsPtr->tclWinGetTclInstance) /* 4 */
-#endif
-/* Slot 5 is reserved */
-#ifndef TclWinNToHS
+#define TclUnixWaitForFile \
+  (tclIntPlatStubsPtr->tclUnixWaitForFile) /* 5 */
 #define TclWinNToHS \
   (tclIntPlatStubsPtr->tclWinNToHS) /* 6 */
-#endif
-#ifndef TclWinSetSockOpt
 #define TclWinSetSockOpt \
   (tclIntPlatStubsPtr->tclWinSetSockOpt) /* 7 */
-#endif
-#ifndef TclpGetPid
 #define TclpGetPid \
   (tclIntPlatStubsPtr->tclpGetPid) /* 8 */
-#endif
-#ifndef TclWinGetPlatformId
 #define TclWinGetPlatformId \
   (tclIntPlatStubsPtr->tclWinGetPlatformId) /* 9 */
-#endif
-/* Slot 10 is reserved */
-#ifndef TclGetAndDetachPids
+#define TclpReaddir \
+  (tclIntPlatStubsPtr->tclpReaddir) /* 10 */
 #define TclGetAndDetachPids \
   (tclIntPlatStubsPtr->tclGetAndDetachPids) /* 11 */
-#endif
-#ifndef TclpCloseFile
 #define TclpCloseFile \
   (tclIntPlatStubsPtr->tclpCloseFile) /* 12 */
-#endif
-#ifndef TclpCreateCommandChannel
 #define TclpCreateCommandChannel \
   (tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 13 */
-#endif
-#ifndef TclpCreatePipe
 #define TclpCreatePipe \
   (tclIntPlatStubsPtr->tclpCreatePipe) /* 14 */
-#endif
-#ifndef TclpCreateProcess
 #define TclpCreateProcess \
   (tclIntPlatStubsPtr->tclpCreateProcess) /* 15 */
-#endif
-/* Slot 16 is reserved */
-/* Slot 17 is reserved */
-#ifndef TclpMakeFile
+#define TclpIsAtty \
+  (tclIntPlatStubsPtr->tclpIsAtty) /* 16 */
+#define TclUnixCopyFile \
+  (tclIntPlatStubsPtr->tclUnixCopyFile) /* 17 */
 #define TclpMakeFile \
   (tclIntPlatStubsPtr->tclpMakeFile) /* 18 */
-#endif
-#ifndef TclpOpenFile
 #define TclpOpenFile \
   (tclIntPlatStubsPtr->tclpOpenFile) /* 19 */
-#endif
-#ifndef TclWinAddProcess
 #define TclWinAddProcess \
   (tclIntPlatStubsPtr->tclWinAddProcess) /* 20 */
-#endif
-/* Slot 21 is reserved */
-#ifndef TclpCreateTempFile
+#define TclpInetNtoa \
+  (tclIntPlatStubsPtr->tclpInetNtoa) /* 21 */
 #define TclpCreateTempFile \
   (tclIntPlatStubsPtr->tclpCreateTempFile) /* 22 */
-#endif
-#ifndef TclpGetTZName
-#define TclpGetTZName \
-  (tclIntPlatStubsPtr->tclpGetTZName) /* 23 */
-#endif
-#ifndef TclWinNoBackslash
+/* Slot 23 is reserved */
 #define TclWinNoBackslash \
   (tclIntPlatStubsPtr->tclWinNoBackslash) /* 24 */
-#endif
 /* Slot 25 is reserved */
-#ifndef TclWinSetInterfaces
 #define TclWinSetInterfaces \
   (tclIntPlatStubsPtr->tclWinSetInterfaces) /* 26 */
-#endif
-#ifndef TclWinFlushDirtyChannels
 #define TclWinFlushDirtyChannels \
   (tclIntPlatStubsPtr->tclWinFlushDirtyChannels) /* 27 */
-#endif
-#ifndef TclWinResetInterfaces
 #define TclWinResetInterfaces \
   (tclIntPlatStubsPtr->tclWinResetInterfaces) /* 28 */
-#endif
-#ifndef TclWinCPUID
 #define TclWinCPUID \
   (tclIntPlatStubsPtr->tclWinCPUID) /* 29 */
-#endif
+#define TclUnixOpenTemporaryFile \
+  (tclIntPlatStubsPtr->tclUnixOpenTemporaryFile) /* 30 */
 #endif /* WIN */
 #ifdef MAC_OSX_TCL /* MACOSX */
-#ifndef TclGetAndDetachPids
 #define TclGetAndDetachPids \
   (tclIntPlatStubsPtr->tclGetAndDetachPids) /* 0 */
-#endif
-#ifndef TclpCloseFile
 #define TclpCloseFile \
   (tclIntPlatStubsPtr->tclpCloseFile) /* 1 */
-#endif
-#ifndef TclpCreateCommandChannel
 #define TclpCreateCommandChannel \
   (tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 2 */
-#endif
-#ifndef TclpCreatePipe
 #define TclpCreatePipe \
   (tclIntPlatStubsPtr->tclpCreatePipe) /* 3 */
-#endif
-#ifndef TclpCreateProcess
 #define TclpCreateProcess \
   (tclIntPlatStubsPtr->tclpCreateProcess) /* 4 */
-#endif
 /* Slot 5 is reserved */
-#ifndef TclpMakeFile
 #define TclpMakeFile \
   (tclIntPlatStubsPtr->tclpMakeFile) /* 6 */
-#endif
-#ifndef TclpOpenFile
 #define TclpOpenFile \
   (tclIntPlatStubsPtr->tclpOpenFile) /* 7 */
-#endif
-#ifndef TclUnixWaitForFile
 #define TclUnixWaitForFile \
   (tclIntPlatStubsPtr->tclUnixWaitForFile) /* 8 */
-#endif
-#ifndef TclpCreateTempFile
 #define TclpCreateTempFile \
   (tclIntPlatStubsPtr->tclpCreateTempFile) /* 9 */
-#endif
-#ifndef TclpReaddir
 #define TclpReaddir \
   (tclIntPlatStubsPtr->tclpReaddir) /* 10 */
-#endif
-#ifndef TclpLocaltime_unix
 #define TclpLocaltime_unix \
   (tclIntPlatStubsPtr->tclpLocaltime_unix) /* 11 */
-#endif
-#ifndef TclpGmtime_unix
 #define TclpGmtime_unix \
   (tclIntPlatStubsPtr->tclpGmtime_unix) /* 12 */
-#endif
-#ifndef TclpInetNtoa
 #define TclpInetNtoa \
   (tclIntPlatStubsPtr->tclpInetNtoa) /* 13 */
-#endif
-#ifndef TclUnixCopyFile
 #define TclUnixCopyFile \
   (tclIntPlatStubsPtr->tclUnixCopyFile) /* 14 */
-#endif
-#ifndef TclMacOSXGetFileAttribute
 #define TclMacOSXGetFileAttribute \
   (tclIntPlatStubsPtr->tclMacOSXGetFileAttribute) /* 15 */
-#endif
-#ifndef TclMacOSXSetFileAttribute
 #define TclMacOSXSetFileAttribute \
   (tclIntPlatStubsPtr->tclMacOSXSetFileAttribute) /* 16 */
-#endif
-#ifndef TclMacOSXCopyFileAttributes
 #define TclMacOSXCopyFileAttributes \
   (tclIntPlatStubsPtr->tclMacOSXCopyFileAttributes) /* 17 */
-#endif
-#ifndef TclMacOSXMatchType
 #define TclMacOSXMatchType \
   (tclIntPlatStubsPtr->tclMacOSXMatchType) /* 18 */
-#endif
+#define TclMacOSXNotifierAddRunLoopMode \
+  (tclIntPlatStubsPtr->tclMacOSXNotifierAddRunLoopMode) /* 19 */
+/* Slot 20 is reserved */
+/* Slot 21 is reserved */
+/* Slot 22 is reserved */
+/* Slot 23 is reserved */
+/* Slot 24 is reserved */
+/* Slot 25 is reserved */
+/* Slot 26 is reserved */
+/* Slot 27 is reserved */
+/* Slot 28 is reserved */
+#define TclWinCPUID \
+  (tclIntPlatStubsPtr->tclWinCPUID) /* 29 */
+#define TclUnixOpenTemporaryFile \
+  (tclIntPlatStubsPtr->tclUnixOpenTemporaryFile) /* 30 */
 #endif /* MACOSX */
 
-#endif /* defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS) */
+#endif /* defined(USE_TCL_STUBS) */
 
 /* !END!: Do not edit above this line. */
 
 #undef TCL_STORAGE_CLASS
 #define TCL_STORAGE_CLASS DLLIMPORT
+#undef TclpLocaltime_unix
+#undef TclpGmtime_unix
+#undef TclWinConvertWSAError
+#define TclWinConvertWSAError TclWinConvertError
+
+#if defined(__WIN32__) || defined(__CYGWIN__)
+#   undef TclWinNToHS
+#   define TclWinNToHS ntohs
+#else
+#   undef TclpGetPid
+#   define TclpGetPid(pid) ((unsigned long) (pid))
+#endif
 
 #endif /* _TCLINTPLATDECLS */
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclPort.h vtk5.10/Utilities/TclTk/internals/tk8.6/tclPort.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclPort.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tclPort.h	2019-02-01 16:20:04.000000000 +0100
@@ -9,8 +9,6 @@
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TCLPORT
@@ -19,13 +17,11 @@
 #ifdef HAVE_TCL_CONFIG_H
 #include "tclConfig.h"
 #endif
-#include "tcl.h"
-
-#if defined(__WIN32__)
-/* PATCHED */
-/* #   include "../win/tclWinPort.h" */
+#if defined(_WIN32)
 #   include "tclWinPort.h"
-#else
+#endif
+#include "tcl.h"
+#if !defined(_WIN32)
 #   include "tclUnixPort.h"
 #endif
 
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclUnixPort.h vtk5.10/Utilities/TclTk/internals/tk8.6/tclUnixPort.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclUnixPort.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tclUnixPort.h	2019-02-01 16:20:04.000000000 +0100
@@ -1,32 +1,29 @@
 /*
  * tclUnixPort.h --
  *
- *  This header file handles porting issues that occur because
- *  of differences between systems.  It reads in UNIX-related
- *  header files and sets up UNIX-related macros for Tcl's UNIX
- *  core.  It should be the only file that contains #ifdefs to
- *  handle different flavors of UNIX.  This file sets up the
- *  union of all UNIX-related things needed by any of the Tcl
- *  core files.  This file depends on configuration #defines such
- *  as NO_DIRENT_H that are set up by the "configure" script.
+ *  This header file handles porting issues that occur because of
+ *  differences between systems. It reads in UNIX-related header files and
+ *  sets up UNIX-related macros for Tcl's UNIX core. It should be the only
+ *  file that contains #ifdefs to handle different flavors of UNIX. This
+ *  file sets up the union of all UNIX-related things needed by any of the
+ *  Tcl core files. This file depends on configuration #defines such as
+ *  NO_DIRENT_H that are set up by the "configure" script.
  *
- *  Much of the material in this file was originally contributed
- *  by Karl Lehenbauer, Mark Diekhans and Peter da Silva.
+ *  Much of the material in this file was originally contributed by Karl
+ *  Lehenbauer, Mark Diekhans and Peter da Silva.
  *
  * Copyright (c) 1991-1994 The Regents of the University of California.
  * Copyright (c) 1994-1997 Sun Microsystems, Inc.
  *
- * See the file "license.terms" for information on usage and redistribution
- * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
+ * See the file "license.terms" for information on usage and redistribution of
+ * this file, and for a DISCLAIMER OF ALL WARRANTIES.
  */
 
 #ifndef _TCLUNIXPORT
 #define _TCLUNIXPORT
 
 #ifndef MODULE_SCOPE
-#define MODULE_SCOPE extern
+#define MODULE_SCOPE  extern
 #endif
 
 /*
@@ -57,6 +54,12 @@
 #endif
 #endif
 
+/*
+ *---------------------------------------------------------------------------
+ * Parameterize for 64-bit filesystem support.
+ *---------------------------------------------------------------------------
+ */
+
 #ifdef HAVE_STRUCT_DIRENT64
 typedef struct dirent64  Tcl_DirEntry;
 #   define TclOSreaddir    readdir64
@@ -75,7 +78,37 @@
 #   define TclOSopen    open
 #endif
 
-#ifdef HAVE_STRUCT_STAT64
+#ifdef __CYGWIN__
+
+    /* Make some symbols available without including <windows.h> */
+#   define DWORD unsigned int
+#   define CP_UTF8 65001
+#   define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS 0x00000004
+#   define HANDLE void *
+#   define HINSTANCE void *
+#   define SOCKET unsigned int
+#   define WSAEWOULDBLOCK 10035
+    typedef unsigned short WCHAR;
+    DLLIMPORT extern __stdcall int GetModuleHandleExW(unsigned int, const char *, void *);
+    DLLIMPORT extern __stdcall int GetModuleFileNameW(void *, const char *, int);
+    DLLIMPORT extern __stdcall int WideCharToMultiByte(int, int, const char *, int,
+      const char *, int, const char *, const char *);
+    DLLIMPORT extern __stdcall int MultiByteToWideChar(int, int, const char *, int,
+      WCHAR *, int);
+    DLLIMPORT extern __stdcall void OutputDebugStringW(const WCHAR *);
+    DLLIMPORT extern __stdcall int IsDebuggerPresent();
+
+    DLLIMPORT extern int cygwin_conv_path(int, const void *, void *, int);
+    DLLIMPORT extern int cygwin_conv_path_list(int, const void *, void *, int);
+#   define USE_PUTENV 1
+#   define USE_PUTENV_FOR_UNSET 1
+/* On Cygwin, the environment is imported from the Cygwin DLL. */
+#   define environ __cygwin_environ
+#   define timezone _timezone
+    DLLIMPORT extern char **__cygwin_environ;
+    MODULE_SCOPE int TclOSstat(const char *name, Tcl_StatBuf *statBuf);
+    MODULE_SCOPE int TclOSlstat(const char *name, Tcl_StatBuf *statBuf);
+#elif defined(HAVE_STRUCT_STAT64)
 #   define TclOSstat    stat64
 #   define TclOSlstat    lstat64
 #else
@@ -83,11 +116,19 @@
 #   define TclOSlstat    lstat
 #endif
 
+/*
+ *---------------------------------------------------------------------------
+ * Miscellaneous includes that might be missing.
+ *---------------------------------------------------------------------------
+ */
+
 #include <sys/file.h>
 #ifdef HAVE_SYS_SELECT_H
 #   include <sys/select.h>
 #endif
-#include <sys/stat.h>
+#ifdef HAVE_SYS_STAT_H
+#   include <sys/stat.h>
+#endif
 #if TIME_WITH_SYS_TIME
 #   include <sys/time.h>
 #   include <time.h>
@@ -104,6 +145,11 @@
 #if HAVE_INTTYPES_H
 #   include <inttypes.h>
 #endif
+#ifdef NO_LIMITS_H
+#   include "../compat/limits.h"
+#else
+#   include <limits.h>
+#endif
 #if HAVE_STDINT_H
 #   include <stdint.h>
 #endif
@@ -113,26 +159,34 @@
 #   include "../compat/unistd.h"
 #endif
 
-MODULE_SCOPE int TclUnixSetBlockingMode(int fd, int mode);
+MODULE_SCOPE int  TclUnixSetBlockingMode(int fd, int mode);
 
 #include <utime.h>
 
 /*
- * Socket support stuff: This likely needs more work to parameterize for
- * each system.
+ *---------------------------------------------------------------------------
+ * Socket support stuff: This likely needs more work to parameterize for each
+ * system.
+ *---------------------------------------------------------------------------
  */
+
 #include <sys/socket.h>    /* struct sockaddr, SOCK_STREAM, ... */
 #ifndef NO_UNAME
 #   include <sys/utsname.h>  /* uname system call. */
 #endif
 #include <netinet/in.h>    /* struct in_addr, struct sockaddr_in */
 #include <arpa/inet.h>    /* inet_ntoa() */
-#include <netdb.h>    /* gethostbyname() */
+#include <netdb.h>    /* getaddrinfo() */
+#ifdef NEED_FAKE_RFC2553
+# include "../compat/fake-rfc2553.h"
+#endif
 
 /*
- * Some platforms (e.g. SunOS) don't define FLT_MAX and FLT_MIN, so we
- * look for an alternative definition.  If no other alternative is available
- * we use a reasonable guess.
+ *---------------------------------------------------------------------------
+ * Some platforms (e.g. SunOS) don't define FLT_MAX and FLT_MIN, so we look
+ * for an alternative definition. If no other alternative is available we use
+ * a reasonable guess.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef NO_FLOAT_H
@@ -145,21 +199,23 @@
 
 #ifndef FLT_MAX
 #   ifdef MAXFLOAT
-#  define FLT_MAX MAXFLOAT
+#  define FLT_MAX  MAXFLOAT
 #   else
-#  define FLT_MAX 3.402823466E+38F
+#  define FLT_MAX  3.402823466E+38F
 #   endif
 #endif
 #ifndef FLT_MIN
 #   ifdef MINFLOAT
-#  define FLT_MIN MINFLOAT
+#  define FLT_MIN  MINFLOAT
 #   else
-#  define FLT_MIN 1.175494351E-38F
+#  define FLT_MIN  1.175494351E-38F
 #   endif
 #endif
 
 /*
+ *---------------------------------------------------------------------------
  * NeXT doesn't define O_NONBLOCK, so #define it here if necessary.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef O_NONBLOCK
@@ -167,23 +223,27 @@
 #endif
 
 /*
- * The type of the status returned by wait varies from UNIX system
- * to UNIX system.  The macro below defines it:
+ *---------------------------------------------------------------------------
+ * The type of the status returned by wait varies from UNIX system to UNIX
+ * system. The macro below defines it:
+ *---------------------------------------------------------------------------
  */
 
 #ifdef _AIX
-#   define WAIT_STATUS_TYPE pid_t
+#   define WAIT_STATUS_TYPE  pid_t
 #else
 #ifndef NO_UNION_WAIT
-#   define WAIT_STATUS_TYPE union wait
+#   define WAIT_STATUS_TYPE  union wait
 #else
-#   define WAIT_STATUS_TYPE int
+#   define WAIT_STATUS_TYPE  int
 #endif
 #endif
 
 /*
- * Supply definitions for macros to query wait status, if not already
- * defined in header files above.
+ *---------------------------------------------------------------------------
+ * Supply definitions for macros to query wait status, if not already defined
+ * in header files above.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef WIFEXITED
@@ -191,15 +251,17 @@
 #endif
 
 #ifndef WEXITSTATUS
-#   define WEXITSTATUS(stat) (((*((int *) &(stat))) >> 8) & 0xff)
+#   define WEXITSTATUS(stat)  (((*((int *) &(stat))) >> 8) & 0xff)
 #endif
 
 #ifndef WIFSIGNALED
-#   define WIFSIGNALED(stat) (((*((int *) &(stat)))) && ((*((int *) &(stat))) == ((*((int *) &(stat))) & 0x00ff)))
+#   define WIFSIGNALED(stat) \
+  (((*((int *) &(stat)))) && ((*((int *) &(stat))) \
+    == ((*((int *) &(stat))) & 0x00ff)))
 #endif
 
 #ifndef WTERMSIG
-#   define WTERMSIG(stat)    ((*((int *) &(stat))) & 0x7f)
+#   define WTERMSIG(stat)  ((*((int *) &(stat))) & 0x7f)
 #endif
 
 #ifndef WIFSTOPPED
@@ -207,12 +269,14 @@
 #endif
 
 #ifndef WSTOPSIG
-#   define WSTOPSIG(stat)    (((*((int *) &(stat))) >> 8) & 0xff)
+#   define WSTOPSIG(stat)  (((*((int *) &(stat))) >> 8) & 0xff)
 #endif
 
 /*
- * Define constants for waitpid() system call if they aren't defined
- * by a system header file.
+ *---------------------------------------------------------------------------
+ * Define constants for waitpid() system call if they aren't defined by a
+ * system header file.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef WNOHANG
@@ -223,8 +287,10 @@
 #endif
 
 /*
- * Supply macros for seek offsets, if they're not already provided by
- * an include file.
+ *---------------------------------------------------------------------------
+ * Supply macros for seek offsets, if they're not already provided by an
+ * include file.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef SEEK_SET
@@ -238,8 +304,10 @@
 #endif
 
 /*
- * The stuff below is needed by the "time" command.  If this system has no
+ *---------------------------------------------------------------------------
+ * The stuff below is needed by the "time" command. If this system has no
  * gettimeofday call, then must use times() instead.
+ *---------------------------------------------------------------------------
  */
 
 #ifdef NO_GETTOD
@@ -251,38 +319,45 @@
 #endif
 
 #ifdef GETTOD_NOT_DECLARED
-EXTERN int    gettimeofday(struct timeval *tp, struct timezone *tzp);
+MODULE_SCOPE int  gettimeofday(struct timeval *tp,
+          struct timezone *tzp);
 #endif
 
 /*
+ *---------------------------------------------------------------------------
  * Define access mode constants if they aren't already defined.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef F_OK
-#    define F_OK 00
+#   define F_OK    00
 #endif
 #ifndef X_OK
-#    define X_OK 01
+#   define X_OK    01
 #endif
 #ifndef W_OK
-#    define W_OK 02
+#   define W_OK    02
 #endif
 #ifndef R_OK
-#    define R_OK 04
+#   define R_OK    04
 #endif
 
 /*
- * Define FD_CLOEEXEC (the close-on-exec flag bit) if it isn't
- * already defined.
+ *---------------------------------------------------------------------------
+ * Define FD_CLOEEXEC (the close-on-exec flag bit) if it isn't already
+ * defined.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef FD_CLOEXEC
-#   define FD_CLOEXEC 1
+#   define FD_CLOEXEC  1
 #endif
 
 /*
- * On systems without symbolic links (i.e. S_IFLNK isn't defined)
- * define "lstat" to use "stat" instead.
+ *---------------------------------------------------------------------------
+ * On systems without symbolic links (i.e. S_IFLNK isn't defined) define
+ * "lstat" to use "stat" instead.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef S_IFLNK
@@ -293,137 +368,156 @@
 #endif
 
 /*
- * Define macros to query file type bits, if they're not already
- * defined.
+ *---------------------------------------------------------------------------
+ * Define macros to query file type bits, if they're not already defined.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef S_ISREG
 #   ifdef S_IFREG
-#       define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+#  define S_ISREG(m)  (((m) & S_IFMT) == S_IFREG)
 #   else
-#       define S_ISREG(m) 0
+#  define S_ISREG(m)  0
 #   endif
 #endif /* !S_ISREG */
 #ifndef S_ISDIR
 #   ifdef S_IFDIR
-#       define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+#  define S_ISDIR(m)  (((m) & S_IFMT) == S_IFDIR)
 #   else
-#       define S_ISDIR(m) 0
+#  define S_ISDIR(m)  0
 #   endif
 #endif /* !S_ISDIR */
 #ifndef S_ISCHR
 #   ifdef S_IFCHR
-#       define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
+#  define S_ISCHR(m)  (((m) & S_IFMT) == S_IFCHR)
 #   else
-#       define S_ISCHR(m) 0
+#  define S_ISCHR(m)  0
 #   endif
 #endif /* !S_ISCHR */
+
 #ifndef S_ISBLK
 #   ifdef S_IFBLK
-#       define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
+#  define S_ISBLK(m)  (((m) & S_IFMT) == S_IFBLK)
 #   else
-#       define S_ISBLK(m) 0
+#  define S_ISBLK(m)  0
 #   endif
 #endif /* !S_ISBLK */
+
 #ifndef S_ISFIFO
 #   ifdef S_IFIFO
-#       define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
+#  define S_ISFIFO(m)  (((m) & S_IFMT) == S_IFIFO)
 #   else
-#       define S_ISFIFO(m) 0
+#  define S_ISFIFO(m)  0
 #   endif
 #endif /* !S_ISFIFO */
+
 #ifndef S_ISLNK
 #   ifdef S_IFLNK
-#       define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#  define S_ISLNK(m)  (((m) & S_IFMT) == S_IFLNK)
 #   else
-#       define S_ISLNK(m) 0
+#  define S_ISLNK(m)  0
 #   endif
 #endif /* !S_ISLNK */
+
 #ifndef S_ISSOCK
 #   ifdef S_IFSOCK
-#       define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
+#  define S_ISSOCK(m)  (((m) & S_IFMT) == S_IFSOCK)
 #   else
-#       define S_ISSOCK(m) 0
+#  define S_ISSOCK(m)  0
 #   endif
 #endif /* !S_ISSOCK */
 
 /*
+ *---------------------------------------------------------------------------
  * Make sure that MAXPATHLEN and MAXNAMLEN are defined.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef MAXPATHLEN
 #   ifdef PATH_MAX
-#       define MAXPATHLEN PATH_MAX
+#  define MAXPATHLEN  PATH_MAX
 #   else
-#       define MAXPATHLEN 2048
+#  define MAXPATHLEN  2048
 #   endif
 #endif
 
 #ifndef MAXNAMLEN
 #   ifdef NAME_MAX
-#  define MAXNAMLEN NAME_MAX
+#  define MAXNAMLEN  NAME_MAX
 #   else
-#  define MAXNAMLEN 255
+#  define MAXNAMLEN  255
 #   endif
 #endif
 
 /*
+ *---------------------------------------------------------------------------
  * Make sure that L_tmpnam is defined.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef L_tmpnam
-#   define L_tmpnam 100
+#   define L_tmpnam  100
 #endif
 
 /*
- * The following macro defines the type of the mask arguments to
- * select:
+ *---------------------------------------------------------------------------
+ * The following macro defines the type of the mask arguments to select:
+ *---------------------------------------------------------------------------
  */
 
 #ifndef NO_FD_SET
-#   define SELECT_MASK fd_set
+#   define SELECT_MASK  fd_set
 #else /* NO_FD_SET */
 #   ifndef _AIX
-  typedef long fd_mask;
+  typedef long  fd_mask;
 #   endif /* !AIX */
 #   if defined(_IBMR2)
-#  define SELECT_MASK void
+#  define SELECT_MASK  void
 #   else /* !defined(_IBMR2) */
-#  define SELECT_MASK int
+#  define SELECT_MASK  int
 #   endif /* defined(_IBMR2) */
 #endif /* !NO_FD_SET */
 
 /*
+ *---------------------------------------------------------------------------
  * Define "NBBY" (number of bits per byte) if it's not already defined.
+ *---------------------------------------------------------------------------
  */
 
 #ifndef NBBY
-#   define NBBY 8
+#   define NBBY    8
 #endif
 
 /*
+ *---------------------------------------------------------------------------
  * The following macro defines the number of fd_masks in an fd_set:
+ *---------------------------------------------------------------------------
  */
 
 #ifndef FD_SETSIZE
 #   ifdef OPEN_MAX
-#  define FD_SETSIZE OPEN_MAX
+#  define FD_SETSIZE  OPEN_MAX
 #   else
-#  define FD_SETSIZE 256
+#  define FD_SETSIZE  256
 #   endif
 #endif /* FD_SETSIZE */
-#if !defined(howmany)
-#   define howmany(x, y) (((x)+((y)-1))/(y))
+
+#ifndef howmany
+#   define howmany(x, y)  (((x)+((y)-1))/(y))
 #endif /* !defined(howmany) */
+
 #ifndef NFDBITS
-#   define NFDBITS NBBY*sizeof(fd_mask)
+#   define NFDBITS  NBBY*sizeof(fd_mask)
 #endif /* NFDBITS */
-#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)
+
+#define MASK_SIZE  howmany(FD_SETSIZE, NFDBITS)
 
 /*
- * Not all systems declare the errno variable in errno.h. so this
- * file does it explicitly.  The list of system error messages also
- * isn't generally declared in a header file anywhere.
+ *---------------------------------------------------------------------------
+ * Not all systems declare the errno variable in errno.h. so this file does it
+ * explicitly. The list of system error messages also isn't generally declared
+ * in a header file anywhere.
+ *---------------------------------------------------------------------------
  */
 
 #ifdef NO_ERRNO
@@ -431,130 +525,154 @@
 #endif /* NO_ERRNO */
 
 /*
- * Not all systems declare all the errors that Tcl uses!  Provide some
+ *---------------------------------------------------------------------------
+ * Not all systems declare all the errors that Tcl uses! Provide some
  * work-arounds...
+ *---------------------------------------------------------------------------
  */
 
 #ifndef EOVERFLOW
 #   ifdef EFBIG
-#  define EOVERFLOW EFBIG
+#  define EOVERFLOW  EFBIG
 #   else /* !EFBIG */
-#  define EOVERFLOW EINVAL
+#  define EOVERFLOW  EINVAL
 #   endif /* EFBIG */
 #endif /* EOVERFLOW */
 
 /*
+ *---------------------------------------------------------------------------
  * Variables provided by the C library:
+ *---------------------------------------------------------------------------
  */
 
 #if defined(__APPLE__) && defined(__DYNAMIC__)
 #   include <crt_externs.h>
-#   define environ (*_NSGetEnviron())
-#   define USE_PUTENV 1
+#   define environ  (*_NSGetEnviron())
+#   define USE_PUTENV  1
 #else
 #   if defined(_sgi) || defined(__sgi)
-#       define environ _environ
+#  define environ  _environ
 #   endif
-extern char **environ;
+extern char **    environ;
 #endif
 
 /*
- * There is no platform-specific panic routine for Unix in the Tcl internals.
- */
-
-#define TclpPanic ((Tcl_PanicProc *) NULL)
-
-/*
+ *---------------------------------------------------------------------------
  * Darwin specifc configure overrides.
+ *---------------------------------------------------------------------------
  */
 
 #ifdef __APPLE__
+
 /*
+ *---------------------------------------------------------------------------
  * Support for fat compiles: configure runs only once for multiple architectures
+ *---------------------------------------------------------------------------
  */
+
 #   if defined(__LP64__) && defined (NO_COREFOUNDATION_64)
-#       undef HAVE_COREFOUNDATION
-#    endif /* __LP64__ && NO_COREFOUNDATION_64 */
+#  undef HAVE_COREFOUNDATION
+#   endif /* __LP64__ && NO_COREFOUNDATION_64 */
 #   include <sys/cdefs.h>
 #   ifdef __DARWIN_UNIX03
-#       if __DARWIN_UNIX03
-#           undef HAVE_PUTENV_THAT_COPIES
-#       else
-#           define HAVE_PUTENV_THAT_COPIES 1
-#       endif
+#  if __DARWIN_UNIX03
+#      undef HAVE_PUTENV_THAT_COPIES
+#  else
+#      define HAVE_PUTENV_THAT_COPIES  1
+#  endif
 #   endif /* __DARWIN_UNIX03 */
+
 /*
+ *---------------------------------------------------------------------------
  * The termios configure test program relies on the configure script being run
- * from a terminal, which is not the case e.g. when configuring from Xcode.
+ * from a terminal, which is not the case e.g., when configuring from Xcode.
  * Since termios is known to be present on all Mac OS X releases since 10.0,
  * override the configure defines for serial API here. [Bug 497147]
+ *---------------------------------------------------------------------------
  */
+
 #   define USE_TERMIOS 1
-#   undef  USE_TERMIO
-#   undef  USE_SGTTY
+#   undef USE_TERMIO
+#   undef USE_SGTTY
+
 /*
+ *---------------------------------------------------------------------------
  * Include AvailabilityMacros.h here (when available) to ensure any symbolic
  * MAC_OS_X_VERSION_* constants passed on the command line are translated.
+ *---------------------------------------------------------------------------
  */
+
 #   ifdef HAVE_AVAILABILITYMACROS_H
-#       include <AvailabilityMacros.h>
+#  include <AvailabilityMacros.h>
 #   endif
+
 /*
+ *---------------------------------------------------------------------------
  * Support for weak import.
+ *---------------------------------------------------------------------------
  */
+
 #   ifdef HAVE_WEAK_IMPORT
-#       if !defined(HAVE_AVAILABILITYMACROS_H) || !defined(MAC_OS_X_VERSION_MIN_REQUIRED)
-#           undef HAVE_WEAK_IMPORT
-#       else
-#           ifndef WEAK_IMPORT_ATTRIBUTE
-#               define WEAK_IMPORT_ATTRIBUTE __attribute__((weak_import))
-#           endif
-#       endif
+#  if !defined(HAVE_AVAILABILITYMACROS_H) || !defined(MAC_OS_X_VERSION_MIN_REQUIRED)
+#      undef HAVE_WEAK_IMPORT
+#  else
+#      ifndef WEAK_IMPORT_ATTRIBUTE
+#    define WEAK_IMPORT_ATTRIBUTE  __attribute__((weak_import))
+#      endif
+#  endif
 #   endif /* HAVE_WEAK_IMPORT */
+
 /*
+ *---------------------------------------------------------------------------
  * Support for MAC_OS_X_VERSION_MAX_ALLOWED define from AvailabilityMacros.h:
  * only use API available in the indicated OS version or earlier.
+ *---------------------------------------------------------------------------
  */
+
 #   ifdef MAC_OS_X_VERSION_MAX_ALLOWED
-#       if MAC_OS_X_VERSION_MAX_ALLOWED < 1050 && defined(__LP64__)
-#           undef HAVE_COREFOUNDATION
-#       endif
-#       if MAC_OS_X_VERSION_MAX_ALLOWED < 1040
-#           undef HAVE_OSSPINLOCKLOCK
-#           undef HAVE_PTHREAD_ATFORK
-#           undef HAVE_COPYFILE
-#       endif
-#       if MAC_OS_X_VERSION_MAX_ALLOWED < 1030
-#           ifdef TCL_THREADS
+#  if MAC_OS_X_VERSION_MAX_ALLOWED < 1050 && defined(__LP64__)
+#      undef HAVE_COREFOUNDATION
+#  endif
+#  if MAC_OS_X_VERSION_MAX_ALLOWED < 1040
+#      undef HAVE_OSSPINLOCKLOCK
+#      undef HAVE_PTHREAD_ATFORK
+#      undef HAVE_COPYFILE
+#  endif
+#  if MAC_OS_X_VERSION_MAX_ALLOWED < 1030
+#      ifdef TCL_THREADS
     /* prior to 10.3, realpath is not threadsafe, c.f. bug 711232 */
-#               define NO_REALPATH 1
-#           endif
-#           undef HAVE_LANGINFO
-#       endif
+#    define NO_REALPATH 1
+#      endif
+#      undef HAVE_LANGINFO
+#  endif
 #   endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
 #   if defined(HAVE_COREFOUNDATION) && defined(__LP64__) && \
       defined(HAVE_WEAK_IMPORT) && MAC_OS_X_VERSION_MIN_REQUIRED < 1050
-#       warning "Weak import of 64-bit CoreFoundation is not supported, will not run on Mac OS X < 10.5."
+#  warning "Weak import of 64-bit CoreFoundation is not supported, will not run on Mac OS X < 10.5."
 #   endif
+
 /*
+ *---------------------------------------------------------------------------
  * At present, using vfork() instead of fork() causes execve() to fail
  * intermittently on Darwin x86_64. rdar://4685553
+ *---------------------------------------------------------------------------
  */
+
 #   if defined(__x86_64__) && !defined(FIXED_RDAR_4685553)
-#       undef USE_VFORK
+#  undef USE_VFORK
 #   endif /* __x86_64__ */
 /* Workaround problems with vfork() when building with llvm-gcc-4.2 */
 #   if defined (__llvm__) && \
       (__GNUC__ > 4 || (__GNUC__ == 4 && (__GNUC_MINOR__ > 2 || \
       (__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ > 0))))
-#       undef USE_VFORK
+#  undef USE_VFORK
 #   endif /* __llvm__ */
 #endif /* __APPLE__ */
 
 /*
  *---------------------------------------------------------------------------
- * The following macros and declarations represent the interface between 
- * generic and unix-specific parts of Tcl.  Some of the macros may override 
+ * The following macros and declarations represent the interface between
+ * generic and unix-specific parts of Tcl. Some of the macros may override
  * functions declared in tclInt.h.
  *---------------------------------------------------------------------------
  */
@@ -571,54 +689,70 @@
 #endif
 
 /*
- * The following macros have trivial definitions, allowing generic code to 
+ *---------------------------------------------------------------------------
+ * The following macros have trivial definitions, allowing generic code to
  * address platform-specific issues.
+ *---------------------------------------------------------------------------
  */
 
-#define TclpGetPid(pid)    ((unsigned long) (pid))
 #define TclpReleaseFile(file)  /* Nothing. */
 
 /*
+ *---------------------------------------------------------------------------
  * The following defines wrap the system memory allocation routines.
+ *---------------------------------------------------------------------------
  */
 
-#define TclpSysAlloc(size, isBin)  malloc((size_t)size)
-#define TclpSysFree(ptr)    free((char*)ptr)
-#define TclpSysRealloc(ptr, size)  realloc((char*)ptr, (size_t)size)
+#define TclpSysAlloc(size, isBin)  malloc((size_t)(size))
+#define TclpSysFree(ptr)    free((char *)(ptr))
+#define TclpSysRealloc(ptr, size)  realloc((char *)(ptr), (size_t)(size))
 
 /*
- * The following macros and declaration wrap the C runtime library
- * functions.
+ *---------------------------------------------------------------------------
+ * The following macros and declaration wrap the C runtime library functions.
+ *---------------------------------------------------------------------------
  */
 
-#define TclpExit    exit
+#define TclpExit  exit
 
 #ifdef TCL_THREADS
-EXTERN struct tm *       TclpLocaltime(const time_t *);
-EXTERN struct tm *       TclpGmtime(const time_t *);
-EXTERN char *            TclpInetNtoa(struct in_addr);
-/* #define localtime(x)  TclpLocaltime(x)
- * #define gmtime(x)  TclpGmtime(x)    */
+#   include <pthread.h>
 #   undef inet_ntoa
 #   define inet_ntoa(x)  TclpInetNtoa(x)
 #endif /* TCL_THREADS */
 
+/* FIXME - Hyper-enormous platform assumption! */
+#ifndef AF_INET6
+#   define AF_INET6  10
+#endif
+
 /*
- * Set of MT-safe implementations of some
- * known-to-be-MT-unsafe library calls.
- * Instead of returning pointers to the
- * static storage, those return pointers
- * to the TSD data. 
+ *---------------------------------------------------------------------------
+ * Set of MT-safe implementations of some known-to-be-MT-unsafe library calls.
+ * Instead of returning pointers to the static storage, those return pointers
+ * to the TSD data.
+ *---------------------------------------------------------------------------
  */
 
 #include <pwd.h>
 #include <grp.h>
 
-MODULE_SCOPE struct passwd*  TclpGetPwNam(const char *name);
-MODULE_SCOPE struct group*   TclpGetGrNam(const char *name);
-MODULE_SCOPE struct passwd*  TclpGetPwUid(uid_t uid);
-MODULE_SCOPE struct group*   TclpGetGrGid(gid_t gid);
-MODULE_SCOPE struct hostent* TclpGetHostByName(const char *name);
-MODULE_SCOPE struct hostent* TclpGetHostByAddr(const char *addr, int length, int type);
+MODULE_SCOPE struct passwd *  TclpGetPwNam(const char *name);
+MODULE_SCOPE struct group *  TclpGetGrNam(const char *name);
+MODULE_SCOPE struct passwd *  TclpGetPwUid(uid_t uid);
+MODULE_SCOPE struct group *  TclpGetGrGid(gid_t gid);
+MODULE_SCOPE struct hostent *  TclpGetHostByName(const char *name);
+MODULE_SCOPE struct hostent *  TclpGetHostByAddr(const char *addr,
+            int length, int type);
+MODULE_SCOPE Tcl_Channel  TclpMakeTcpClientChannelMode(
+            ClientData tcpSocket, int mode);
 
 #endif /* _TCLUNIXPORT */
+
+/*
+ * Local Variables:
+ * mode: c
+ * c-basic-offset: 4
+ * fill-column: 78
+ * End:
+ */
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclWinPort.h vtk5.10/Utilities/TclTk/internals/tk8.6/tclWinPort.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tclWinPort.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tclWinPort.h	2019-02-01 16:20:04.000000000 +0100
@@ -9,13 +9,49 @@
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TCLWINPORT
 #define _TCLWINPORT
 
+#if !defined(_WIN64) && defined(BUILD_tcl)
+/* See [Bug 3354324]: file mtime sets wrong time */
+#   define _USE_32BIT_TIME_T
+#endif
+
+/*
+ * We must specify the lower version we intend to support.
+ *
+ * WINVER = 0x0500 means Windows 2000 and above
+ */
+
+#ifndef WINVER
+#   define WINVER 0x0501
+#endif
+#ifndef _WIN32_WINNT
+#   define _WIN32_WINNT 0x0501
+#endif
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#undef WIN32_LEAN_AND_MEAN
+
+/* Compatibility to older visual studio / windows platform SDK */
+#if !defined(MAXULONG_PTR)
+typedef DWORD DWORD_PTR;
+typedef DWORD_PTR * PDWORD_PTR;
+#endif
+
+/*
+ * Ask for the winsock function typedefs, also.
+ */
+#define INCL_WINSOCK_API_TYPEDEFS   1
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#ifdef HAVE_WSPIAPI_H
+#   include <wspiapi.h>
+#endif
+
 #ifdef CHECK_UNICODE_CALLS
 #   define _UNICODE
 #   define UNICODE
@@ -26,30 +62,42 @@
 #endif /* CHECK_UNICODE_CALLS */
 
 /*
+ *  Pull in the typedef of TCHAR for windows.
+ */
+#include <tchar.h>
+#ifndef _TCHAR_DEFINED
+    /* Borland seems to forget to set this. */
+    typedef _TCHAR TCHAR;
+#   define _TCHAR_DEFINED
+#endif
+#if defined(_MSC_VER) && defined(__STDC__)
+    /* VS2005 SP1 misses this. See [Bug #3110161] */
+    typedef _TCHAR TCHAR;
+#endif
+
+/*
  *---------------------------------------------------------------------------
  * The following sets of #includes and #ifdefs are required to get Tcl to
  * compile under the windows compilers.
  *---------------------------------------------------------------------------
  */
 
-#include <stdio.h>
-#include <stdlib.h>
-
+#include <wchar.h>
+#include <io.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <float.h>
-#include <io.h>
 #include <malloc.h>
 #include <process.h>
 #include <signal.h>
-#include <string.h>
+#include <limits.h>
 
-/*
- * These string functions are not defined with the same names on Windows.
- */
-
-#define strcasecmp stricmp
-#define strncasecmp strnicmp
+#ifndef strncasecmp
+#   define strncasecmp strnicmp
+#endif
+#ifndef strcasecmp
+#   define strcasecmp stricmp
+#endif
 
 /*
  * Need to block out these includes for building extensions with MetroWerks
@@ -68,155 +116,169 @@
 
 #include <time.h>
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#undef WIN32_LEAN_AND_MEAN
-
-/*
- * Ask for the winsock function typedefs, also.
- */
-#define INCL_WINSOCK_API_TYPEDEFS   1
-#include <winsock2.h>
-
-/*
- * Define EINPROGRESS in terms of WSAEINPROGRESS.
- */
-
-#ifndef  EINPROGRESS
-#   define EINPROGRESS  WSAEINPROGRESS
-#endif
-
-/*
- * If ENOTSUP is not defined, define it to a value that will never occur.
- */
-
-#ifndef ENOTSUP
-#   define ENOTSUP  -1030507
-#endif
-
 /*
  * The following defines redefine the Windows Socket errors as
  * BSD errors so Tcl_PosixError can do the right thing.
  */
 
-#ifndef EWOULDBLOCK
-#   define EWOULDBLOCK  EAGAIN
+#ifndef ENOTEMPTY
+#   define ENOTEMPTY   41  /* Directory not empty */
+#endif
+#ifndef EREMOTE
+#   define EREMOTE  66  /* The object is remote */
+#endif
+#ifndef EPFNOSUPPORT
+#   define EPFNOSUPPORT  96  /* Protocol family not supported */
+#endif
+#ifndef EADDRINUSE
+#   define EADDRINUSE  100  /* Address already in use */
+#endif
+#ifndef EADDRNOTAVAIL
+#   define EADDRNOTAVAIL 101  /* Can't assign requested address */
+#endif
+#ifndef EAFNOSUPPORT
+#   define EAFNOSUPPORT  102  /* Address family not supported */
 #endif
 #ifndef EALREADY
-#   define EALREADY  149  /* operation already in progress */
+#   define EALREADY  103  /* Operation already in progress */
 #endif
-#ifndef ENOTSOCK
-#   define ENOTSOCK  95  /* Socket operation on non-socket */
+#ifndef EBADMSG
+#   define EBADMSG  104  /* Not a data message */
 #endif
-#ifndef EDESTADDRREQ
-#   define EDESTADDRREQ  96  /* Destination address required */
+#ifndef ECANCELED
+#   define ECANCELED  105  /* Canceled */
 #endif
-#ifndef EMSGSIZE
-#   define EMSGSIZE  97  /* Message too long */
+#ifndef ECONNABORTED
+#   define ECONNABORTED  106  /* Software caused connection abort */
 #endif
-#ifndef EPROTOTYPE
-#   define EPROTOTYPE  98  /* Protocol wrong type for socket */
+#ifndef ECONNREFUSED
+#   define ECONNREFUSED  107  /* Connection refused */
 #endif
-#ifndef ENOPROTOOPT
-#   define ENOPROTOOPT  99  /* Protocol not available */
+#ifndef ECONNRESET
+#   define ECONNRESET  108  /* Connection reset by peer */
 #endif
-#ifndef EPROTONOSUPPORT
-#   define EPROTONOSUPPORT 120  /* Protocol not supported */
+#ifndef EDESTADDRREQ
+#   define EDESTADDRREQ  109  /* Destination address required */
 #endif
-#ifndef ESOCKTNOSUPPORT
-#   define ESOCKTNOSUPPORT 121  /* Socket type not supported */
+#ifndef EHOSTUNREACH
+#   define EHOSTUNREACH  110  /* No route to host */
 #endif
-#ifndef EOPNOTSUPP
-#   define EOPNOTSUPP  122  /* Operation not supported on socket */
+#ifndef EIDRM
+#   define EIDRM  111  /* Identifier removed */
 #endif
-#ifndef EPFNOSUPPORT
-#   define EPFNOSUPPORT  123  /* Protocol family not supported */
+#ifndef EINPROGRESS
+#   define EINPROGRESS  112  /* Operation now in progress */
 #endif
-#ifndef EAFNOSUPPORT
-#   define EAFNOSUPPORT  124  /* Address family not supported */
+#ifndef EISCONN
+#   define EISCONN  113  /* Socket is already connected */
 #endif
-#ifndef EADDRINUSE
-#   define EADDRINUSE  125  /* Address already in use */
+#ifndef ELOOP
+#   define ELOOP  114  /* Symbolic link loop */
 #endif
-#ifndef EADDRNOTAVAIL
-#   define EADDRNOTAVAIL 126  /* Can't assign requested address */
+#ifndef EMSGSIZE
+#   define EMSGSIZE  115  /* Message too long */
 #endif
 #ifndef ENETDOWN
-#   define ENETDOWN  127  /* Network is down */
+#   define ENETDOWN  116  /* Network is down */
+#endif
+#ifndef ENETRESET
+#   define ENETRESET  117  /* Network dropped connection on reset */
 #endif
 #ifndef ENETUNREACH
-#   define ENETUNREACH  128  /* Network is unreachable */
+#   define ENETUNREACH  118  /* Network is unreachable */
 #endif
-#ifndef ENETRESET
-#   define ENETRESET  129  /* Network dropped connection on reset */
+#ifndef ENOBUFS
+#   define ENOBUFS  119  /* No buffer space available */
 #endif
-#ifndef ECONNABORTED
-#   define ECONNABORTED  130  /* Software caused connection abort */
+#ifndef ENODATA
+#   define ENODATA  120  /* No data available */
 #endif
-#ifndef ECONNRESET
-#   define ECONNRESET  131  /* Connection reset by peer */
+#ifndef ENOLINK
+#   define ENOLINK  121  /* Link has be severed */
 #endif
-#ifndef ENOBUFS
-#   define ENOBUFS  132  /* No buffer space available */
+#ifndef ENOMSG
+#   define ENOMSG  122  /* No message of desired type */
 #endif
-#ifndef EISCONN
-#   define EISCONN  133  /* Socket is already connected */
+#ifndef ENOPROTOOPT
+#   define ENOPROTOOPT  123  /* Protocol not available */
+#endif
+#ifndef ENOSR
+#   define ENOSR  124  /* Out of stream resources */
+#endif
+#ifndef ENOSTR
+#   define ENOSTR  125  /* Not a stream device */
 #endif
 #ifndef ENOTCONN
-#   define ENOTCONN  134  /* Socket is not connected */
+#   define ENOTCONN  126  /* Socket is not connected */
 #endif
-#ifndef ESHUTDOWN
-#   define ESHUTDOWN  143  /* Can't send after socket shutdown */
+#ifndef ENOTRECOVERABLE
+#   define ENOTRECOVERABLE  127  /* Not recoverable */
 #endif
-#ifndef ETOOMANYREFS
-#   define ETOOMANYREFS  144  /* Too many references: can't splice */
+#ifndef ENOTSOCK
+#   define ENOTSOCK  128  /* Socket operation on non-socket */
+#endif
+#ifndef ENOTSUP
+#   define ENOTSUP  129  /* Operation not supported */
+#endif
+#ifndef EOPNOTSUPP
+#   define EOPNOTSUPP  130  /* Operation not supported on socket */
+#endif
+#ifndef EOTHER
+#   define EOTHER  131  /* Other error */
+#endif
+#ifndef EOVERFLOW
+#   define EOVERFLOW  132  /* File too big */
+#endif
+#ifndef EOWNERDEAD
+#   define EOWNERDEAD  133  /* Owner dead */
+#endif
+#ifndef EPROTO
+#   define EPROTO  134  /* Protocol error */
+#endif
+#ifndef EPROTONOSUPPORT
+#   define EPROTONOSUPPORT 135  /* Protocol not supported */
+#endif
+#ifndef EPROTOTYPE
+#   define EPROTOTYPE  136  /* Protocol wrong type for socket */
+#endif
+#ifndef ETIME
+#   define ETIME  137  /* Timer expired */
 #endif
 #ifndef ETIMEDOUT
-#   define ETIMEDOUT  145  /* Connection timed out */
+#   define ETIMEDOUT  138  /* Connection timed out */
 #endif
-#ifndef ECONNREFUSED
-#   define ECONNREFUSED  146  /* Connection refused */
+#ifndef ETXTBSY
+#   define ETXTBSY  139  /* Text file or pseudo-device busy */
 #endif
-#ifndef ELOOP
-#   define ELOOP  90  /* Symbolic link loop */
+#ifndef EWOULDBLOCK
+#   define EWOULDBLOCK  140  /* Operation would block */
 #endif
-#ifndef EHOSTDOWN
-#   define EHOSTDOWN  147  /* Host is down */
+
+
+/* Visual Studio doesn't have these, so just choose some high numbers */
+#ifndef ESOCKTNOSUPPORT
+#   define ESOCKTNOSUPPORT 240  /* Socket type not supported */
 #endif
-#ifndef EHOSTUNREACH
-#   define EHOSTUNREACH  148  /* No route to host */
+#ifndef ESHUTDOWN
+#   define ESHUTDOWN  241  /* Can't send after socket shutdown */
 #endif
-#ifndef ENOTEMPTY
-#   define ENOTEMPTY   93  /* directory not empty */
+#ifndef ETOOMANYREFS
+#   define ETOOMANYREFS  242  /* Too many references: can't splice */
+#endif
+#ifndef EHOSTDOWN
+#   define EHOSTDOWN  243  /* Host is down */
 #endif
 #ifndef EUSERS
-#   define EUSERS  94  /* Too many users (for UFS) */
+#   define EUSERS  244  /* Too many users (for UFS) */
 #endif
 #ifndef EDQUOT
-#   define EDQUOT  69  /* Disc quota exceeded */
+#   define EDQUOT  245  /* Disc quota exceeded */
 #endif
 #ifndef ESTALE
-#   define ESTALE  151  /* Stale NFS file handle */
-#endif
-#ifndef EREMOTE
-#   define EREMOTE  66  /* The object is remote */
+#   define ESTALE  246  /* Stale NFS file handle */
 #endif
 
 /*
- * It is very hard to determine how Windows reacts to attempting to
- * set a file pointer outside the input datatype's representable
- * region.  So we fake the error code ourselves.
- */
-
-#ifndef EOVERFLOW
-#   ifdef EFBIG
-#      define EOVERFLOW  EFBIG  /* The object couldn't fit in the datatype */
-#   else /* !EFBIG */
-#      define EOVERFLOW  EINVAL  /* Better than nothing! */
-#   endif /* EFBIG */
-#endif /* !EOVERFLOW */
-
-/*
  * Signals not known to the standard ANSI signal.h.  These are used
  * by Tcl_WaitPid() and generic/tclPosixStr.c
  */
@@ -298,7 +360,7 @@
  */
 
 #ifndef S_IFLNK
-#define S_IFLNK        0120000  /* Symbolic Link */
+#   define S_IFLNK        0120000  /* Symbolic Link */
 #endif
 
 #ifndef S_ISREG
@@ -350,11 +412,11 @@
  */
 
 #ifndef MAXPATH
-#define MAXPATH MAX_PATH
+#   define MAXPATH MAX_PATH
 #endif /* MAXPATH */
 
 #ifndef MAXPATHLEN
-#define MAXPATHLEN MAXPATH
+#   define MAXPATHLEN MAXPATH
 #endif /* MAXPATHLEN */
 
 /*
@@ -375,13 +437,15 @@
  */
 
 #if defined(_MSC_VER) || defined(__MINGW32__)
-#    define environ _environ
-#    define hypot _hypot
-#    define exception _exception
-#    undef EDEADLOCK
-#    if defined(__MINGW32__) && !defined(__MSVCRT__)
+#   define environ _environ
+#   if defined(_MSC_VER) && (_MSC_VER < 1600)
+#  define hypot _hypot
+#   endif
+#   define exception _exception
+#   undef EDEADLOCK
+#   if defined(__MINGW32__) && !defined(__MSVCRT__)
 #  define timezone _timezone
-#    endif
+#   endif
 #endif /* _MSC_VER || __MINGW32__ */
 
 /*
@@ -393,21 +457,7 @@
 #   define environ  _environ
 #endif /* __BORLANDC__ */
 
-#ifdef __CYGWIN__
-/* On Cygwin, the environment is imported from the Cygwin DLL. */
-     DLLIMPORT extern char **__cygwin_environ;
-#    define environ __cygwin_environ
-#    define putenv TclCygwinPutenv
-#    define timezone _timezone
-#endif /* __CYGWIN__ */
-
-
 #ifdef __WATCOMC__
-    /* 
-     * OpenWatcom uses a wine derived winsock2.h that is missing the
-     * LPFN_* typedefs.
-     */
-#   define HAVE_NO_LPFN_DECLS
 #   if !defined(__CHAR_SIGNED__)
 #  error "You must use the -j switch to ensure char is signed."
 #   endif
@@ -425,15 +475,9 @@
 
 
 /*
- * There is no platform-specific panic routine for Windows in the Tcl internals.
- */
-
-#define TclpPanic ((Tcl_PanicProc *) NULL)
-
-/*
  *---------------------------------------------------------------------------
- * The following macros and declarations represent the interface between 
- * generic and windows-specific parts of Tcl.  Some of the macros may 
+ * The following macros and declarations represent the interface between
+ * generic and windows-specific parts of Tcl.  Some of the macros may
  * override functions declared in tclInt.h.
  *---------------------------------------------------------------------------
  */
@@ -470,7 +514,7 @@
 /*
  * Older version of Mingw are known to lack a MWMO_ALERTABLE define.
  */
-#if defined(HAVE_NO_MWMO_ALERTABLE)
+#if !defined(MWMO_ALERTABLE)
 #   define MWMO_ALERTABLE 2
 #endif
 
@@ -479,18 +523,12 @@
  * use by tclAlloc.c.
  */
 
-#ifdef __CYGWIN__
-#   define TclpSysAlloc(size, isBin)  malloc((size))
-#   define TclpSysFree(ptr)    free((ptr))
-#   define TclpSysRealloc(ptr, size)  realloc((ptr), (size))
-#else
-#   define TclpSysAlloc(size, isBin)  ((void*)HeapAlloc(GetProcessHeap(), \
+#define TclpSysAlloc(size, isBin)  ((void*)HeapAlloc(GetProcessHeap(), \
               (DWORD)0, (DWORD)size))
-#   define TclpSysFree(ptr)    (HeapFree(GetProcessHeap(), \
+#define TclpSysFree(ptr)    (HeapFree(GetProcessHeap(), \
               (DWORD)0, (HGLOBAL)ptr))
-#   define TclpSysRealloc(ptr, size)  ((void*)HeapReAlloc(GetProcessHeap(), \
+#define TclpSysRealloc(ptr, size)  ((void*)HeapReAlloc(GetProcessHeap(), \
               (DWORD)0, (LPVOID)ptr, (DWORD)size))
-#endif
 
 /*
  * The following defines map from standard socket names to our internal
@@ -500,21 +538,20 @@
 
 #define getservbyname  TclWinGetServByName
 #define getsockopt  TclWinGetSockOpt
-#define ntohs    TclWinNToHS
 #define setsockopt  TclWinSetSockOpt
 /* This type is not defined in the Windows headers */
 #define socklen_t       int
 
 
 /*
- * The following macros have trivial definitions, allowing generic code to 
+ * The following macros have trivial definitions, allowing generic code to
  * address platform-specific issues.
  */
 
 #define TclpReleaseFile(file)  ckfree((char *) file)
 
 /*
- * The following macros and declarations wrap the C runtime library 
+ * The following macros and declarations wrap the C runtime library
  * functions.
  */
 
@@ -524,4 +561,8 @@
 #define INVALID_SET_FILE_POINTER 0xFFFFFFFF
 #endif /* INVALID_SET_FILE_POINTER */
 
+#ifndef LABEL_SECURITY_INFORMATION
+#   define LABEL_SECURITY_INFORMATION (0x00000010L)
+#endif
+
 #endif /* _TCLWINPORT */
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkInt.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkInt.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkInt.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkInt.h	2019-02-01 16:20:04.000000000 +0100
@@ -10,29 +10,22 @@
  *
  * See the file "license.terms" for information on usage and redistribution of
  * this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: Id
  */
 
 #ifndef _TKINT
 #define _TKINT
 
-#ifndef _TK
-#include "tk.h"
-#endif
-#ifndef _TCL
-#include "tcl.h"
-#endif
 #ifndef _TKPORT
 #include "tkPort.h"
 #endif
 
 /*
- * Ensure WORDS_BIGENDIAN is defined correcly:
+ * Ensure WORDS_BIGENDIAN is defined correctly:
  * Needs to happen here in addition to configure to work with fat compiles on
  * Darwin (where configure runs only once for multiple architectures).
  */
 
+#include <stdio.h>
 #ifdef HAVE_SYS_TYPES_H
 #    include <sys/types.h>
 #endif
@@ -102,18 +95,11 @@
 typedef struct TkRegion_ *TkRegion;
 typedef struct TkStressedCmap TkStressedCmap;
 typedef struct TkBindInfo_ *TkBindInfo;
-
-/*
- * Function types.
- */
-
-typedef int (TkBindEvalProc)(ClientData clientData, Tcl_Interp *interp,
-  XEvent *eventPtr, Tk_Window tkwin, KeySym keySym);
-typedef void (TkBindFreeProc)(ClientData clientData);
+typedef struct Busy *TkBusy;
 
 /*
  * One of the following structures is maintained for each cursor in use in the
- * system. This structure is used by tkCursor.c and the various system
+ * system. This structure is used by tkCursor.c and the various system-
  * specific cursor files.
  */
 
@@ -313,8 +299,9 @@
          * multiple applications on the display have
          * the focus, this will refer to the innermost
          * window in the innermost application. This
-         * information isn't used under Unix or
-         * Windows, but it's needed on the Mac. */
+         * information isn't used on Windows, but it's
+         * needed on the Mac, and also on X11 when XIM
+         * processing is being done. */
 
     /*
      * Information used by tkGC.c only:
@@ -398,10 +385,6 @@
     int postCommandGeneration;
 
     /*
-     * Information used by tkOption.c only.
-     */
-
-    /*
      * Information used by tkPack.c only.
      */
 
@@ -470,24 +453,6 @@
          * application name on each comm window. */
 
     /*
-     * Information used by tkXId.c only:
-     */
-
-    struct TkIdStack *idStackPtr;
-        /* First in list of chunks of free resource
-         * identifiers, or NULL if there are no free
-         * resources. */
-    XID (*defaultAllocProc) (Display *display);
-        /* Default resource allocator for display. */
-    struct TkIdStack *windowStackPtr;
-        /* First in list of chunks of window ids that
-         * can't be reused right now. */
-    Tcl_TimerToken idCleanupScheduled;
-        /* If set, it means a call to WindowIdCleanup
-         * has already been scheduled, 0 means it
-         * hasn't. */
-
-    /*
      * Information used by tkUnixWm.c and tkWinWm.c only:
      */
 
@@ -496,18 +461,6 @@
         /* Points to the foreground window. */
 
     /*
-     * Information maintained by tkWindow.c for use later on by tkXId.c:
-     */
-
-    int destroyCount;    /* Number of Tk_DestroyWindow operations in
-         * progress. */
-    unsigned long lastDestroyRequest;
-        /* Id of most recent XDestroyWindow request;
-         * can re-use ids in windowStackPtr when
-         * server has seen this request and event
-         * queue is empty. */
-
-    /*
      * Information used by tkVisual.c only:
      */
 
@@ -538,7 +491,9 @@
          * display. */
     Window mouseButtonWindow;  /* Window the button state was set in, added
          * in Tk 8.4. */
-    Window warpWindow;
+    Tk_Window warpWindow;
+    Tk_Window warpMainwin;  /* For finding the root window for warping
+         * purposes. */
     int warpX;
     int warpY;
 
@@ -670,6 +625,7 @@
          * ::tk::AlwaysShowSelection variable. */
     struct TkMainInfo *nextPtr;  /* Next in list of all main windows managed by
          * this process. */
+    Tcl_HashTable busyTable;  /* Information used by [tk busy] command. */
 } TkMainInfo;
 
 /*
@@ -679,7 +635,7 @@
  */
 
 typedef struct {
-    const char *source;    /* Bits for bitmap. */
+    const void *source;    /* Bits for bitmap. */
     int width, height;    /* Dimensions of bitmap. */
     int native;      /* 0 means generic (X style) bitmap, 1 means
              * native style bitmap. */
@@ -804,7 +760,8 @@
      * Information used by tkGeometry.c for geometry management.
      */
 
-    const Tk_GeomMgr *geomMgrPtr; /* Information about geometry manager for this
+    const Tk_GeomMgr *geomMgrPtr;
+        /* Information about geometry manager for this
          * window. */
     ClientData geomData;  /* Argument for geometry manager functions. */
     int reqWidth, reqHeight;  /* Arguments from last call to
@@ -823,13 +780,14 @@
     struct TkWmInfo *wmInfoPtr;  /* For top-level windows (and also for special
          * Unix menubar and wrapper windows), points
          * to structure with wm-related info (see
-         * tkWm.c). For other windows, this is NULL. */
+         * tkWm.c). For other windows, this is
+         * NULL. */
 
     /*
      * Information used by widget classes.
      */
 
-    Tk_ClassProcs *classProcsPtr;
+    const Tk_ClassProcs *classProcsPtr;
     ClientData instanceData;
 
     /*
@@ -849,9 +807,47 @@
 
     int minReqWidth;    /* Minimum requested width. */
     int minReqHeight;    /* Minimum requested height. */
+    char *geometryMaster;
 } TkWindow;
 
 /*
+ * Real definition of some events. Note that these events come from outside
+ * but have internally generated pieces added to them.
+ */
+
+typedef struct {
+    XKeyEvent keyEvent;    /* The real event from X11. */
+    char *charValuePtr;    /* A pointer to a string that holds the key's
+         * %A substitution text (before backslash
+         * adding), or NULL if that has not been
+         * computed yet. If non-NULL, this string was
+         * allocated with ckalloc(). */
+    int charValueLen;    /* Length of string in charValuePtr when that
+         * is non-NULL. */
+    KeySym keysym;    /* Key symbol computed after input methods
+         * have been invoked */
+} TkKeyEvent;
+
+/*
+ * Flags passed to TkpMakeMenuWindow's 'transient' argument.
+ */
+
+#define TK_MAKE_MENU_TEAROFF  0  /* Only non-transient case. */
+#define TK_MAKE_MENU_POPUP  1
+#define TK_MAKE_MENU_DROPDOWN  2
+
+/*
+ * The following structure is used with TkMakeEnsemble to create ensemble
+ * commands and optionally to create sub-ensembles.
+ */
+
+typedef struct TkEnsemble {
+    const char *name;
+    Tcl_ObjCmdProc *proc;
+    const struct TkEnsemble *subensemble;
+} TkEnsemble;
+
+/*
  * The following structure is used as a two way map between integers and
  * strings, usually to map between an internal C representation and the
  * strings used in Tcl.
@@ -879,12 +875,6 @@
 #define TKP_CLIP_REGION 1
 
 /*
- * Pointer to first entry in list of all displays currently known.
- */
-
-extern TkDisplay *tkDisplayList;
-
-/*
  * Return values from TkGrabState:
  */
 
@@ -931,35 +921,74 @@
  * be properly registered with Tcl:
  */
 
-MODULE_SCOPE Tcl_ObjType tkBorderObjType;
-MODULE_SCOPE Tcl_ObjType tkBitmapObjType;
-MODULE_SCOPE Tcl_ObjType tkColorObjType;
-MODULE_SCOPE Tcl_ObjType tkCursorObjType;
-MODULE_SCOPE Tcl_ObjType tkFontObjType;
-MODULE_SCOPE Tcl_ObjType tkOptionObjType;
-MODULE_SCOPE Tcl_ObjType tkStateKeyObjType;
-MODULE_SCOPE Tcl_ObjType tkTextIndexType;
+MODULE_SCOPE const Tcl_ObjType tkBorderObjType;
+MODULE_SCOPE const Tcl_ObjType tkBitmapObjType;
+MODULE_SCOPE const Tcl_ObjType tkColorObjType;
+MODULE_SCOPE const Tcl_ObjType tkCursorObjType;
+MODULE_SCOPE const Tcl_ObjType tkFontObjType;
+MODULE_SCOPE const Tcl_ObjType tkStateKeyObjType;
+MODULE_SCOPE const Tcl_ObjType tkTextIndexType;
 
 /*
  * Miscellaneous variables shared among Tk modules but not exported to the
  * outside world:
  */
 
-MODULE_SCOPE Tk_SmoothMethod  tkBezierSmoothMethod;
+MODULE_SCOPE const Tk_SmoothMethod tkBezierSmoothMethod;
 MODULE_SCOPE Tk_ImageType  tkBitmapImageType;
 MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtGIF;
 MODULE_SCOPE void    (*tkHandleEventProc) (XEvent* eventPtr);
+MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtPNG;
 MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtPPM;
 MODULE_SCOPE TkMainInfo    *tkMainWindowList;
 MODULE_SCOPE Tk_ImageType  tkPhotoImageType;
 MODULE_SCOPE Tcl_HashTable  tkPredefBitmapTable;
 
-#include "tkIntDecls.h"
+MODULE_SCOPE const char *const tkWebColors[20];
+
+/*
+ * The definition of pi, at least from the perspective of double-precision
+ * floats.
+ */
+
+#ifndef PI
+#ifdef M_PI
+#define PI  M_PI
+#else
+#define PI  3.14159265358979323846
+#endif
+#endif
 
-#ifdef BUILD_tk
-#undef TCL_STORAGE_CLASS
-#define TCL_STORAGE_CLASS DLLEXPORT
+/*
+ * Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>
+ */
+
+#if defined(PURIFY) && defined(__clang__)
+#if __has_feature(attribute_analyzer_noreturn) && \
+  !defined(Tcl_Panic) && defined(Tcl_Panic_TCL_DECLARED)
+void Tcl_Panic(const char *, ...) __attribute__((analyzer_noreturn));
 #endif
+#if !defined(CLANG_ASSERT)
+#include <assert.h>
+#define CLANG_ASSERT(x) assert(x)
+#endif
+#elif !defined(CLANG_ASSERT)
+#define CLANG_ASSERT(x)
+#endif /* PURIFY && __clang__ */
+
+/*
+ * The following magic value is stored in the "send_event" field of FocusIn
+ * and FocusOut events. This allows us to separate "real" events coming from
+ * the server from those that we generated.
+ */
+
+#define GENERATED_FOCUS_EVENT_MAGIC  ((Bool) 0x547321ac)
+
+/*
+ * Exported internals.
+ */
+
+#include "tkIntDecls.h"
 
 /*
  * Themed widget set init function:
@@ -981,6 +1010,9 @@
 MODULE_SCOPE int  Tk_BindtagsObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
+MODULE_SCOPE int  Tk_BusyObjCmd(ClientData clientData,
+          Tcl_Interp *interp, int objc,
+          Tcl_Obj *const objv[]);
 MODULE_SCOPE int  Tk_ButtonObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
@@ -999,9 +1031,6 @@
 MODULE_SCOPE int  Tk_ChooseDirectoryObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
-MODULE_SCOPE int  Tk_ChooseFontObjCmd(ClientData clientData,
-          Tcl_Interp *interp, int objc,
-          Tcl_Obj *const objv[]);
 MODULE_SCOPE int  Tk_DestroyObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
@@ -1093,9 +1122,6 @@
 MODULE_SCOPE int  Tk_TextObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
-MODULE_SCOPE int  Tk_TkObjCmd(ClientData clientData,
-          Tcl_Interp *interp, int objc,
-          Tcl_Obj *const objv[]);
 MODULE_SCOPE int  Tk_TkwaitObjCmd(ClientData clientData,
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
@@ -1111,6 +1137,14 @@
 MODULE_SCOPE int  Tk_WmObjCmd(ClientData clientData, Tcl_Interp *interp,
           int objc, Tcl_Obj *const objv[]);
 
+MODULE_SCOPE int  Tk_GetDoublePixelsFromObj(Tcl_Interp *interp,
+          Tk_Window tkwin, Tcl_Obj *objPtr,
+          double *doublePtr);
+MODULE_SCOPE int  TkSetGeometryMaster(Tcl_Interp *interp,
+          Tk_Window tkwin, const char *master);
+MODULE_SCOPE void  TkFreeGeometryMaster(Tk_Window tkwin,
+          const char *master);
+
 MODULE_SCOPE void  TkEventInit(void);
 MODULE_SCOPE void  TkRegisterObjTypes(void);
 MODULE_SCOPE int  TkCreateMenuCmd(Tcl_Interp *interp);
@@ -1119,53 +1153,11 @@
 MODULE_SCOPE int  TkCanvasGetCoordObj(Tcl_Interp *interp,
           Tk_Canvas canvas, Tcl_Obj *obj,
           double *doublePtr);
-MODULE_SCOPE int  TkCanvasDashParseProc(ClientData clientData,
-          Tcl_Interp *interp, Tk_Window tkwin,
-          const char *value, char *widgRec, int offset);
-MODULE_SCOPE char *  TkCanvasDashPrintProc(ClientData clientData,
-          Tk_Window tkwin, char *widgRec, int offset,
-          Tcl_FreeProc **freeProcPtr);
 MODULE_SCOPE int  TkGetDoublePixels(Tcl_Interp *interp, Tk_Window tkwin,
           const char *string, double *doublePtr);
-MODULE_SCOPE int  TkOffsetParseProc(ClientData clientData,
-          Tcl_Interp *interp, Tk_Window tkwin,
-          const char *value, char *widgRec, int offset);
-MODULE_SCOPE char *  TkOffsetPrintProc(ClientData clientData,
-          Tk_Window tkwin, char *widgRec, int offset,
-          Tcl_FreeProc **freeProcPtr);
-MODULE_SCOPE int  TkOrientParseProc(ClientData clientData,
-          Tcl_Interp *interp, Tk_Window tkwin,
-          const char *value, char *widgRec, int offset);
-MODULE_SCOPE char *  TkOrientPrintProc(ClientData clientData,
-          Tk_Window tkwin, char *widgRec, int offset,
-          Tcl_FreeProc **freeProcPtr);
-MODULE_SCOPE int  TkPixelParseProc(ClientData clientData,
-          Tcl_Interp *interp, Tk_Window tkwin,
-          const char *value, char *widgRec, int offset);
-MODULE_SCOPE char *  TkPixelPrintProc(ClientData clientData,
-          Tk_Window tkwin, char *widgRec, int offset,
-          Tcl_FreeProc **freeProcPtr);
 MODULE_SCOPE int  TkPostscriptImage(Tcl_Interp *interp, Tk_Window tkwin,
           Tk_PostscriptInfo psInfo, XImage *ximage,
           int x, int y, int width, int height);
-MODULE_SCOPE int  TkSmoothParseProc(ClientData clientData,
-          Tcl_Interp *interp, Tk_Window tkwin,
-          const char *value, char *recordPtr, int offset);
-MODULE_SCOPE char *  TkSmoothPrintProc(ClientData clientData,
-          Tk_Window tkwin, char *recordPtr, int offset,
-          Tcl_FreeProc **freeProcPtr);
-MODULE_SCOPE int  TkStateParseProc(ClientData clientData,
-          Tcl_Interp *interp, Tk_Window tkwin,
-          const char *value, char *widgRec, int offset);
-MODULE_SCOPE char *  TkStatePrintProc(ClientData clientData,
-          Tk_Window tkwin, char *widgRec, int offset,
-          Tcl_FreeProc **freeProcPtr);
-MODULE_SCOPE int  TkTileParseProc(ClientData clientData,
-          Tcl_Interp *interp, Tk_Window tkwin,
-          const char *value, char *widgRec, int offset);
-MODULE_SCOPE char *  TkTilePrintProc(ClientData clientData, Tk_Window tkwin,
-          char *widgRec, int offset,
-          Tcl_FreeProc **freeProcPtr);
 MODULE_SCOPE void       TkMapTopFrame(Tk_Window tkwin);
 MODULE_SCOPE XEvent *  TkpGetBindingXEvent(Tcl_Interp *interp);
 MODULE_SCOPE void  TkCreateExitHandler(Tcl_ExitProc *proc,
@@ -1178,8 +1170,8 @@
           unsigned x, unsigned y, unsigned width,
           unsigned height, unsigned char *dataPtr,
           unsigned pixelStride, unsigned lineStride);
-MODULE_SCOPE void  TkPrintPadAmount(Tcl_Interp *interp,
-          char *buffer, int pad1, int pad2);
+MODULE_SCOPE void  TkAppendPadAmount(Tcl_Obj *bufferObj,
+          const char *buffer, int pad1, int pad2);
 MODULE_SCOPE int  TkParsePadAmount(Tcl_Interp *interp,
           Tk_Window tkwin, Tcl_Obj *objPtr,
           int *pad1Ptr, int *pad2Ptr);
@@ -1200,6 +1192,37 @@
           int firstByte, int lastByte);
 MODULE_SCOPE void  TkpGetFontAttrsForChar(Tk_Window tkwin, Tk_Font tkfont,
           Tcl_UniChar c, struct TkFontAttributes *faPtr);
+MODULE_SCOPE Tcl_Obj *  TkNewWindowObj(Tk_Window tkwin);
+MODULE_SCOPE void  TkpShowBusyWindow(TkBusy busy);
+MODULE_SCOPE void  TkpHideBusyWindow(TkBusy busy);
+MODULE_SCOPE void  TkpMakeTransparentWindowExist(Tk_Window tkwin,
+          Window parent);
+MODULE_SCOPE void  TkpCreateBusy(Tk_FakeWin *winPtr, Tk_Window tkRef,
+          Window *parentPtr, Tk_Window tkParent,
+          TkBusy busy);
+MODULE_SCOPE int  TkBackgroundEvalObjv(Tcl_Interp *interp,
+          int objc, Tcl_Obj *const *objv, int flags);
+MODULE_SCOPE void  TkSendVirtualEvent(Tk_Window tgtWin,
+          const char *eventName);
+MODULE_SCOPE Tcl_Command TkMakeEnsemble(Tcl_Interp *interp,
+          const char *nsname, const char *name,
+          ClientData clientData, const TkEnsemble *map);
+MODULE_SCOPE int  TkInitTkCmd(Tcl_Interp *interp,
+          ClientData clientData);
+MODULE_SCOPE int  TkInitFontchooser(Tcl_Interp *interp,
+          ClientData clientData);
+MODULE_SCOPE void  TkpWarpPointer(TkDisplay *dispPtr);
+
+#ifdef __WIN32__
+#define TkParseColor XParseColor
+#else
+MODULE_SCOPE Status TkParseColor (Display * display,
+        Colormap map, const char* spec,
+        XColor * colorPtr);
+#endif
+#ifdef HAVE_XFT
+MODULE_SCOPE void  TkUnixSetXftClipRegion(TkRegion clipRegion);
+#endif
 
 /*
  * Unsupported commands.
@@ -1209,11 +1232,21 @@
           Tcl_Interp *interp, int objc,
           Tcl_Obj *const objv[]);
 
-#undef TCL_STORAGE_CLASS
-#define TCL_STORAGE_CLASS DLLIMPORT
+/*
+ * For Tktest.
+ */
+MODULE_SCOPE int SquareObjCmd(ClientData clientData,
+          Tcl_Interp *interp, int objc,
+          Tcl_Obj * const objv[]);
+MODULE_SCOPE int  TkOldTestInit(Tcl_Interp *interp);
+#if !(defined(__WIN32__) || defined(MAC_OSX_TK))
+#define TkplatformtestInit(x) TCL_OK
+#else
+MODULE_SCOPE int  TkplatformtestInit(Tcl_Interp *interp);
+#endif
 
 #endif /* _TKINT */
-
+
 /*
  * Local Variables:
  * mode: c
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkIntDecls.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkIntDecls.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkIntDecls.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkIntDecls.h	2019-02-01 16:20:04.000000000 +0100
@@ -10,8 +10,6 @@
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TKINTDECLS
@@ -22,6 +20,13 @@
 #define TCL_STORAGE_CLASS DLLEXPORT
 #endif
 
+struct TkText;
+typedef struct TkTextBTree_ *TkTextBTree;
+struct TkTextDispChunk;
+struct TkTextIndex;
+struct TkTextSegment;
+struct TkSharedText;
+
 /*
  * WARNING: This file is automatically generated by the tools/genStubs.tcl
  * script.  Any modifications to the function declarations below should be made
@@ -34,775 +39,328 @@
  * Exported function declarations:
  */
 
-#ifndef TkAllocWindow_TCL_DECLARED
-#define TkAllocWindow_TCL_DECLARED
 /* 0 */
-EXTERN TkWindow *  TkAllocWindow (TkDisplay * dispPtr, int screenNum, 
-        TkWindow * parentPtr);
-#endif
-#ifndef TkBezierPoints_TCL_DECLARED
-#define TkBezierPoints_TCL_DECLARED
+EXTERN TkWindow *  TkAllocWindow(TkDisplay *dispPtr, int screenNum,
+        TkWindow *parentPtr);
 /* 1 */
-EXTERN void    TkBezierPoints (double control[], int numSteps, 
-        double * coordPtr);
-#endif
-#ifndef TkBezierScreenPoints_TCL_DECLARED
-#define TkBezierScreenPoints_TCL_DECLARED
+EXTERN void    TkBezierPoints(double control[], int numSteps,
+        double *coordPtr);
 /* 2 */
-EXTERN void    TkBezierScreenPoints (Tk_Canvas canvas, 
-        double control[], int numSteps, 
-        XPoint * xPointPtr);
-#endif
-#ifndef TkBindDeadWindow_TCL_DECLARED
-#define TkBindDeadWindow_TCL_DECLARED
-/* 3 */
-EXTERN void    TkBindDeadWindow (TkWindow * winPtr);
-#endif
-#ifndef TkBindEventProc_TCL_DECLARED
-#define TkBindEventProc_TCL_DECLARED
+EXTERN void    TkBezierScreenPoints(Tk_Canvas canvas,
+        double control[], int numSteps,
+        XPoint *xPointPtr);
+/* Slot 3 is reserved */
 /* 4 */
-EXTERN void    TkBindEventProc (TkWindow * winPtr, 
-        XEvent * eventPtr);
-#endif
-#ifndef TkBindFree_TCL_DECLARED
-#define TkBindFree_TCL_DECLARED
+EXTERN void    TkBindEventProc(TkWindow *winPtr, XEvent *eventPtr);
 /* 5 */
-EXTERN void    TkBindFree (TkMainInfo * mainPtr);
-#endif
-#ifndef TkBindInit_TCL_DECLARED
-#define TkBindInit_TCL_DECLARED
+EXTERN void    TkBindFree(TkMainInfo *mainPtr);
 /* 6 */
-EXTERN void    TkBindInit (TkMainInfo * mainPtr);
-#endif
-#ifndef TkChangeEventWindow_TCL_DECLARED
-#define TkChangeEventWindow_TCL_DECLARED
+EXTERN void    TkBindInit(TkMainInfo *mainPtr);
 /* 7 */
-EXTERN void    TkChangeEventWindow (XEvent * eventPtr, 
-        TkWindow * winPtr);
-#endif
-#ifndef TkClipInit_TCL_DECLARED
-#define TkClipInit_TCL_DECLARED
+EXTERN void    TkChangeEventWindow(XEvent *eventPtr,
+        TkWindow *winPtr);
 /* 8 */
-EXTERN int    TkClipInit (Tcl_Interp * interp, TkDisplay * dispPtr);
-#endif
-#ifndef TkComputeAnchor_TCL_DECLARED
-#define TkComputeAnchor_TCL_DECLARED
+EXTERN int    TkClipInit(Tcl_Interp *interp, TkDisplay *dispPtr);
 /* 9 */
-EXTERN void    TkComputeAnchor (Tk_Anchor anchor, Tk_Window tkwin, 
-        int padX, int padY, int innerWidth, 
-        int innerHeight, int * xPtr, int * yPtr);
-#endif
-#ifndef TkCopyAndGlobalEval_TCL_DECLARED
-#define TkCopyAndGlobalEval_TCL_DECLARED
-/* 10 */
-EXTERN int    TkCopyAndGlobalEval (Tcl_Interp * interp, 
-        char * script);
-#endif
-#ifndef TkCreateBindingProcedure_TCL_DECLARED
-#define TkCreateBindingProcedure_TCL_DECLARED
-/* 11 */
-EXTERN unsigned long  TkCreateBindingProcedure (Tcl_Interp * interp, 
-        Tk_BindingTable bindingTable, 
-        ClientData object, CONST char * eventString, 
-        TkBindEvalProc * evalProc, 
-        TkBindFreeProc * freeProc, 
-        ClientData clientData);
-#endif
-#ifndef TkCreateCursorFromData_TCL_DECLARED
-#define TkCreateCursorFromData_TCL_DECLARED
+EXTERN void    TkComputeAnchor(Tk_Anchor anchor, Tk_Window tkwin,
+        int padX, int padY, int innerWidth,
+        int innerHeight, int *xPtr, int *yPtr);
+/* Slot 10 is reserved */
+/* Slot 11 is reserved */
 /* 12 */
-EXTERN TkCursor *  TkCreateCursorFromData (Tk_Window tkwin, 
-        CONST char * source, CONST char * mask, 
-        int width, int height, int xHot, int yHot, 
+EXTERN TkCursor *  TkCreateCursorFromData(Tk_Window tkwin,
+        const char *source, const char *mask,
+        int width, int height, int xHot, int yHot,
         XColor fg, XColor bg);
-#endif
-#ifndef TkCreateFrame_TCL_DECLARED
-#define TkCreateFrame_TCL_DECLARED
 /* 13 */
-EXTERN int    TkCreateFrame (ClientData clientData, 
-        Tcl_Interp * interp, int argc, char ** argv, 
-        int toplevel, char * appName);
-#endif
-#ifndef TkCreateMainWindow_TCL_DECLARED
-#define TkCreateMainWindow_TCL_DECLARED
+EXTERN int    TkCreateFrame(ClientData clientData,
+        Tcl_Interp *interp, int argc,
+        const char *const *argv, int toplevel,
+        const char *appName);
 /* 14 */
-EXTERN Tk_Window  TkCreateMainWindow (Tcl_Interp * interp, 
-        CONST char * screenName, char * baseName);
-#endif
-#ifndef TkCurrentTime_TCL_DECLARED
-#define TkCurrentTime_TCL_DECLARED
+EXTERN Tk_Window  TkCreateMainWindow(Tcl_Interp *interp,
+        const char *screenName, const char *baseName);
 /* 15 */
-EXTERN Time    TkCurrentTime (TkDisplay * dispPtr);
-#endif
-#ifndef TkDeleteAllImages_TCL_DECLARED
-#define TkDeleteAllImages_TCL_DECLARED
+EXTERN Time    TkCurrentTime(TkDisplay *dispPtr);
 /* 16 */
-EXTERN void    TkDeleteAllImages (TkMainInfo * mainPtr);
-#endif
-#ifndef TkDoConfigureNotify_TCL_DECLARED
-#define TkDoConfigureNotify_TCL_DECLARED
+EXTERN void    TkDeleteAllImages(TkMainInfo *mainPtr);
 /* 17 */
-EXTERN void    TkDoConfigureNotify (TkWindow * winPtr);
-#endif
-#ifndef TkDrawInsetFocusHighlight_TCL_DECLARED
-#define TkDrawInsetFocusHighlight_TCL_DECLARED
+EXTERN void    TkDoConfigureNotify(TkWindow *winPtr);
 /* 18 */
-EXTERN void    TkDrawInsetFocusHighlight (Tk_Window tkwin, GC gc, 
+EXTERN void    TkDrawInsetFocusHighlight(Tk_Window tkwin, GC gc,
         int width, Drawable drawable, int padding);
-#endif
-#ifndef TkEventDeadWindow_TCL_DECLARED
-#define TkEventDeadWindow_TCL_DECLARED
 /* 19 */
-EXTERN void    TkEventDeadWindow (TkWindow * winPtr);
-#endif
-#ifndef TkFillPolygon_TCL_DECLARED
-#define TkFillPolygon_TCL_DECLARED
+EXTERN void    TkEventDeadWindow(TkWindow *winPtr);
 /* 20 */
-EXTERN void    TkFillPolygon (Tk_Canvas canvas, double * coordPtr, 
-        int numPoints, Display * display, 
+EXTERN void    TkFillPolygon(Tk_Canvas canvas, double *coordPtr,
+        int numPoints, Display *display,
         Drawable drawable, GC gc, GC outlineGC);
-#endif
-#ifndef TkFindStateNum_TCL_DECLARED
-#define TkFindStateNum_TCL_DECLARED
 /* 21 */
-EXTERN int    TkFindStateNum (Tcl_Interp * interp, 
-        CONST char * option, 
-        CONST TkStateMap * mapPtr, 
-        CONST char * strKey);
-#endif
-#ifndef TkFindStateString_TCL_DECLARED
-#define TkFindStateString_TCL_DECLARED
+EXTERN int    TkFindStateNum(Tcl_Interp *interp,
+        const char *option, const TkStateMap *mapPtr,
+        const char *strKey);
 /* 22 */
-EXTERN char *    TkFindStateString (CONST TkStateMap * mapPtr, 
+EXTERN CONST86 char *  TkFindStateString(const TkStateMap *mapPtr,
         int numKey);
-#endif
-#ifndef TkFocusDeadWindow_TCL_DECLARED
-#define TkFocusDeadWindow_TCL_DECLARED
 /* 23 */
-EXTERN void    TkFocusDeadWindow (TkWindow * winPtr);
-#endif
-#ifndef TkFocusFilterEvent_TCL_DECLARED
-#define TkFocusFilterEvent_TCL_DECLARED
+EXTERN void    TkFocusDeadWindow(TkWindow *winPtr);
 /* 24 */
-EXTERN int    TkFocusFilterEvent (TkWindow * winPtr, 
-        XEvent * eventPtr);
-#endif
-#ifndef TkFocusKeyEvent_TCL_DECLARED
-#define TkFocusKeyEvent_TCL_DECLARED
+EXTERN int    TkFocusFilterEvent(TkWindow *winPtr,
+        XEvent *eventPtr);
 /* 25 */
-EXTERN TkWindow *  TkFocusKeyEvent (TkWindow * winPtr, 
-        XEvent * eventPtr);
-#endif
-#ifndef TkFontPkgInit_TCL_DECLARED
-#define TkFontPkgInit_TCL_DECLARED
+EXTERN TkWindow *  TkFocusKeyEvent(TkWindow *winPtr, XEvent *eventPtr);
 /* 26 */
-EXTERN void    TkFontPkgInit (TkMainInfo * mainPtr);
-#endif
-#ifndef TkFontPkgFree_TCL_DECLARED
-#define TkFontPkgFree_TCL_DECLARED
+EXTERN void    TkFontPkgInit(TkMainInfo *mainPtr);
 /* 27 */
-EXTERN void    TkFontPkgFree (TkMainInfo * mainPtr);
-#endif
-#ifndef TkFreeBindingTags_TCL_DECLARED
-#define TkFreeBindingTags_TCL_DECLARED
+EXTERN void    TkFontPkgFree(TkMainInfo *mainPtr);
 /* 28 */
-EXTERN void    TkFreeBindingTags (TkWindow * winPtr);
-#endif
-#ifndef TkpFreeCursor_TCL_DECLARED
-#define TkpFreeCursor_TCL_DECLARED
+EXTERN void    TkFreeBindingTags(TkWindow *winPtr);
 /* 29 */
-EXTERN void    TkpFreeCursor (TkCursor * cursorPtr);
-#endif
-#ifndef TkGetBitmapData_TCL_DECLARED
-#define TkGetBitmapData_TCL_DECLARED
+EXTERN void    TkpFreeCursor(TkCursor *cursorPtr);
 /* 30 */
-EXTERN char *    TkGetBitmapData (Tcl_Interp * interp, char * string, 
-        char * fileName, int * widthPtr, 
-        int * heightPtr, int * hotXPtr, 
-        int * hotYPtr);
-#endif
-#ifndef TkGetButtPoints_TCL_DECLARED
-#define TkGetButtPoints_TCL_DECLARED
+EXTERN char *    TkGetBitmapData(Tcl_Interp *interp,
+        const char *string, const char *fileName,
+        int *widthPtr, int *heightPtr, int *hotXPtr,
+        int *hotYPtr);
 /* 31 */
-EXTERN void    TkGetButtPoints (double p1[], double p2[], 
-        double width, int project, double m1[], 
+EXTERN void    TkGetButtPoints(double p1[], double p2[],
+        double width, int project, double m1[],
         double m2[]);
-#endif
-#ifndef TkGetCursorByName_TCL_DECLARED
-#define TkGetCursorByName_TCL_DECLARED
 /* 32 */
-EXTERN TkCursor *  TkGetCursorByName (Tcl_Interp * interp, 
+EXTERN TkCursor *  TkGetCursorByName(Tcl_Interp *interp,
         Tk_Window tkwin, Tk_Uid string);
-#endif
-#ifndef TkGetDefaultScreenName_TCL_DECLARED
-#define TkGetDefaultScreenName_TCL_DECLARED
 /* 33 */
-EXTERN CONST84_RETURN char * TkGetDefaultScreenName (Tcl_Interp * interp, 
-        CONST char * screenName);
-#endif
-#ifndef TkGetDisplay_TCL_DECLARED
-#define TkGetDisplay_TCL_DECLARED
+EXTERN const char *  TkGetDefaultScreenName(Tcl_Interp *interp,
+        const char *screenName);
 /* 34 */
-EXTERN TkDisplay *  TkGetDisplay (Display * display);
-#endif
-#ifndef TkGetDisplayOf_TCL_DECLARED
-#define TkGetDisplayOf_TCL_DECLARED
+EXTERN TkDisplay *  TkGetDisplay(Display *display);
 /* 35 */
-EXTERN int    TkGetDisplayOf (Tcl_Interp * interp, int objc, 
-        Tcl_Obj *CONST objv[], Tk_Window * tkwinPtr);
-#endif
-#ifndef TkGetFocusWin_TCL_DECLARED
-#define TkGetFocusWin_TCL_DECLARED
+EXTERN int    TkGetDisplayOf(Tcl_Interp *interp, int objc,
+        Tcl_Obj *const objv[], Tk_Window *tkwinPtr);
 /* 36 */
-EXTERN TkWindow *  TkGetFocusWin (TkWindow * winPtr);
-#endif
-#ifndef TkGetInterpNames_TCL_DECLARED
-#define TkGetInterpNames_TCL_DECLARED
+EXTERN TkWindow *  TkGetFocusWin(TkWindow *winPtr);
 /* 37 */
-EXTERN int    TkGetInterpNames (Tcl_Interp * interp, 
-        Tk_Window tkwin);
-#endif
-#ifndef TkGetMiterPoints_TCL_DECLARED
-#define TkGetMiterPoints_TCL_DECLARED
+EXTERN int    TkGetInterpNames(Tcl_Interp *interp, Tk_Window tkwin);
 /* 38 */
-EXTERN int    TkGetMiterPoints (double p1[], double p2[], 
-        double p3[], double width, double m1[], 
+EXTERN int    TkGetMiterPoints(double p1[], double p2[],
+        double p3[], double width, double m1[],
         double m2[]);
-#endif
-#ifndef TkGetPointerCoords_TCL_DECLARED
-#define TkGetPointerCoords_TCL_DECLARED
 /* 39 */
-EXTERN void    TkGetPointerCoords (Tk_Window tkwin, int * xPtr, 
-        int * yPtr);
-#endif
-#ifndef TkGetServerInfo_TCL_DECLARED
-#define TkGetServerInfo_TCL_DECLARED
+EXTERN void    TkGetPointerCoords(Tk_Window tkwin, int *xPtr,
+        int *yPtr);
 /* 40 */
-EXTERN void    TkGetServerInfo (Tcl_Interp * interp, 
-        Tk_Window tkwin);
-#endif
-#ifndef TkGrabDeadWindow_TCL_DECLARED
-#define TkGrabDeadWindow_TCL_DECLARED
+EXTERN void    TkGetServerInfo(Tcl_Interp *interp, Tk_Window tkwin);
 /* 41 */
-EXTERN void    TkGrabDeadWindow (TkWindow * winPtr);
-#endif
-#ifndef TkGrabState_TCL_DECLARED
-#define TkGrabState_TCL_DECLARED
+EXTERN void    TkGrabDeadWindow(TkWindow *winPtr);
 /* 42 */
-EXTERN int    TkGrabState (TkWindow * winPtr);
-#endif
-#ifndef TkIncludePoint_TCL_DECLARED
-#define TkIncludePoint_TCL_DECLARED
+EXTERN int    TkGrabState(TkWindow *winPtr);
 /* 43 */
-EXTERN void    TkIncludePoint (Tk_Item * itemPtr, double * pointPtr);
-#endif
-#ifndef TkInOutEvents_TCL_DECLARED
-#define TkInOutEvents_TCL_DECLARED
+EXTERN void    TkIncludePoint(Tk_Item *itemPtr, double *pointPtr);
 /* 44 */
-EXTERN void    TkInOutEvents (XEvent * eventPtr, 
-        TkWindow * sourcePtr, TkWindow * destPtr, 
-        int leaveType, int enterType, 
-        Tcl_QueuePosition position);
-#endif
-#ifndef TkInstallFrameMenu_TCL_DECLARED
-#define TkInstallFrameMenu_TCL_DECLARED
+EXTERN void    TkInOutEvents(XEvent *eventPtr, TkWindow *sourcePtr,
+        TkWindow *destPtr, int leaveType,
+        int enterType, Tcl_QueuePosition position);
 /* 45 */
-EXTERN void    TkInstallFrameMenu (Tk_Window tkwin);
-#endif
-#ifndef TkKeysymToString_TCL_DECLARED
-#define TkKeysymToString_TCL_DECLARED
+EXTERN void    TkInstallFrameMenu(Tk_Window tkwin);
 /* 46 */
-EXTERN char *    TkKeysymToString (KeySym keysym);
-#endif
-#ifndef TkLineToArea_TCL_DECLARED
-#define TkLineToArea_TCL_DECLARED
+EXTERN CONST86 char *  TkKeysymToString(KeySym keysym);
 /* 47 */
-EXTERN int    TkLineToArea (double end1Ptr[], double end2Ptr[], 
+EXTERN int    TkLineToArea(double end1Ptr[], double end2Ptr[],
         double rectPtr[]);
-#endif
-#ifndef TkLineToPoint_TCL_DECLARED
-#define TkLineToPoint_TCL_DECLARED
 /* 48 */
-EXTERN double    TkLineToPoint (double end1Ptr[], double end2Ptr[], 
+EXTERN double    TkLineToPoint(double end1Ptr[], double end2Ptr[],
         double pointPtr[]);
-#endif
-#ifndef TkMakeBezierCurve_TCL_DECLARED
-#define TkMakeBezierCurve_TCL_DECLARED
 /* 49 */
-EXTERN int    TkMakeBezierCurve (Tk_Canvas canvas, 
-        double * pointPtr, int numPoints, 
-        int numSteps, XPoint xPoints[], 
-        double dblPoints[]);
-#endif
-#ifndef TkMakeBezierPostscript_TCL_DECLARED
-#define TkMakeBezierPostscript_TCL_DECLARED
+EXTERN int    TkMakeBezierCurve(Tk_Canvas canvas, double *pointPtr,
+        int numPoints, int numSteps,
+        XPoint xPoints[], double dblPoints[]);
 /* 50 */
-EXTERN void    TkMakeBezierPostscript (Tcl_Interp * interp, 
-        Tk_Canvas canvas, double * pointPtr, 
+EXTERN void    TkMakeBezierPostscript(Tcl_Interp *interp,
+        Tk_Canvas canvas, double *pointPtr,
         int numPoints);
-#endif
-#ifndef TkOptionClassChanged_TCL_DECLARED
-#define TkOptionClassChanged_TCL_DECLARED
 /* 51 */
-EXTERN void    TkOptionClassChanged (TkWindow * winPtr);
-#endif
-#ifndef TkOptionDeadWindow_TCL_DECLARED
-#define TkOptionDeadWindow_TCL_DECLARED
+EXTERN void    TkOptionClassChanged(TkWindow *winPtr);
 /* 52 */
-EXTERN void    TkOptionDeadWindow (TkWindow * winPtr);
-#endif
-#ifndef TkOvalToArea_TCL_DECLARED
-#define TkOvalToArea_TCL_DECLARED
+EXTERN void    TkOptionDeadWindow(TkWindow *winPtr);
 /* 53 */
-EXTERN int    TkOvalToArea (double * ovalPtr, double * rectPtr);
-#endif
-#ifndef TkOvalToPoint_TCL_DECLARED
-#define TkOvalToPoint_TCL_DECLARED
+EXTERN int    TkOvalToArea(double *ovalPtr, double *rectPtr);
 /* 54 */
-EXTERN double    TkOvalToPoint (double ovalPtr[], double width, 
+EXTERN double    TkOvalToPoint(double ovalPtr[], double width,
         int filled, double pointPtr[]);
-#endif
-#ifndef TkpChangeFocus_TCL_DECLARED
-#define TkpChangeFocus_TCL_DECLARED
 /* 55 */
-EXTERN int    TkpChangeFocus (TkWindow * winPtr, int force);
-#endif
-#ifndef TkpCloseDisplay_TCL_DECLARED
-#define TkpCloseDisplay_TCL_DECLARED
+EXTERN int    TkpChangeFocus(TkWindow *winPtr, int force);
 /* 56 */
-EXTERN void    TkpCloseDisplay (TkDisplay * dispPtr);
-#endif
-#ifndef TkpClaimFocus_TCL_DECLARED
-#define TkpClaimFocus_TCL_DECLARED
+EXTERN void    TkpCloseDisplay(TkDisplay *dispPtr);
 /* 57 */
-EXTERN void    TkpClaimFocus (TkWindow * topLevelPtr, int force);
-#endif
-#ifndef TkpDisplayWarning_TCL_DECLARED
-#define TkpDisplayWarning_TCL_DECLARED
+EXTERN void    TkpClaimFocus(TkWindow *topLevelPtr, int force);
 /* 58 */
-EXTERN void    TkpDisplayWarning (CONST char * msg, 
-        CONST char * title);
-#endif
-#ifndef TkpGetAppName_TCL_DECLARED
-#define TkpGetAppName_TCL_DECLARED
+EXTERN void    TkpDisplayWarning(const char *msg, const char *title);
 /* 59 */
-EXTERN void    TkpGetAppName (Tcl_Interp * interp, 
-        Tcl_DString * name);
-#endif
-#ifndef TkpGetOtherWindow_TCL_DECLARED
-#define TkpGetOtherWindow_TCL_DECLARED
+EXTERN void    TkpGetAppName(Tcl_Interp *interp, Tcl_DString *name);
 /* 60 */
-EXTERN TkWindow *  TkpGetOtherWindow (TkWindow * winPtr);
-#endif
-#ifndef TkpGetWrapperWindow_TCL_DECLARED
-#define TkpGetWrapperWindow_TCL_DECLARED
+EXTERN TkWindow *  TkpGetOtherWindow(TkWindow *winPtr);
 /* 61 */
-EXTERN TkWindow *  TkpGetWrapperWindow (TkWindow * winPtr);
-#endif
-#ifndef TkpInit_TCL_DECLARED
-#define TkpInit_TCL_DECLARED
+EXTERN TkWindow *  TkpGetWrapperWindow(TkWindow *winPtr);
 /* 62 */
-EXTERN int    TkpInit (Tcl_Interp * interp);
-#endif
-#ifndef TkpInitializeMenuBindings_TCL_DECLARED
-#define TkpInitializeMenuBindings_TCL_DECLARED
+EXTERN int    TkpInit(Tcl_Interp *interp);
 /* 63 */
-EXTERN void    TkpInitializeMenuBindings (Tcl_Interp * interp, 
+EXTERN void    TkpInitializeMenuBindings(Tcl_Interp *interp,
         Tk_BindingTable bindingTable);
-#endif
-#ifndef TkpMakeContainer_TCL_DECLARED
-#define TkpMakeContainer_TCL_DECLARED
 /* 64 */
-EXTERN void    TkpMakeContainer (Tk_Window tkwin);
-#endif
-#ifndef TkpMakeMenuWindow_TCL_DECLARED
-#define TkpMakeMenuWindow_TCL_DECLARED
+EXTERN void    TkpMakeContainer(Tk_Window tkwin);
 /* 65 */
-EXTERN void    TkpMakeMenuWindow (Tk_Window tkwin, int transient);
-#endif
-#ifndef TkpMakeWindow_TCL_DECLARED
-#define TkpMakeWindow_TCL_DECLARED
+EXTERN void    TkpMakeMenuWindow(Tk_Window tkwin, int transient);
 /* 66 */
-EXTERN Window    TkpMakeWindow (TkWindow * winPtr, Window parent);
-#endif
-#ifndef TkpMenuNotifyToplevelCreate_TCL_DECLARED
-#define TkpMenuNotifyToplevelCreate_TCL_DECLARED
+EXTERN Window    TkpMakeWindow(TkWindow *winPtr, Window parent);
 /* 67 */
-EXTERN void    TkpMenuNotifyToplevelCreate (Tcl_Interp * interp1, 
-        char * menuName);
-#endif
-#ifndef TkpOpenDisplay_TCL_DECLARED
-#define TkpOpenDisplay_TCL_DECLARED
+EXTERN void    TkpMenuNotifyToplevelCreate(Tcl_Interp *interp,
+        const char *menuName);
 /* 68 */
-EXTERN TkDisplay *  TkpOpenDisplay (CONST char * display_name);
-#endif
-#ifndef TkPointerEvent_TCL_DECLARED
-#define TkPointerEvent_TCL_DECLARED
+EXTERN TkDisplay *  TkpOpenDisplay(const char *display_name);
 /* 69 */
-EXTERN int    TkPointerEvent (XEvent * eventPtr, TkWindow * winPtr);
-#endif
-#ifndef TkPolygonToArea_TCL_DECLARED
-#define TkPolygonToArea_TCL_DECLARED
+EXTERN int    TkPointerEvent(XEvent *eventPtr, TkWindow *winPtr);
 /* 70 */
-EXTERN int    TkPolygonToArea (double * polyPtr, int numPoints, 
-        double * rectPtr);
-#endif
-#ifndef TkPolygonToPoint_TCL_DECLARED
-#define TkPolygonToPoint_TCL_DECLARED
+EXTERN int    TkPolygonToArea(double *polyPtr, int numPoints,
+        double *rectPtr);
 /* 71 */
-EXTERN double    TkPolygonToPoint (double * polyPtr, int numPoints, 
-        double * pointPtr);
-#endif
-#ifndef TkPositionInTree_TCL_DECLARED
-#define TkPositionInTree_TCL_DECLARED
+EXTERN double    TkPolygonToPoint(double *polyPtr, int numPoints,
+        double *pointPtr);
 /* 72 */
-EXTERN int    TkPositionInTree (TkWindow * winPtr, 
-        TkWindow * treePtr);
-#endif
-#ifndef TkpRedirectKeyEvent_TCL_DECLARED
-#define TkpRedirectKeyEvent_TCL_DECLARED
+EXTERN int    TkPositionInTree(TkWindow *winPtr, TkWindow *treePtr);
 /* 73 */
-EXTERN void    TkpRedirectKeyEvent (TkWindow * winPtr, 
-        XEvent * eventPtr);
-#endif
-#ifndef TkpSetMainMenubar_TCL_DECLARED
-#define TkpSetMainMenubar_TCL_DECLARED
+EXTERN void    TkpRedirectKeyEvent(TkWindow *winPtr,
+        XEvent *eventPtr);
 /* 74 */
-EXTERN void    TkpSetMainMenubar (Tcl_Interp * interp, 
-        Tk_Window tkwin, char * menuName);
-#endif
-#ifndef TkpUseWindow_TCL_DECLARED
-#define TkpUseWindow_TCL_DECLARED
+EXTERN void    TkpSetMainMenubar(Tcl_Interp *interp,
+        Tk_Window tkwin, const char *menuName);
 /* 75 */
-EXTERN int    TkpUseWindow (Tcl_Interp * interp, Tk_Window tkwin, 
-        CONST char * string);
-#endif
+EXTERN int    TkpUseWindow(Tcl_Interp *interp, Tk_Window tkwin,
+        const char *string);
 /* Slot 76 is reserved */
-#ifndef TkQueueEventForAllChildren_TCL_DECLARED
-#define TkQueueEventForAllChildren_TCL_DECLARED
 /* 77 */
-EXTERN void    TkQueueEventForAllChildren (TkWindow * winPtr, 
-        XEvent * eventPtr);
-#endif
-#ifndef TkReadBitmapFile_TCL_DECLARED
-#define TkReadBitmapFile_TCL_DECLARED
+EXTERN void    TkQueueEventForAllChildren(TkWindow *winPtr,
+        XEvent *eventPtr);
 /* 78 */
-EXTERN int    TkReadBitmapFile (Display * display, Drawable d, 
-        CONST char * filename, 
-        unsigned int * width_return, 
-        unsigned int * height_return, 
-        Pixmap * bitmap_return, int * x_hot_return, 
-        int * y_hot_return);
-#endif
-#ifndef TkScrollWindow_TCL_DECLARED
-#define TkScrollWindow_TCL_DECLARED
+EXTERN int    TkReadBitmapFile(Display *display, Drawable d,
+        const char *filename,
+        unsigned int *width_return,
+        unsigned int *height_return,
+        Pixmap *bitmap_return, int *x_hot_return,
+        int *y_hot_return);
 /* 79 */
-EXTERN int    TkScrollWindow (Tk_Window tkwin, GC gc, int x, int y, 
-        int width, int height, int dx, int dy, 
+EXTERN int    TkScrollWindow(Tk_Window tkwin, GC gc, int x, int y,
+        int width, int height, int dx, int dy,
         TkRegion damageRgn);
-#endif
-#ifndef TkSelDeadWindow_TCL_DECLARED
-#define TkSelDeadWindow_TCL_DECLARED
 /* 80 */
-EXTERN void    TkSelDeadWindow (TkWindow * winPtr);
-#endif
-#ifndef TkSelEventProc_TCL_DECLARED
-#define TkSelEventProc_TCL_DECLARED
+EXTERN void    TkSelDeadWindow(TkWindow *winPtr);
 /* 81 */
-EXTERN void    TkSelEventProc (Tk_Window tkwin, XEvent * eventPtr);
-#endif
-#ifndef TkSelInit_TCL_DECLARED
-#define TkSelInit_TCL_DECLARED
+EXTERN void    TkSelEventProc(Tk_Window tkwin, XEvent *eventPtr);
 /* 82 */
-EXTERN void    TkSelInit (Tk_Window tkwin);
-#endif
-#ifndef TkSelPropProc_TCL_DECLARED
-#define TkSelPropProc_TCL_DECLARED
+EXTERN void    TkSelInit(Tk_Window tkwin);
 /* 83 */
-EXTERN void    TkSelPropProc (XEvent * eventPtr);
-#endif
+EXTERN void    TkSelPropProc(XEvent *eventPtr);
 /* Slot 84 is reserved */
-#ifndef TkSetWindowMenuBar_TCL_DECLARED
-#define TkSetWindowMenuBar_TCL_DECLARED
 /* 85 */
-EXTERN void    TkSetWindowMenuBar (Tcl_Interp * interp, 
-        Tk_Window tkwin, char * oldMenuName, 
-        char * menuName);
-#endif
-#ifndef TkStringToKeysym_TCL_DECLARED
-#define TkStringToKeysym_TCL_DECLARED
+EXTERN void    TkSetWindowMenuBar(Tcl_Interp *interp,
+        Tk_Window tkwin, const char *oldMenuName,
+        const char *menuName);
 /* 86 */
-EXTERN KeySym    TkStringToKeysym (char * name);
-#endif
-#ifndef TkThickPolyLineToArea_TCL_DECLARED
-#define TkThickPolyLineToArea_TCL_DECLARED
+EXTERN KeySym    TkStringToKeysym(const char *name);
 /* 87 */
-EXTERN int    TkThickPolyLineToArea (double * coordPtr, 
-        int numPoints, double width, int capStyle, 
-        int joinStyle, double * rectPtr);
-#endif
-#ifndef TkWmAddToColormapWindows_TCL_DECLARED
-#define TkWmAddToColormapWindows_TCL_DECLARED
+EXTERN int    TkThickPolyLineToArea(double *coordPtr,
+        int numPoints, double width, int capStyle,
+        int joinStyle, double *rectPtr);
 /* 88 */
-EXTERN void    TkWmAddToColormapWindows (TkWindow * winPtr);
-#endif
-#ifndef TkWmDeadWindow_TCL_DECLARED
-#define TkWmDeadWindow_TCL_DECLARED
+EXTERN void    TkWmAddToColormapWindows(TkWindow *winPtr);
 /* 89 */
-EXTERN void    TkWmDeadWindow (TkWindow * winPtr);
-#endif
-#ifndef TkWmFocusToplevel_TCL_DECLARED
-#define TkWmFocusToplevel_TCL_DECLARED
+EXTERN void    TkWmDeadWindow(TkWindow *winPtr);
 /* 90 */
-EXTERN TkWindow *  TkWmFocusToplevel (TkWindow * winPtr);
-#endif
-#ifndef TkWmMapWindow_TCL_DECLARED
-#define TkWmMapWindow_TCL_DECLARED
+EXTERN TkWindow *  TkWmFocusToplevel(TkWindow *winPtr);
 /* 91 */
-EXTERN void    TkWmMapWindow (TkWindow * winPtr);
-#endif
-#ifndef TkWmNewWindow_TCL_DECLARED
-#define TkWmNewWindow_TCL_DECLARED
+EXTERN void    TkWmMapWindow(TkWindow *winPtr);
 /* 92 */
-EXTERN void    TkWmNewWindow (TkWindow * winPtr);
-#endif
-#ifndef TkWmProtocolEventProc_TCL_DECLARED
-#define TkWmProtocolEventProc_TCL_DECLARED
+EXTERN void    TkWmNewWindow(TkWindow *winPtr);
 /* 93 */
-EXTERN void    TkWmProtocolEventProc (TkWindow * winPtr, 
-        XEvent * evenvPtr);
-#endif
-#ifndef TkWmRemoveFromColormapWindows_TCL_DECLARED
-#define TkWmRemoveFromColormapWindows_TCL_DECLARED
+EXTERN void    TkWmProtocolEventProc(TkWindow *winPtr,
+        XEvent *evenvPtr);
 /* 94 */
-EXTERN void    TkWmRemoveFromColormapWindows (TkWindow * winPtr);
-#endif
-#ifndef TkWmRestackToplevel_TCL_DECLARED
-#define TkWmRestackToplevel_TCL_DECLARED
+EXTERN void    TkWmRemoveFromColormapWindows(TkWindow *winPtr);
 /* 95 */
-EXTERN void    TkWmRestackToplevel (TkWindow * winPtr, 
-        int aboveBelow, TkWindow * otherPtr);
-#endif
-#ifndef TkWmSetClass_TCL_DECLARED
-#define TkWmSetClass_TCL_DECLARED
+EXTERN void    TkWmRestackToplevel(TkWindow *winPtr, int aboveBelow,
+        TkWindow *otherPtr);
 /* 96 */
-EXTERN void    TkWmSetClass (TkWindow * winPtr);
-#endif
-#ifndef TkWmUnmapWindow_TCL_DECLARED
-#define TkWmUnmapWindow_TCL_DECLARED
+EXTERN void    TkWmSetClass(TkWindow *winPtr);
 /* 97 */
-EXTERN void    TkWmUnmapWindow (TkWindow * winPtr);
-#endif
-#ifndef TkDebugBitmap_TCL_DECLARED
-#define TkDebugBitmap_TCL_DECLARED
+EXTERN void    TkWmUnmapWindow(TkWindow *winPtr);
 /* 98 */
-EXTERN Tcl_Obj *  TkDebugBitmap (Tk_Window tkwin, char * name);
-#endif
-#ifndef TkDebugBorder_TCL_DECLARED
-#define TkDebugBorder_TCL_DECLARED
+EXTERN Tcl_Obj *  TkDebugBitmap(Tk_Window tkwin, const char *name);
 /* 99 */
-EXTERN Tcl_Obj *  TkDebugBorder (Tk_Window tkwin, char * name);
-#endif
-#ifndef TkDebugCursor_TCL_DECLARED
-#define TkDebugCursor_TCL_DECLARED
+EXTERN Tcl_Obj *  TkDebugBorder(Tk_Window tkwin, const char *name);
 /* 100 */
-EXTERN Tcl_Obj *  TkDebugCursor (Tk_Window tkwin, char * name);
-#endif
-#ifndef TkDebugColor_TCL_DECLARED
-#define TkDebugColor_TCL_DECLARED
+EXTERN Tcl_Obj *  TkDebugCursor(Tk_Window tkwin, const char *name);
 /* 101 */
-EXTERN Tcl_Obj *  TkDebugColor (Tk_Window tkwin, char * name);
-#endif
-#ifndef TkDebugConfig_TCL_DECLARED
-#define TkDebugConfig_TCL_DECLARED
+EXTERN Tcl_Obj *  TkDebugColor(Tk_Window tkwin, const char *name);
 /* 102 */
-EXTERN Tcl_Obj *  TkDebugConfig (Tcl_Interp * interp, 
+EXTERN Tcl_Obj *  TkDebugConfig(Tcl_Interp *interp,
         Tk_OptionTable table);
-#endif
-#ifndef TkDebugFont_TCL_DECLARED
-#define TkDebugFont_TCL_DECLARED
 /* 103 */
-EXTERN Tcl_Obj *  TkDebugFont (Tk_Window tkwin, char * name);
-#endif
-#ifndef TkFindStateNumObj_TCL_DECLARED
-#define TkFindStateNumObj_TCL_DECLARED
+EXTERN Tcl_Obj *  TkDebugFont(Tk_Window tkwin, const char *name);
 /* 104 */
-EXTERN int    TkFindStateNumObj (Tcl_Interp * interp, 
-        Tcl_Obj * optionPtr, 
-        CONST TkStateMap * mapPtr, Tcl_Obj * keyPtr);
-#endif
-#ifndef TkGetBitmapPredefTable_TCL_DECLARED
-#define TkGetBitmapPredefTable_TCL_DECLARED
+EXTERN int    TkFindStateNumObj(Tcl_Interp *interp,
+        Tcl_Obj *optionPtr, const TkStateMap *mapPtr,
+        Tcl_Obj *keyPtr);
 /* 105 */
-EXTERN Tcl_HashTable *  TkGetBitmapPredefTable (void);
-#endif
-#ifndef TkGetDisplayList_TCL_DECLARED
-#define TkGetDisplayList_TCL_DECLARED
+EXTERN Tcl_HashTable *  TkGetBitmapPredefTable(void);
 /* 106 */
-EXTERN TkDisplay *  TkGetDisplayList (void);
-#endif
-#ifndef TkGetMainInfoList_TCL_DECLARED
-#define TkGetMainInfoList_TCL_DECLARED
+EXTERN TkDisplay *  TkGetDisplayList(void);
 /* 107 */
-EXTERN TkMainInfo *  TkGetMainInfoList (void);
-#endif
-#ifndef TkGetWindowFromObj_TCL_DECLARED
-#define TkGetWindowFromObj_TCL_DECLARED
+EXTERN TkMainInfo *  TkGetMainInfoList(void);
 /* 108 */
-EXTERN int    TkGetWindowFromObj (Tcl_Interp * interp, 
-        Tk_Window tkwin, Tcl_Obj * objPtr, 
-        Tk_Window * windowPtr);
-#endif
-#ifndef TkpGetString_TCL_DECLARED
-#define TkpGetString_TCL_DECLARED
+EXTERN int    TkGetWindowFromObj(Tcl_Interp *interp,
+        Tk_Window tkwin, Tcl_Obj *objPtr,
+        Tk_Window *windowPtr);
 /* 109 */
-EXTERN char *    TkpGetString (TkWindow * winPtr, XEvent * eventPtr, 
-        Tcl_DString * dsPtr);
-#endif
-#ifndef TkpGetSubFonts_TCL_DECLARED
-#define TkpGetSubFonts_TCL_DECLARED
+EXTERN CONST86 char *  TkpGetString(TkWindow *winPtr, XEvent *eventPtr,
+        Tcl_DString *dsPtr);
 /* 110 */
-EXTERN void    TkpGetSubFonts (Tcl_Interp * interp, Tk_Font tkfont);
-#endif
-#ifndef TkpGetSystemDefault_TCL_DECLARED
-#define TkpGetSystemDefault_TCL_DECLARED
+EXTERN void    TkpGetSubFonts(Tcl_Interp *interp, Tk_Font tkfont);
 /* 111 */
-EXTERN Tcl_Obj *  TkpGetSystemDefault (Tk_Window tkwin, 
-        CONST char * dbName, CONST char * className);
-#endif
-#ifndef TkpMenuThreadInit_TCL_DECLARED
-#define TkpMenuThreadInit_TCL_DECLARED
+EXTERN Tcl_Obj *  TkpGetSystemDefault(Tk_Window tkwin,
+        const char *dbName, const char *className);
 /* 112 */
-EXTERN void    TkpMenuThreadInit (void);
-#endif
-#ifdef __WIN32__ /* WIN */
-#ifndef TkClipBox_TCL_DECLARED
-#define TkClipBox_TCL_DECLARED
-/* 113 */
-EXTERN void    TkClipBox (TkRegion rgn, XRectangle * rect_return);
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkClipBox_TCL_DECLARED
-#define TkClipBox_TCL_DECLARED
+EXTERN void    TkpMenuThreadInit(void);
 /* 113 */
-EXTERN void    TkClipBox (TkRegion rgn, XRectangle * rect_return);
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkCreateRegion_TCL_DECLARED
-#define TkCreateRegion_TCL_DECLARED
-/* 114 */
-EXTERN TkRegion    TkCreateRegion (void);
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkCreateRegion_TCL_DECLARED
-#define TkCreateRegion_TCL_DECLARED
+EXTERN void    TkClipBox(TkRegion rgn, XRectangle *rect_return);
 /* 114 */
-EXTERN TkRegion    TkCreateRegion (void);
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkDestroyRegion_TCL_DECLARED
-#define TkDestroyRegion_TCL_DECLARED
-/* 115 */
-EXTERN void    TkDestroyRegion (TkRegion rgn);
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkDestroyRegion_TCL_DECLARED
-#define TkDestroyRegion_TCL_DECLARED
+EXTERN TkRegion    TkCreateRegion(void);
 /* 115 */
-EXTERN void    TkDestroyRegion (TkRegion rgn);
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkIntersectRegion_TCL_DECLARED
-#define TkIntersectRegion_TCL_DECLARED
+EXTERN void    TkDestroyRegion(TkRegion rgn);
 /* 116 */
-EXTERN void    TkIntersectRegion (TkRegion sra, TkRegion srcb, 
+EXTERN void    TkIntersectRegion(TkRegion sra, TkRegion srcb,
         TkRegion dr_return);
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkIntersectRegion_TCL_DECLARED
-#define TkIntersectRegion_TCL_DECLARED
-/* 116 */
-EXTERN void    TkIntersectRegion (TkRegion sra, TkRegion srcb, 
-        TkRegion dr_return);
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkRectInRegion_TCL_DECLARED
-#define TkRectInRegion_TCL_DECLARED
-/* 117 */
-EXTERN int    TkRectInRegion (TkRegion rgn, int x, int y, 
-        unsigned int width, unsigned int height);
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkRectInRegion_TCL_DECLARED
-#define TkRectInRegion_TCL_DECLARED
 /* 117 */
-EXTERN int    TkRectInRegion (TkRegion rgn, int x, int y, 
+EXTERN int    TkRectInRegion(TkRegion rgn, int x, int y,
         unsigned int width, unsigned int height);
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkSetRegion_TCL_DECLARED
-#define TkSetRegion_TCL_DECLARED
-/* 118 */
-EXTERN void    TkSetRegion (Display * display, GC gc, TkRegion rgn);
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkSetRegion_TCL_DECLARED
-#define TkSetRegion_TCL_DECLARED
 /* 118 */
-EXTERN void    TkSetRegion (Display * display, GC gc, TkRegion rgn);
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkUnionRectWithRegion_TCL_DECLARED
-#define TkUnionRectWithRegion_TCL_DECLARED
+EXTERN void    TkSetRegion(Display *display, GC gc, TkRegion rgn);
 /* 119 */
-EXTERN void    TkUnionRectWithRegion (XRectangle * rect, 
-        TkRegion src, TkRegion dr_return);
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkUnionRectWithRegion_TCL_DECLARED
-#define TkUnionRectWithRegion_TCL_DECLARED
-/* 119 */
-EXTERN void    TkUnionRectWithRegion (XRectangle * rect, 
-        TkRegion src, TkRegion dr_return);
-#endif
-#endif /* AQUA */
+EXTERN void    TkUnionRectWithRegion(XRectangle *rect, TkRegion src,
+        TkRegion dr_return);
 /* Slot 120 is reserved */
 #ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkpCreateNativeBitmap_TCL_DECLARED
-#define TkpCreateNativeBitmap_TCL_DECLARED
 /* 121 */
-EXTERN Pixmap    TkpCreateNativeBitmap (Display * display, 
-        CONST char * source);
-#endif
+EXTERN Pixmap    TkpCreateNativeBitmap(Display *display,
+        const void *source);
 #endif /* AQUA */
 #ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkpDefineNativeBitmaps_TCL_DECLARED
-#define TkpDefineNativeBitmaps_TCL_DECLARED
 /* 122 */
-EXTERN void    TkpDefineNativeBitmaps (void);
-#endif
+EXTERN void    TkpDefineNativeBitmaps(void);
 #endif /* AQUA */
 /* Slot 123 is reserved */
 #ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkpGetNativeAppBitmap_TCL_DECLARED
-#define TkpGetNativeAppBitmap_TCL_DECLARED
 /* 124 */
-EXTERN Pixmap    TkpGetNativeAppBitmap (Display * display, 
-        CONST char * name, int * width, int * height);
-#endif
+EXTERN Pixmap    TkpGetNativeAppBitmap(Display *display,
+        const char *name, int *width, int *height);
 #endif /* AQUA */
 /* Slot 125 is reserved */
 /* Slot 126 is reserved */
@@ -814,968 +372,661 @@
 /* Slot 132 is reserved */
 /* Slot 133 is reserved */
 /* Slot 134 is reserved */
-#ifndef TkpDrawHighlightBorder_TCL_DECLARED
-#define TkpDrawHighlightBorder_TCL_DECLARED
 /* 135 */
-EXTERN void    TkpDrawHighlightBorder (Tk_Window tkwin, GC fgGC, 
-        GC bgGC, int highlightWidth, 
+EXTERN void    TkpDrawHighlightBorder(Tk_Window tkwin, GC fgGC,
+        GC bgGC, int highlightWidth,
         Drawable drawable);
-#endif
-#ifndef TkSetFocusWin_TCL_DECLARED
-#define TkSetFocusWin_TCL_DECLARED
 /* 136 */
-EXTERN void    TkSetFocusWin (TkWindow * winPtr, int force);
-#endif
-#ifndef TkpSetKeycodeAndState_TCL_DECLARED
-#define TkpSetKeycodeAndState_TCL_DECLARED
+EXTERN void    TkSetFocusWin(TkWindow *winPtr, int force);
 /* 137 */
-EXTERN void    TkpSetKeycodeAndState (Tk_Window tkwin, 
-        KeySym keySym, XEvent * eventPtr);
-#endif
-#ifndef TkpGetKeySym_TCL_DECLARED
-#define TkpGetKeySym_TCL_DECLARED
+EXTERN void    TkpSetKeycodeAndState(Tk_Window tkwin, KeySym keySym,
+        XEvent *eventPtr);
 /* 138 */
-EXTERN KeySym    TkpGetKeySym (TkDisplay * dispPtr, XEvent * eventPtr);
-#endif
-#ifndef TkpInitKeymapInfo_TCL_DECLARED
-#define TkpInitKeymapInfo_TCL_DECLARED
+EXTERN KeySym    TkpGetKeySym(TkDisplay *dispPtr, XEvent *eventPtr);
 /* 139 */
-EXTERN void    TkpInitKeymapInfo (TkDisplay * dispPtr);
-#endif
-#ifndef TkPhotoGetValidRegion_TCL_DECLARED
-#define TkPhotoGetValidRegion_TCL_DECLARED
+EXTERN void    TkpInitKeymapInfo(TkDisplay *dispPtr);
 /* 140 */
-EXTERN TkRegion    TkPhotoGetValidRegion (Tk_PhotoHandle handle);
-#endif
-#ifndef TkWmStackorderToplevel_TCL_DECLARED
-#define TkWmStackorderToplevel_TCL_DECLARED
+EXTERN TkRegion    TkPhotoGetValidRegion(Tk_PhotoHandle handle);
 /* 141 */
-EXTERN TkWindow **  TkWmStackorderToplevel (TkWindow * parentPtr);
-#endif
-#ifndef TkFocusFree_TCL_DECLARED
-#define TkFocusFree_TCL_DECLARED
+EXTERN TkWindow **  TkWmStackorderToplevel(TkWindow *parentPtr);
 /* 142 */
-EXTERN void    TkFocusFree (TkMainInfo * mainPtr);
-#endif
-#ifndef TkClipCleanup_TCL_DECLARED
-#define TkClipCleanup_TCL_DECLARED
+EXTERN void    TkFocusFree(TkMainInfo *mainPtr);
 /* 143 */
-EXTERN void    TkClipCleanup (TkDisplay * dispPtr);
-#endif
-#ifndef TkGCCleanup_TCL_DECLARED
-#define TkGCCleanup_TCL_DECLARED
+EXTERN void    TkClipCleanup(TkDisplay *dispPtr);
 /* 144 */
-EXTERN void    TkGCCleanup (TkDisplay * dispPtr);
-#endif
-#ifdef __WIN32__ /* WIN */
-#ifndef TkSubtractRegion_TCL_DECLARED
-#define TkSubtractRegion_TCL_DECLARED
-/* 145 */
-EXTERN void    TkSubtractRegion (TkRegion sra, TkRegion srcb, 
-        TkRegion dr_return);
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkSubtractRegion_TCL_DECLARED
-#define TkSubtractRegion_TCL_DECLARED
+EXTERN void    TkGCCleanup(TkDisplay *dispPtr);
 /* 145 */
-EXTERN void    TkSubtractRegion (TkRegion sra, TkRegion srcb, 
+EXTERN void    TkSubtractRegion(TkRegion sra, TkRegion srcb,
         TkRegion dr_return);
-#endif
-#endif /* AQUA */
-#ifndef TkStylePkgInit_TCL_DECLARED
-#define TkStylePkgInit_TCL_DECLARED
 /* 146 */
-EXTERN void    TkStylePkgInit (TkMainInfo * mainPtr);
-#endif
-#ifndef TkStylePkgFree_TCL_DECLARED
-#define TkStylePkgFree_TCL_DECLARED
+EXTERN void    TkStylePkgInit(TkMainInfo *mainPtr);
 /* 147 */
-EXTERN void    TkStylePkgFree (TkMainInfo * mainPtr);
-#endif
-#ifndef TkToplevelWindowForCommand_TCL_DECLARED
-#define TkToplevelWindowForCommand_TCL_DECLARED
+EXTERN void    TkStylePkgFree(TkMainInfo *mainPtr);
 /* 148 */
-EXTERN Tk_Window  TkToplevelWindowForCommand (Tcl_Interp * interp, 
-        CONST char * cmdName);
-#endif
-#ifndef TkGetOptionSpec_TCL_DECLARED
-#define TkGetOptionSpec_TCL_DECLARED
+EXTERN Tk_Window  TkToplevelWindowForCommand(Tcl_Interp *interp,
+        const char *cmdName);
 /* 149 */
-EXTERN CONST Tk_OptionSpec * TkGetOptionSpec (CONST char * name, 
+EXTERN const Tk_OptionSpec * TkGetOptionSpec(const char *name,
         Tk_OptionTable optionTable);
-#endif
-#ifndef TkMakeRawCurve_TCL_DECLARED
-#define TkMakeRawCurve_TCL_DECLARED
 /* 150 */
-EXTERN int    TkMakeRawCurve (Tk_Canvas canvas, double * pointPtr, 
-        int numPoints, int numSteps, 
+EXTERN int    TkMakeRawCurve(Tk_Canvas canvas, double *pointPtr,
+        int numPoints, int numSteps,
         XPoint xPoints[], double dblPoints[]);
-#endif
-#ifndef TkMakeRawCurvePostscript_TCL_DECLARED
-#define TkMakeRawCurvePostscript_TCL_DECLARED
 /* 151 */
-EXTERN void    TkMakeRawCurvePostscript (Tcl_Interp * interp, 
-        Tk_Canvas canvas, double * pointPtr, 
+EXTERN void    TkMakeRawCurvePostscript(Tcl_Interp *interp,
+        Tk_Canvas canvas, double *pointPtr,
         int numPoints);
-#endif
-#ifndef TkpDrawFrame_TCL_DECLARED
-#define TkpDrawFrame_TCL_DECLARED
 /* 152 */
-EXTERN void    TkpDrawFrame (Tk_Window tkwin, Tk_3DBorder border, 
-        int highlightWidth, int borderWidth, 
+EXTERN void    TkpDrawFrame(Tk_Window tkwin, Tk_3DBorder border,
+        int highlightWidth, int borderWidth,
         int relief);
-#endif
-#ifndef TkCreateThreadExitHandler_TCL_DECLARED
-#define TkCreateThreadExitHandler_TCL_DECLARED
 /* 153 */
-EXTERN void    TkCreateThreadExitHandler (Tcl_ExitProc * proc, 
+EXTERN void    TkCreateThreadExitHandler(Tcl_ExitProc *proc,
         ClientData clientData);
-#endif
-#ifndef TkDeleteThreadExitHandler_TCL_DECLARED
-#define TkDeleteThreadExitHandler_TCL_DECLARED
 /* 154 */
-EXTERN void    TkDeleteThreadExitHandler (Tcl_ExitProc * proc, 
+EXTERN void    TkDeleteThreadExitHandler(Tcl_ExitProc *proc,
         ClientData clientData);
-#endif
 /* Slot 155 is reserved */
-#ifndef TkpTestembedCmd_TCL_DECLARED
-#define TkpTestembedCmd_TCL_DECLARED
 /* 156 */
-EXTERN int    TkpTestembedCmd (ClientData clientData, 
-        Tcl_Interp * interp, int argc, 
-        CONST char ** argv);
-#endif
-#ifndef TkpTesttextCmd_TCL_DECLARED
-#define TkpTesttextCmd_TCL_DECLARED
+EXTERN int    TkpTestembedCmd(ClientData clientData,
+        Tcl_Interp *interp, int argc,
+        const char **argv);
 /* 157 */
-EXTERN int    TkpTesttextCmd (ClientData dummy, 
-        Tcl_Interp * interp, int argc, 
-        CONST char ** argv);
-#endif
+EXTERN int    TkpTesttextCmd(ClientData dummy, Tcl_Interp *interp,
+        int argc, const char **argv);
+/* 158 */
+EXTERN int    TkSelGetSelection(Tcl_Interp *interp,
+        Tk_Window tkwin, Atom selection, Atom target,
+        Tk_GetSelProc *proc, ClientData clientData);
+/* 159 */
+EXTERN int    TkTextGetIndex(Tcl_Interp *interp,
+        struct TkText *textPtr, const char *string,
+        struct TkTextIndex *indexPtr);
+/* 160 */
+EXTERN int    TkTextIndexBackBytes(const struct TkText *textPtr,
+        const struct TkTextIndex *srcPtr, int count,
+        struct TkTextIndex *dstPtr);
+/* 161 */
+EXTERN int    TkTextIndexForwBytes(const struct TkText *textPtr,
+        const struct TkTextIndex *srcPtr, int count,
+        struct TkTextIndex *dstPtr);
+/* 162 */
+EXTERN struct TkTextIndex * TkTextMakeByteIndex(TkTextBTree tree,
+        const struct TkText *textPtr, int lineIndex,
+        int byteIndex, struct TkTextIndex *indexPtr);
+/* 163 */
+EXTERN int    TkTextPrintIndex(const struct TkText *textPtr,
+        const struct TkTextIndex *indexPtr,
+        char *string);
+/* 164 */
+EXTERN struct TkTextSegment * TkTextSetMark(struct TkText *textPtr,
+        const char *name,
+        struct TkTextIndex *indexPtr);
+/* 165 */
+EXTERN int    TkTextXviewCmd(struct TkText *textPtr,
+        Tcl_Interp *interp, int objc,
+        Tcl_Obj *const objv[]);
+/* 166 */
+EXTERN void    TkTextChanged(struct TkSharedText *sharedTextPtr,
+        struct TkText *textPtr,
+        const struct TkTextIndex *index1Ptr,
+        const struct TkTextIndex *index2Ptr);
+/* 167 */
+EXTERN int    TkBTreeNumLines(TkTextBTree tree,
+        const struct TkText *textPtr);
+/* 168 */
+EXTERN void    TkTextInsertDisplayProc(struct TkText *textPtr,
+        struct TkTextDispChunk *chunkPtr, int x,
+        int y, int height, int baseline,
+        Display *display, Drawable dst, int screenY);
+/* 169 */
+EXTERN int    TkStateParseProc(ClientData clientData,
+        Tcl_Interp *interp, Tk_Window tkwin,
+        const char *value, char *widgRec, int offset);
+/* 170 */
+EXTERN CONST86 char *  TkStatePrintProc(ClientData clientData,
+        Tk_Window tkwin, char *widgRec, int offset,
+        Tcl_FreeProc **freeProcPtr);
+/* 171 */
+EXTERN int    TkCanvasDashParseProc(ClientData clientData,
+        Tcl_Interp *interp, Tk_Window tkwin,
+        const char *value, char *widgRec, int offset);
+/* 172 */
+EXTERN CONST86 char *  TkCanvasDashPrintProc(ClientData clientData,
+        Tk_Window tkwin, char *widgRec, int offset,
+        Tcl_FreeProc **freeProcPtr);
+/* 173 */
+EXTERN int    TkOffsetParseProc(ClientData clientData,
+        Tcl_Interp *interp, Tk_Window tkwin,
+        const char *value, char *widgRec, int offset);
+/* 174 */
+EXTERN CONST86 char *  TkOffsetPrintProc(ClientData clientData,
+        Tk_Window tkwin, char *widgRec, int offset,
+        Tcl_FreeProc **freeProcPtr);
+/* 175 */
+EXTERN int    TkPixelParseProc(ClientData clientData,
+        Tcl_Interp *interp, Tk_Window tkwin,
+        const char *value, char *widgRec, int offset);
+/* 176 */
+EXTERN CONST86 char *  TkPixelPrintProc(ClientData clientData,
+        Tk_Window tkwin, char *widgRec, int offset,
+        Tcl_FreeProc **freeProcPtr);
+/* 177 */
+EXTERN int    TkOrientParseProc(ClientData clientData,
+        Tcl_Interp *interp, Tk_Window tkwin,
+        const char *value, char *widgRec, int offset);
+/* 178 */
+EXTERN CONST86 char *  TkOrientPrintProc(ClientData clientData,
+        Tk_Window tkwin, char *widgRec, int offset,
+        Tcl_FreeProc **freeProcPtr);
+/* 179 */
+EXTERN int    TkSmoothParseProc(ClientData clientData,
+        Tcl_Interp *interp, Tk_Window tkwin,
+        const char *value, char *widgRec, int offset);
+/* 180 */
+EXTERN CONST86 char *  TkSmoothPrintProc(ClientData clientData,
+        Tk_Window tkwin, char *widgRec, int offset,
+        Tcl_FreeProc **freeProcPtr);
+/* 181 */
+EXTERN void    TkDrawAngledTextLayout(Display *display,
+        Drawable drawable, GC gc,
+        Tk_TextLayout layout, int x, int y,
+        double angle, int firstChar, int lastChar);
+/* 182 */
+EXTERN void    TkUnderlineAngledTextLayout(Display *display,
+        Drawable drawable, GC gc,
+        Tk_TextLayout layout, int x, int y,
+        double angle, int underline);
+/* 183 */
+EXTERN int    TkIntersectAngledTextLayout(Tk_TextLayout layout,
+        int x, int y, int width, int height,
+        double angle);
+/* 184 */
+EXTERN void    TkDrawAngledChars(Display *display,
+        Drawable drawable, GC gc, Tk_Font tkfont,
+        const char *source, int numBytes, double x,
+        double y, double angle);
 
 typedef struct TkIntStubs {
     int magic;
-    CONST struct TkIntStubHooks *hooks;
+    void *hooks;
 
-    TkWindow * (*tkAllocWindow) (TkDisplay * dispPtr, int screenNum, TkWindow * parentPtr); /* 0 */
-    void (*tkBezierPoints) (double control[], int numSteps, double * coordPtr); /* 1 */
-    void (*tkBezierScreenPoints) (Tk_Canvas canvas, double control[], int numSteps, XPoint * xPointPtr); /* 2 */
-    void (*tkBindDeadWindow) (TkWindow * winPtr); /* 3 */
-    void (*tkBindEventProc) (TkWindow * winPtr, XEvent * eventPtr); /* 4 */
-    void (*tkBindFree) (TkMainInfo * mainPtr); /* 5 */
-    void (*tkBindInit) (TkMainInfo * mainPtr); /* 6 */
-    void (*tkChangeEventWindow) (XEvent * eventPtr, TkWindow * winPtr); /* 7 */
-    int (*tkClipInit) (Tcl_Interp * interp, TkDisplay * dispPtr); /* 8 */
-    void (*tkComputeAnchor) (Tk_Anchor anchor, Tk_Window tkwin, int padX, int padY, int innerWidth, int innerHeight, int * xPtr, int * yPtr); /* 9 */
-    int (*tkCopyAndGlobalEval) (Tcl_Interp * interp, char * script); /* 10 */
-    unsigned long (*tkCreateBindingProcedure) (Tcl_Interp * interp, Tk_BindingTable bindingTable, ClientData object, CONST char * eventString, TkBindEvalProc * evalProc, TkBindFreeProc * freeProc, ClientData clientData); /* 11 */
-    TkCursor * (*tkCreateCursorFromData) (Tk_Window tkwin, CONST char * source, CONST char * mask, int width, int height, int xHot, int yHot, XColor fg, XColor bg); /* 12 */
-    int (*tkCreateFrame) (ClientData clientData, Tcl_Interp * interp, int argc, char ** argv, int toplevel, char * appName); /* 13 */
-    Tk_Window (*tkCreateMainWindow) (Tcl_Interp * interp, CONST char * screenName, char * baseName); /* 14 */
-    Time (*tkCurrentTime) (TkDisplay * dispPtr); /* 15 */
-    void (*tkDeleteAllImages) (TkMainInfo * mainPtr); /* 16 */
-    void (*tkDoConfigureNotify) (TkWindow * winPtr); /* 17 */
+    TkWindow * (*tkAllocWindow) (TkDisplay *dispPtr, int screenNum, TkWindow *parentPtr); /* 0 */
+    void (*tkBezierPoints) (double control[], int numSteps, double *coordPtr); /* 1 */
+    void (*tkBezierScreenPoints) (Tk_Canvas canvas, double control[], int numSteps, XPoint *xPointPtr); /* 2 */
+    void (*reserved3)(void);
+    void (*tkBindEventProc) (TkWindow *winPtr, XEvent *eventPtr); /* 4 */
+    void (*tkBindFree) (TkMainInfo *mainPtr); /* 5 */
+    void (*tkBindInit) (TkMainInfo *mainPtr); /* 6 */
+    void (*tkChangeEventWindow) (XEvent *eventPtr, TkWindow *winPtr); /* 7 */
+    int (*tkClipInit) (Tcl_Interp *interp, TkDisplay *dispPtr); /* 8 */
+    void (*tkComputeAnchor) (Tk_Anchor anchor, Tk_Window tkwin, int padX, int padY, int innerWidth, int innerHeight, int *xPtr, int *yPtr); /* 9 */
+    void (*reserved10)(void);
+    void (*reserved11)(void);
+    TkCursor * (*tkCreateCursorFromData) (Tk_Window tkwin, const char *source, const char *mask, int width, int height, int xHot, int yHot, XColor fg, XColor bg); /* 12 */
+    int (*tkCreateFrame) (ClientData clientData, Tcl_Interp *interp, int argc, const char *const *argv, int toplevel, const char *appName); /* 13 */
+    Tk_Window (*tkCreateMainWindow) (Tcl_Interp *interp, const char *screenName, const char *baseName); /* 14 */
+    Time (*tkCurrentTime) (TkDisplay *dispPtr); /* 15 */
+    void (*tkDeleteAllImages) (TkMainInfo *mainPtr); /* 16 */
+    void (*tkDoConfigureNotify) (TkWindow *winPtr); /* 17 */
     void (*tkDrawInsetFocusHighlight) (Tk_Window tkwin, GC gc, int width, Drawable drawable, int padding); /* 18 */
-    void (*tkEventDeadWindow) (TkWindow * winPtr); /* 19 */
-    void (*tkFillPolygon) (Tk_Canvas canvas, double * coordPtr, int numPoints, Display * display, Drawable drawable, GC gc, GC outlineGC); /* 20 */
-    int (*tkFindStateNum) (Tcl_Interp * interp, CONST char * option, CONST TkStateMap * mapPtr, CONST char * strKey); /* 21 */
-    char * (*tkFindStateString) (CONST TkStateMap * mapPtr, int numKey); /* 22 */
-    void (*tkFocusDeadWindow) (TkWindow * winPtr); /* 23 */
-    int (*tkFocusFilterEvent) (TkWindow * winPtr, XEvent * eventPtr); /* 24 */
-    TkWindow * (*tkFocusKeyEvent) (TkWindow * winPtr, XEvent * eventPtr); /* 25 */
-    void (*tkFontPkgInit) (TkMainInfo * mainPtr); /* 26 */
-    void (*tkFontPkgFree) (TkMainInfo * mainPtr); /* 27 */
-    void (*tkFreeBindingTags) (TkWindow * winPtr); /* 28 */
-    void (*tkpFreeCursor) (TkCursor * cursorPtr); /* 29 */
-    char * (*tkGetBitmapData) (Tcl_Interp * interp, char * string, char * fileName, int * widthPtr, int * heightPtr, int * hotXPtr, int * hotYPtr); /* 30 */
+    void (*tkEventDeadWindow) (TkWindow *winPtr); /* 19 */
+    void (*tkFillPolygon) (Tk_Canvas canvas, double *coordPtr, int numPoints, Display *display, Drawable drawable, GC gc, GC outlineGC); /* 20 */
+    int (*tkFindStateNum) (Tcl_Interp *interp, const char *option, const TkStateMap *mapPtr, const char *strKey); /* 21 */
+    CONST86 char * (*tkFindStateString) (const TkStateMap *mapPtr, int numKey); /* 22 */
+    void (*tkFocusDeadWindow) (TkWindow *winPtr); /* 23 */
+    int (*tkFocusFilterEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 24 */
+    TkWindow * (*tkFocusKeyEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 25 */
+    void (*tkFontPkgInit) (TkMainInfo *mainPtr); /* 26 */
+    void (*tkFontPkgFree) (TkMainInfo *mainPtr); /* 27 */
+    void (*tkFreeBindingTags) (TkWindow *winPtr); /* 28 */
+    void (*tkpFreeCursor) (TkCursor *cursorPtr); /* 29 */
+    char * (*tkGetBitmapData) (Tcl_Interp *interp, const char *string, const char *fileName, int *widthPtr, int *heightPtr, int *hotXPtr, int *hotYPtr); /* 30 */
     void (*tkGetButtPoints) (double p1[], double p2[], double width, int project, double m1[], double m2[]); /* 31 */
-    TkCursor * (*tkGetCursorByName) (Tcl_Interp * interp, Tk_Window tkwin, Tk_Uid string); /* 32 */
-    CONST84_RETURN char * (*tkGetDefaultScreenName) (Tcl_Interp * interp, CONST char * screenName); /* 33 */
-    TkDisplay * (*tkGetDisplay) (Display * display); /* 34 */
-    int (*tkGetDisplayOf) (Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[], Tk_Window * tkwinPtr); /* 35 */
-    TkWindow * (*tkGetFocusWin) (TkWindow * winPtr); /* 36 */
-    int (*tkGetInterpNames) (Tcl_Interp * interp, Tk_Window tkwin); /* 37 */
+    TkCursor * (*tkGetCursorByName) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid string); /* 32 */
+    const char * (*tkGetDefaultScreenName) (Tcl_Interp *interp, const char *screenName); /* 33 */
+    TkDisplay * (*tkGetDisplay) (Display *display); /* 34 */
+    int (*tkGetDisplayOf) (Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], Tk_Window *tkwinPtr); /* 35 */
+    TkWindow * (*tkGetFocusWin) (TkWindow *winPtr); /* 36 */
+    int (*tkGetInterpNames) (Tcl_Interp *interp, Tk_Window tkwin); /* 37 */
     int (*tkGetMiterPoints) (double p1[], double p2[], double p3[], double width, double m1[], double m2[]); /* 38 */
-    void (*tkGetPointerCoords) (Tk_Window tkwin, int * xPtr, int * yPtr); /* 39 */
-    void (*tkGetServerInfo) (Tcl_Interp * interp, Tk_Window tkwin); /* 40 */
-    void (*tkGrabDeadWindow) (TkWindow * winPtr); /* 41 */
-    int (*tkGrabState) (TkWindow * winPtr); /* 42 */
-    void (*tkIncludePoint) (Tk_Item * itemPtr, double * pointPtr); /* 43 */
-    void (*tkInOutEvents) (XEvent * eventPtr, TkWindow * sourcePtr, TkWindow * destPtr, int leaveType, int enterType, Tcl_QueuePosition position); /* 44 */
+    void (*tkGetPointerCoords) (Tk_Window tkwin, int *xPtr, int *yPtr); /* 39 */
+    void (*tkGetServerInfo) (Tcl_Interp *interp, Tk_Window tkwin); /* 40 */
+    void (*tkGrabDeadWindow) (TkWindow *winPtr); /* 41 */
+    int (*tkGrabState) (TkWindow *winPtr); /* 42 */
+    void (*tkIncludePoint) (Tk_Item *itemPtr, double *pointPtr); /* 43 */
+    void (*tkInOutEvents) (XEvent *eventPtr, TkWindow *sourcePtr, TkWindow *destPtr, int leaveType, int enterType, Tcl_QueuePosition position); /* 44 */
     void (*tkInstallFrameMenu) (Tk_Window tkwin); /* 45 */
-    char * (*tkKeysymToString) (KeySym keysym); /* 46 */
+    CONST86 char * (*tkKeysymToString) (KeySym keysym); /* 46 */
     int (*tkLineToArea) (double end1Ptr[], double end2Ptr[], double rectPtr[]); /* 47 */
     double (*tkLineToPoint) (double end1Ptr[], double end2Ptr[], double pointPtr[]); /* 48 */
-    int (*tkMakeBezierCurve) (Tk_Canvas canvas, double * pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 49 */
-    void (*tkMakeBezierPostscript) (Tcl_Interp * interp, Tk_Canvas canvas, double * pointPtr, int numPoints); /* 50 */
-    void (*tkOptionClassChanged) (TkWindow * winPtr); /* 51 */
-    void (*tkOptionDeadWindow) (TkWindow * winPtr); /* 52 */
-    int (*tkOvalToArea) (double * ovalPtr, double * rectPtr); /* 53 */
+    int (*tkMakeBezierCurve) (Tk_Canvas canvas, double *pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 49 */
+    void (*tkMakeBezierPostscript) (Tcl_Interp *interp, Tk_Canvas canvas, double *pointPtr, int numPoints); /* 50 */
+    void (*tkOptionClassChanged) (TkWindow *winPtr); /* 51 */
+    void (*tkOptionDeadWindow) (TkWindow *winPtr); /* 52 */
+    int (*tkOvalToArea) (double *ovalPtr, double *rectPtr); /* 53 */
     double (*tkOvalToPoint) (double ovalPtr[], double width, int filled, double pointPtr[]); /* 54 */
-    int (*tkpChangeFocus) (TkWindow * winPtr, int force); /* 55 */
-    void (*tkpCloseDisplay) (TkDisplay * dispPtr); /* 56 */
-    void (*tkpClaimFocus) (TkWindow * topLevelPtr, int force); /* 57 */
-    void (*tkpDisplayWarning) (CONST char * msg, CONST char * title); /* 58 */
-    void (*tkpGetAppName) (Tcl_Interp * interp, Tcl_DString * name); /* 59 */
-    TkWindow * (*tkpGetOtherWindow) (TkWindow * winPtr); /* 60 */
-    TkWindow * (*tkpGetWrapperWindow) (TkWindow * winPtr); /* 61 */
-    int (*tkpInit) (Tcl_Interp * interp); /* 62 */
-    void (*tkpInitializeMenuBindings) (Tcl_Interp * interp, Tk_BindingTable bindingTable); /* 63 */
+    int (*tkpChangeFocus) (TkWindow *winPtr, int force); /* 55 */
+    void (*tkpCloseDisplay) (TkDisplay *dispPtr); /* 56 */
+    void (*tkpClaimFocus) (TkWindow *topLevelPtr, int force); /* 57 */
+    void (*tkpDisplayWarning) (const char *msg, const char *title); /* 58 */
+    void (*tkpGetAppName) (Tcl_Interp *interp, Tcl_DString *name); /* 59 */
+    TkWindow * (*tkpGetOtherWindow) (TkWindow *winPtr); /* 60 */
+    TkWindow * (*tkpGetWrapperWindow) (TkWindow *winPtr); /* 61 */
+    int (*tkpInit) (Tcl_Interp *interp); /* 62 */
+    void (*tkpInitializeMenuBindings) (Tcl_Interp *interp, Tk_BindingTable bindingTable); /* 63 */
     void (*tkpMakeContainer) (Tk_Window tkwin); /* 64 */
     void (*tkpMakeMenuWindow) (Tk_Window tkwin, int transient); /* 65 */
-    Window (*tkpMakeWindow) (TkWindow * winPtr, Window parent); /* 66 */
-    void (*tkpMenuNotifyToplevelCreate) (Tcl_Interp * interp1, char * menuName); /* 67 */
-    TkDisplay * (*tkpOpenDisplay) (CONST char * display_name); /* 68 */
-    int (*tkPointerEvent) (XEvent * eventPtr, TkWindow * winPtr); /* 69 */
-    int (*tkPolygonToArea) (double * polyPtr, int numPoints, double * rectPtr); /* 70 */
-    double (*tkPolygonToPoint) (double * polyPtr, int numPoints, double * pointPtr); /* 71 */
-    int (*tkPositionInTree) (TkWindow * winPtr, TkWindow * treePtr); /* 72 */
-    void (*tkpRedirectKeyEvent) (TkWindow * winPtr, XEvent * eventPtr); /* 73 */
-    void (*tkpSetMainMenubar) (Tcl_Interp * interp, Tk_Window tkwin, char * menuName); /* 74 */
-    int (*tkpUseWindow) (Tcl_Interp * interp, Tk_Window tkwin, CONST char * string); /* 75 */
-    void *reserved76;
-    void (*tkQueueEventForAllChildren) (TkWindow * winPtr, XEvent * eventPtr); /* 77 */
-    int (*tkReadBitmapFile) (Display * display, Drawable d, CONST char * filename, unsigned int * width_return, unsigned int * height_return, Pixmap * bitmap_return, int * x_hot_return, int * y_hot_return); /* 78 */
+    Window (*tkpMakeWindow) (TkWindow *winPtr, Window parent); /* 66 */
+    void (*tkpMenuNotifyToplevelCreate) (Tcl_Interp *interp, const char *menuName); /* 67 */
+    TkDisplay * (*tkpOpenDisplay) (const char *display_name); /* 68 */
+    int (*tkPointerEvent) (XEvent *eventPtr, TkWindow *winPtr); /* 69 */
+    int (*tkPolygonToArea) (double *polyPtr, int numPoints, double *rectPtr); /* 70 */
+    double (*tkPolygonToPoint) (double *polyPtr, int numPoints, double *pointPtr); /* 71 */
+    int (*tkPositionInTree) (TkWindow *winPtr, TkWindow *treePtr); /* 72 */
+    void (*tkpRedirectKeyEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 73 */
+    void (*tkpSetMainMenubar) (Tcl_Interp *interp, Tk_Window tkwin, const char *menuName); /* 74 */
+    int (*tkpUseWindow) (Tcl_Interp *interp, Tk_Window tkwin, const char *string); /* 75 */
+    void (*reserved76)(void);
+    void (*tkQueueEventForAllChildren) (TkWindow *winPtr, XEvent *eventPtr); /* 77 */
+    int (*tkReadBitmapFile) (Display *display, Drawable d, const char *filename, unsigned int *width_return, unsigned int *height_return, Pixmap *bitmap_return, int *x_hot_return, int *y_hot_return); /* 78 */
     int (*tkScrollWindow) (Tk_Window tkwin, GC gc, int x, int y, int width, int height, int dx, int dy, TkRegion damageRgn); /* 79 */
-    void (*tkSelDeadWindow) (TkWindow * winPtr); /* 80 */
-    void (*tkSelEventProc) (Tk_Window tkwin, XEvent * eventPtr); /* 81 */
+    void (*tkSelDeadWindow) (TkWindow *winPtr); /* 80 */
+    void (*tkSelEventProc) (Tk_Window tkwin, XEvent *eventPtr); /* 81 */
     void (*tkSelInit) (Tk_Window tkwin); /* 82 */
-    void (*tkSelPropProc) (XEvent * eventPtr); /* 83 */
-    void *reserved84;
-    void (*tkSetWindowMenuBar) (Tcl_Interp * interp, Tk_Window tkwin, char * oldMenuName, char * menuName); /* 85 */
-    KeySym (*tkStringToKeysym) (char * name); /* 86 */
-    int (*tkThickPolyLineToArea) (double * coordPtr, int numPoints, double width, int capStyle, int joinStyle, double * rectPtr); /* 87 */
-    void (*tkWmAddToColormapWindows) (TkWindow * winPtr); /* 88 */
-    void (*tkWmDeadWindow) (TkWindow * winPtr); /* 89 */
-    TkWindow * (*tkWmFocusToplevel) (TkWindow * winPtr); /* 90 */
-    void (*tkWmMapWindow) (TkWindow * winPtr); /* 91 */
-    void (*tkWmNewWindow) (TkWindow * winPtr); /* 92 */
-    void (*tkWmProtocolEventProc) (TkWindow * winPtr, XEvent * evenvPtr); /* 93 */
-    void (*tkWmRemoveFromColormapWindows) (TkWindow * winPtr); /* 94 */
-    void (*tkWmRestackToplevel) (TkWindow * winPtr, int aboveBelow, TkWindow * otherPtr); /* 95 */
-    void (*tkWmSetClass) (TkWindow * winPtr); /* 96 */
-    void (*tkWmUnmapWindow) (TkWindow * winPtr); /* 97 */
-    Tcl_Obj * (*tkDebugBitmap) (Tk_Window tkwin, char * name); /* 98 */
-    Tcl_Obj * (*tkDebugBorder) (Tk_Window tkwin, char * name); /* 99 */
-    Tcl_Obj * (*tkDebugCursor) (Tk_Window tkwin, char * name); /* 100 */
-    Tcl_Obj * (*tkDebugColor) (Tk_Window tkwin, char * name); /* 101 */
-    Tcl_Obj * (*tkDebugConfig) (Tcl_Interp * interp, Tk_OptionTable table); /* 102 */
-    Tcl_Obj * (*tkDebugFont) (Tk_Window tkwin, char * name); /* 103 */
-    int (*tkFindStateNumObj) (Tcl_Interp * interp, Tcl_Obj * optionPtr, CONST TkStateMap * mapPtr, Tcl_Obj * keyPtr); /* 104 */
+    void (*tkSelPropProc) (XEvent *eventPtr); /* 83 */
+    void (*reserved84)(void);
+    void (*tkSetWindowMenuBar) (Tcl_Interp *interp, Tk_Window tkwin, const char *oldMenuName, const char *menuName); /* 85 */
+    KeySym (*tkStringToKeysym) (const char *name); /* 86 */
+    int (*tkThickPolyLineToArea) (double *coordPtr, int numPoints, double width, int capStyle, int joinStyle, double *rectPtr); /* 87 */
+    void (*tkWmAddToColormapWindows) (TkWindow *winPtr); /* 88 */
+    void (*tkWmDeadWindow) (TkWindow *winPtr); /* 89 */
+    TkWindow * (*tkWmFocusToplevel) (TkWindow *winPtr); /* 90 */
+    void (*tkWmMapWindow) (TkWindow *winPtr); /* 91 */
+    void (*tkWmNewWindow) (TkWindow *winPtr); /* 92 */
+    void (*tkWmProtocolEventProc) (TkWindow *winPtr, XEvent *evenvPtr); /* 93 */
+    void (*tkWmRemoveFromColormapWindows) (TkWindow *winPtr); /* 94 */
+    void (*tkWmRestackToplevel) (TkWindow *winPtr, int aboveBelow, TkWindow *otherPtr); /* 95 */
+    void (*tkWmSetClass) (TkWindow *winPtr); /* 96 */
+    void (*tkWmUnmapWindow) (TkWindow *winPtr); /* 97 */
+    Tcl_Obj * (*tkDebugBitmap) (Tk_Window tkwin, const char *name); /* 98 */
+    Tcl_Obj * (*tkDebugBorder) (Tk_Window tkwin, const char *name); /* 99 */
+    Tcl_Obj * (*tkDebugCursor) (Tk_Window tkwin, const char *name); /* 100 */
+    Tcl_Obj * (*tkDebugColor) (Tk_Window tkwin, const char *name); /* 101 */
+    Tcl_Obj * (*tkDebugConfig) (Tcl_Interp *interp, Tk_OptionTable table); /* 102 */
+    Tcl_Obj * (*tkDebugFont) (Tk_Window tkwin, const char *name); /* 103 */
+    int (*tkFindStateNumObj) (Tcl_Interp *interp, Tcl_Obj *optionPtr, const TkStateMap *mapPtr, Tcl_Obj *keyPtr); /* 104 */
     Tcl_HashTable * (*tkGetBitmapPredefTable) (void); /* 105 */
     TkDisplay * (*tkGetDisplayList) (void); /* 106 */
     TkMainInfo * (*tkGetMainInfoList) (void); /* 107 */
-    int (*tkGetWindowFromObj) (Tcl_Interp * interp, Tk_Window tkwin, Tcl_Obj * objPtr, Tk_Window * windowPtr); /* 108 */
-    char * (*tkpGetString) (TkWindow * winPtr, XEvent * eventPtr, Tcl_DString * dsPtr); /* 109 */
-    void (*tkpGetSubFonts) (Tcl_Interp * interp, Tk_Font tkfont); /* 110 */
-    Tcl_Obj * (*tkpGetSystemDefault) (Tk_Window tkwin, CONST char * dbName, CONST char * className); /* 111 */
+    int (*tkGetWindowFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr, Tk_Window *windowPtr); /* 108 */
+    CONST86 char * (*tkpGetString) (TkWindow *winPtr, XEvent *eventPtr, Tcl_DString *dsPtr); /* 109 */
+    void (*tkpGetSubFonts) (Tcl_Interp *interp, Tk_Font tkfont); /* 110 */
+    Tcl_Obj * (*tkpGetSystemDefault) (Tk_Window tkwin, const char *dbName, const char *className); /* 111 */
     void (*tkpMenuThreadInit) (void); /* 112 */
-#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-    void *reserved113;
-#endif /* X11 */
-#ifdef __WIN32__ /* WIN */
-    void (*tkClipBox) (TkRegion rgn, XRectangle * rect_return); /* 113 */
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-    void *reserved113; /* Dummy entry for stubs table backwards compatibility */
-    void (*tkClipBox) (TkRegion rgn, XRectangle * rect_return); /* 113 */
-#endif /* AQUA */
-#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-    void *reserved114;
-#endif /* X11 */
-#ifdef __WIN32__ /* WIN */
+    void (*tkClipBox) (TkRegion rgn, XRectangle *rect_return); /* 113 */
     TkRegion (*tkCreateRegion) (void); /* 114 */
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-    void *reserved114; /* Dummy entry for stubs table backwards compatibility */
-    TkRegion (*tkCreateRegion) (void); /* 114 */
-#endif /* AQUA */
-#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-    void *reserved115;
-#endif /* X11 */
-#ifdef __WIN32__ /* WIN */
     void (*tkDestroyRegion) (TkRegion rgn); /* 115 */
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-    void *reserved115; /* Dummy entry for stubs table backwards compatibility */
-    void (*tkDestroyRegion) (TkRegion rgn); /* 115 */
-#endif /* AQUA */
-#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-    void *reserved116;
-#endif /* X11 */
-#ifdef __WIN32__ /* WIN */
     void (*tkIntersectRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 116 */
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-    void *reserved116; /* Dummy entry for stubs table backwards compatibility */
-    void (*tkIntersectRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 116 */
-#endif /* AQUA */
-#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-    void *reserved117;
-#endif /* X11 */
-#ifdef __WIN32__ /* WIN */
     int (*tkRectInRegion) (TkRegion rgn, int x, int y, unsigned int width, unsigned int height); /* 117 */
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-    void *reserved117; /* Dummy entry for stubs table backwards compatibility */
-    int (*tkRectInRegion) (TkRegion rgn, int x, int y, unsigned int width, unsigned int height); /* 117 */
-#endif /* AQUA */
-#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-    void *reserved118;
-#endif /* X11 */
-#ifdef __WIN32__ /* WIN */
-    void (*tkSetRegion) (Display * display, GC gc, TkRegion rgn); /* 118 */
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-    void *reserved118; /* Dummy entry for stubs table backwards compatibility */
-    void (*tkSetRegion) (Display * display, GC gc, TkRegion rgn); /* 118 */
-#endif /* AQUA */
+    void (*tkSetRegion) (Display *display, GC gc, TkRegion rgn); /* 118 */
+    void (*tkUnionRectWithRegion) (XRectangle *rect, TkRegion src, TkRegion dr_return); /* 119 */
+    void (*reserved120)(void);
 #if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-    void *reserved119;
+    void (*reserved121)(void);
 #endif /* X11 */
-#ifdef __WIN32__ /* WIN */
-    void (*tkUnionRectWithRegion) (XRectangle * rect, TkRegion src, TkRegion dr_return); /* 119 */
+#if defined(__WIN32__) /* WIN */
+    void (*reserved121)(void);
 #endif /* WIN */
 #ifdef MAC_OSX_TK /* AQUA */
-    void *reserved119; /* Dummy entry for stubs table backwards compatibility */
-    void (*tkUnionRectWithRegion) (XRectangle * rect, TkRegion src, TkRegion dr_return); /* 119 */
+    void (*reserved121)(void); /* Dummy entry for stubs table backwards compatibility */
+    Pixmap (*tkpCreateNativeBitmap) (Display *display, const void *source); /* 121 */
 #endif /* AQUA */
-    void *reserved120;
 #if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-    void *reserved121;
+    void (*reserved122)(void);
 #endif /* X11 */
-#ifdef __WIN32__ /* WIN */
-    void *reserved121;
+#if defined(__WIN32__) /* WIN */
+    void (*reserved122)(void);
 #endif /* WIN */
 #ifdef MAC_OSX_TK /* AQUA */
-    void *reserved121; /* Dummy entry for stubs table backwards compatibility */
-    Pixmap (*tkpCreateNativeBitmap) (Display * display, CONST char * source); /* 121 */
-#endif /* AQUA */
-#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-    void *reserved122;
-#endif /* X11 */
-#ifdef __WIN32__ /* WIN */
-    void *reserved122;
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-    void *reserved122; /* Dummy entry for stubs table backwards compatibility */
+    void (*reserved122)(void); /* Dummy entry for stubs table backwards compatibility */
     void (*tkpDefineNativeBitmaps) (void); /* 122 */
 #endif /* AQUA */
-    void *reserved123;
+    void (*reserved123)(void);
 #if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-    void *reserved124;
+    void (*reserved124)(void);
 #endif /* X11 */
-#ifdef __WIN32__ /* WIN */
-    void *reserved124;
+#if defined(__WIN32__) /* WIN */
+    void (*reserved124)(void);
 #endif /* WIN */
 #ifdef MAC_OSX_TK /* AQUA */
-    void *reserved124; /* Dummy entry for stubs table backwards compatibility */
-    Pixmap (*tkpGetNativeAppBitmap) (Display * display, CONST char * name, int * width, int * height); /* 124 */
+    void (*reserved124)(void); /* Dummy entry for stubs table backwards compatibility */
+    Pixmap (*tkpGetNativeAppBitmap) (Display *display, const char *name, int *width, int *height); /* 124 */
 #endif /* AQUA */
-    void *reserved125;
-    void *reserved126;
-    void *reserved127;
-    void *reserved128;
-    void *reserved129;
-    void *reserved130;
-    void *reserved131;
-    void *reserved132;
-    void *reserved133;
-    void *reserved134;
+    void (*reserved125)(void);
+    void (*reserved126)(void);
+    void (*reserved127)(void);
+    void (*reserved128)(void);
+    void (*reserved129)(void);
+    void (*reserved130)(void);
+    void (*reserved131)(void);
+    void (*reserved132)(void);
+    void (*reserved133)(void);
+    void (*reserved134)(void);
     void (*tkpDrawHighlightBorder) (Tk_Window tkwin, GC fgGC, GC bgGC, int highlightWidth, Drawable drawable); /* 135 */
-    void (*tkSetFocusWin) (TkWindow * winPtr, int force); /* 136 */
-    void (*tkpSetKeycodeAndState) (Tk_Window tkwin, KeySym keySym, XEvent * eventPtr); /* 137 */
-    KeySym (*tkpGetKeySym) (TkDisplay * dispPtr, XEvent * eventPtr); /* 138 */
-    void (*tkpInitKeymapInfo) (TkDisplay * dispPtr); /* 139 */
+    void (*tkSetFocusWin) (TkWindow *winPtr, int force); /* 136 */
+    void (*tkpSetKeycodeAndState) (Tk_Window tkwin, KeySym keySym, XEvent *eventPtr); /* 137 */
+    KeySym (*tkpGetKeySym) (TkDisplay *dispPtr, XEvent *eventPtr); /* 138 */
+    void (*tkpInitKeymapInfo) (TkDisplay *dispPtr); /* 139 */
     TkRegion (*tkPhotoGetValidRegion) (Tk_PhotoHandle handle); /* 140 */
-    TkWindow ** (*tkWmStackorderToplevel) (TkWindow * parentPtr); /* 141 */
-    void (*tkFocusFree) (TkMainInfo * mainPtr); /* 142 */
-    void (*tkClipCleanup) (TkDisplay * dispPtr); /* 143 */
-    void (*tkGCCleanup) (TkDisplay * dispPtr); /* 144 */
-#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-    void *reserved145;
-#endif /* X11 */
-#ifdef __WIN32__ /* WIN */
+    TkWindow ** (*tkWmStackorderToplevel) (TkWindow *parentPtr); /* 141 */
+    void (*tkFocusFree) (TkMainInfo *mainPtr); /* 142 */
+    void (*tkClipCleanup) (TkDisplay *dispPtr); /* 143 */
+    void (*tkGCCleanup) (TkDisplay *dispPtr); /* 144 */
     void (*tkSubtractRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 145 */
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-    void *reserved145; /* Dummy entry for stubs table backwards compatibility */
-    void (*tkSubtractRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 145 */
-#endif /* AQUA */
-    void (*tkStylePkgInit) (TkMainInfo * mainPtr); /* 146 */
-    void (*tkStylePkgFree) (TkMainInfo * mainPtr); /* 147 */
-    Tk_Window (*tkToplevelWindowForCommand) (Tcl_Interp * interp, CONST char * cmdName); /* 148 */
-    CONST Tk_OptionSpec * (*tkGetOptionSpec) (CONST char * name, Tk_OptionTable optionTable); /* 149 */
-    int (*tkMakeRawCurve) (Tk_Canvas canvas, double * pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 150 */
-    void (*tkMakeRawCurvePostscript) (Tcl_Interp * interp, Tk_Canvas canvas, double * pointPtr, int numPoints); /* 151 */
+    void (*tkStylePkgInit) (TkMainInfo *mainPtr); /* 146 */
+    void (*tkStylePkgFree) (TkMainInfo *mainPtr); /* 147 */
+    Tk_Window (*tkToplevelWindowForCommand) (Tcl_Interp *interp, const char *cmdName); /* 148 */
+    const Tk_OptionSpec * (*tkGetOptionSpec) (const char *name, Tk_OptionTable optionTable); /* 149 */
+    int (*tkMakeRawCurve) (Tk_Canvas canvas, double *pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 150 */
+    void (*tkMakeRawCurvePostscript) (Tcl_Interp *interp, Tk_Canvas canvas, double *pointPtr, int numPoints); /* 151 */
     void (*tkpDrawFrame) (Tk_Window tkwin, Tk_3DBorder border, int highlightWidth, int borderWidth, int relief); /* 152 */
-    void (*tkCreateThreadExitHandler) (Tcl_ExitProc * proc, ClientData clientData); /* 153 */
-    void (*tkDeleteThreadExitHandler) (Tcl_ExitProc * proc, ClientData clientData); /* 154 */
-    void *reserved155;
-    int (*tkpTestembedCmd) (ClientData clientData, Tcl_Interp * interp, int argc, CONST char ** argv); /* 156 */
-    int (*tkpTesttextCmd) (ClientData dummy, Tcl_Interp * interp, int argc, CONST char ** argv); /* 157 */
+    void (*tkCreateThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 153 */
+    void (*tkDeleteThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 154 */
+    void (*reserved155)(void);
+    int (*tkpTestembedCmd) (ClientData clientData, Tcl_Interp *interp, int argc, const char **argv); /* 156 */
+    int (*tkpTesttextCmd) (ClientData dummy, Tcl_Interp *interp, int argc, const char **argv); /* 157 */
+    int (*tkSelGetSelection) (Tcl_Interp *interp, Tk_Window tkwin, Atom selection, Atom target, Tk_GetSelProc *proc, ClientData clientData); /* 158 */
+    int (*tkTextGetIndex) (Tcl_Interp *interp, struct TkText *textPtr, const char *string, struct TkTextIndex *indexPtr); /* 159 */
+    int (*tkTextIndexBackBytes) (const struct TkText *textPtr, const struct TkTextIndex *srcPtr, int count, struct TkTextIndex *dstPtr); /* 160 */
+    int (*tkTextIndexForwBytes) (const struct TkText *textPtr, const struct TkTextIndex *srcPtr, int count, struct TkTextIndex *dstPtr); /* 161 */
+    struct TkTextIndex * (*tkTextMakeByteIndex) (TkTextBTree tree, const struct TkText *textPtr, int lineIndex, int byteIndex, struct TkTextIndex *indexPtr); /* 162 */
+    int (*tkTextPrintIndex) (const struct TkText *textPtr, const struct TkTextIndex *indexPtr, char *string); /* 163 */
+    struct TkTextSegment * (*tkTextSetMark) (struct TkText *textPtr, const char *name, struct TkTextIndex *indexPtr); /* 164 */
+    int (*tkTextXviewCmd) (struct TkText *textPtr, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 165 */
+    void (*tkTextChanged) (struct TkSharedText *sharedTextPtr, struct TkText *textPtr, const struct TkTextIndex *index1Ptr, const struct TkTextIndex *index2Ptr); /* 166 */
+    int (*tkBTreeNumLines) (TkTextBTree tree, const struct TkText *textPtr); /* 167 */
+    void (*tkTextInsertDisplayProc) (struct TkText *textPtr, struct TkTextDispChunk *chunkPtr, int x, int y, int height, int baseline, Display *display, Drawable dst, int screenY); /* 168 */
+    int (*tkStateParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 169 */
+    CONST86 char * (*tkStatePrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 170 */
+    int (*tkCanvasDashParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 171 */
+    CONST86 char * (*tkCanvasDashPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 172 */
+    int (*tkOffsetParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 173 */
+    CONST86 char * (*tkOffsetPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 174 */
+    int (*tkPixelParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 175 */
+    CONST86 char * (*tkPixelPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 176 */
+    int (*tkOrientParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 177 */
+    CONST86 char * (*tkOrientPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 178 */
+    int (*tkSmoothParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, const char *value, char *widgRec, int offset); /* 179 */
+    CONST86 char * (*tkSmoothPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 180 */
+    void (*tkDrawAngledTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, double angle, int firstChar, int lastChar); /* 181 */
+    void (*tkUnderlineAngledTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, double angle, int underline); /* 182 */
+    int (*tkIntersectAngledTextLayout) (Tk_TextLayout layout, int x, int y, int width, int height, double angle); /* 183 */
+    void (*tkDrawAngledChars) (Display *display, Drawable drawable, GC gc, Tk_Font tkfont, const char *source, int numBytes, double x, double y, double angle); /* 184 */
 } TkIntStubs;
 
-#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)
-extern CONST TkIntStubs *tkIntStubsPtr;
-#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern const TkIntStubs *tkIntStubsPtr;
+#ifdef __cplusplus
+}
+#endif
 
-#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)
+#if defined(USE_TK_STUBS)
 
 /*
  * Inline function declarations:
  */
 
-#ifndef TkAllocWindow
 #define TkAllocWindow \
   (tkIntStubsPtr->tkAllocWindow) /* 0 */
-#endif
-#ifndef TkBezierPoints
 #define TkBezierPoints \
   (tkIntStubsPtr->tkBezierPoints) /* 1 */
-#endif
-#ifndef TkBezierScreenPoints
 #define TkBezierScreenPoints \
   (tkIntStubsPtr->tkBezierScreenPoints) /* 2 */
-#endif
-#ifndef TkBindDeadWindow
-#define TkBindDeadWindow \
-  (tkIntStubsPtr->tkBindDeadWindow) /* 3 */
-#endif
-#ifndef TkBindEventProc
+/* Slot 3 is reserved */
 #define TkBindEventProc \
   (tkIntStubsPtr->tkBindEventProc) /* 4 */
-#endif
-#ifndef TkBindFree
 #define TkBindFree \
   (tkIntStubsPtr->tkBindFree) /* 5 */
-#endif
-#ifndef TkBindInit
 #define TkBindInit \
   (tkIntStubsPtr->tkBindInit) /* 6 */
-#endif
-#ifndef TkChangeEventWindow
 #define TkChangeEventWindow \
   (tkIntStubsPtr->tkChangeEventWindow) /* 7 */
-#endif
-#ifndef TkClipInit
 #define TkClipInit \
   (tkIntStubsPtr->tkClipInit) /* 8 */
-#endif
-#ifndef TkComputeAnchor
 #define TkComputeAnchor \
   (tkIntStubsPtr->tkComputeAnchor) /* 9 */
-#endif
-#ifndef TkCopyAndGlobalEval
-#define TkCopyAndGlobalEval \
-  (tkIntStubsPtr->tkCopyAndGlobalEval) /* 10 */
-#endif
-#ifndef TkCreateBindingProcedure
-#define TkCreateBindingProcedure \
-  (tkIntStubsPtr->tkCreateBindingProcedure) /* 11 */
-#endif
-#ifndef TkCreateCursorFromData
+/* Slot 10 is reserved */
+/* Slot 11 is reserved */
 #define TkCreateCursorFromData \
   (tkIntStubsPtr->tkCreateCursorFromData) /* 12 */
-#endif
-#ifndef TkCreateFrame
 #define TkCreateFrame \
   (tkIntStubsPtr->tkCreateFrame) /* 13 */
-#endif
-#ifndef TkCreateMainWindow
 #define TkCreateMainWindow \
   (tkIntStubsPtr->tkCreateMainWindow) /* 14 */
-#endif
-#ifndef TkCurrentTime
 #define TkCurrentTime \
   (tkIntStubsPtr->tkCurrentTime) /* 15 */
-#endif
-#ifndef TkDeleteAllImages
 #define TkDeleteAllImages \
   (tkIntStubsPtr->tkDeleteAllImages) /* 16 */
-#endif
-#ifndef TkDoConfigureNotify
 #define TkDoConfigureNotify \
   (tkIntStubsPtr->tkDoConfigureNotify) /* 17 */
-#endif
-#ifndef TkDrawInsetFocusHighlight
 #define TkDrawInsetFocusHighlight \
   (tkIntStubsPtr->tkDrawInsetFocusHighlight) /* 18 */
-#endif
-#ifndef TkEventDeadWindow
 #define TkEventDeadWindow \
   (tkIntStubsPtr->tkEventDeadWindow) /* 19 */
-#endif
-#ifndef TkFillPolygon
 #define TkFillPolygon \
   (tkIntStubsPtr->tkFillPolygon) /* 20 */
-#endif
-#ifndef TkFindStateNum
 #define TkFindStateNum \
   (tkIntStubsPtr->tkFindStateNum) /* 21 */
-#endif
-#ifndef TkFindStateString
 #define TkFindStateString \
   (tkIntStubsPtr->tkFindStateString) /* 22 */
-#endif
-#ifndef TkFocusDeadWindow
 #define TkFocusDeadWindow \
   (tkIntStubsPtr->tkFocusDeadWindow) /* 23 */
-#endif
-#ifndef TkFocusFilterEvent
 #define TkFocusFilterEvent \
   (tkIntStubsPtr->tkFocusFilterEvent) /* 24 */
-#endif
-#ifndef TkFocusKeyEvent
 #define TkFocusKeyEvent \
   (tkIntStubsPtr->tkFocusKeyEvent) /* 25 */
-#endif
-#ifndef TkFontPkgInit
 #define TkFontPkgInit \
   (tkIntStubsPtr->tkFontPkgInit) /* 26 */
-#endif
-#ifndef TkFontPkgFree
 #define TkFontPkgFree \
   (tkIntStubsPtr->tkFontPkgFree) /* 27 */
-#endif
-#ifndef TkFreeBindingTags
 #define TkFreeBindingTags \
   (tkIntStubsPtr->tkFreeBindingTags) /* 28 */
-#endif
-#ifndef TkpFreeCursor
 #define TkpFreeCursor \
   (tkIntStubsPtr->tkpFreeCursor) /* 29 */
-#endif
-#ifndef TkGetBitmapData
 #define TkGetBitmapData \
   (tkIntStubsPtr->tkGetBitmapData) /* 30 */
-#endif
-#ifndef TkGetButtPoints
 #define TkGetButtPoints \
   (tkIntStubsPtr->tkGetButtPoints) /* 31 */
-#endif
-#ifndef TkGetCursorByName
 #define TkGetCursorByName \
   (tkIntStubsPtr->tkGetCursorByName) /* 32 */
-#endif
-#ifndef TkGetDefaultScreenName
 #define TkGetDefaultScreenName \
   (tkIntStubsPtr->tkGetDefaultScreenName) /* 33 */
-#endif
-#ifndef TkGetDisplay
 #define TkGetDisplay \
   (tkIntStubsPtr->tkGetDisplay) /* 34 */
-#endif
-#ifndef TkGetDisplayOf
 #define TkGetDisplayOf \
   (tkIntStubsPtr->tkGetDisplayOf) /* 35 */
-#endif
-#ifndef TkGetFocusWin
 #define TkGetFocusWin \
   (tkIntStubsPtr->tkGetFocusWin) /* 36 */
-#endif
-#ifndef TkGetInterpNames
 #define TkGetInterpNames \
   (tkIntStubsPtr->tkGetInterpNames) /* 37 */
-#endif
-#ifndef TkGetMiterPoints
 #define TkGetMiterPoints \
   (tkIntStubsPtr->tkGetMiterPoints) /* 38 */
-#endif
-#ifndef TkGetPointerCoords
 #define TkGetPointerCoords \
   (tkIntStubsPtr->tkGetPointerCoords) /* 39 */
-#endif
-#ifndef TkGetServerInfo
 #define TkGetServerInfo \
   (tkIntStubsPtr->tkGetServerInfo) /* 40 */
-#endif
-#ifndef TkGrabDeadWindow
 #define TkGrabDeadWindow \
   (tkIntStubsPtr->tkGrabDeadWindow) /* 41 */
-#endif
-#ifndef TkGrabState
 #define TkGrabState \
   (tkIntStubsPtr->tkGrabState) /* 42 */
-#endif
-#ifndef TkIncludePoint
 #define TkIncludePoint \
   (tkIntStubsPtr->tkIncludePoint) /* 43 */
-#endif
-#ifndef TkInOutEvents
 #define TkInOutEvents \
   (tkIntStubsPtr->tkInOutEvents) /* 44 */
-#endif
-#ifndef TkInstallFrameMenu
 #define TkInstallFrameMenu \
   (tkIntStubsPtr->tkInstallFrameMenu) /* 45 */
-#endif
-#ifndef TkKeysymToString
 #define TkKeysymToString \
   (tkIntStubsPtr->tkKeysymToString) /* 46 */
-#endif
-#ifndef TkLineToArea
 #define TkLineToArea \
   (tkIntStubsPtr->tkLineToArea) /* 47 */
-#endif
-#ifndef TkLineToPoint
 #define TkLineToPoint \
   (tkIntStubsPtr->tkLineToPoint) /* 48 */
-#endif
-#ifndef TkMakeBezierCurve
 #define TkMakeBezierCurve \
   (tkIntStubsPtr->tkMakeBezierCurve) /* 49 */
-#endif
-#ifndef TkMakeBezierPostscript
 #define TkMakeBezierPostscript \
   (tkIntStubsPtr->tkMakeBezierPostscript) /* 50 */
-#endif
-#ifndef TkOptionClassChanged
 #define TkOptionClassChanged \
   (tkIntStubsPtr->tkOptionClassChanged) /* 51 */
-#endif
-#ifndef TkOptionDeadWindow
 #define TkOptionDeadWindow \
   (tkIntStubsPtr->tkOptionDeadWindow) /* 52 */
-#endif
-#ifndef TkOvalToArea
 #define TkOvalToArea \
   (tkIntStubsPtr->tkOvalToArea) /* 53 */
-#endif
-#ifndef TkOvalToPoint
 #define TkOvalToPoint \
   (tkIntStubsPtr->tkOvalToPoint) /* 54 */
-#endif
-#ifndef TkpChangeFocus
 #define TkpChangeFocus \
   (tkIntStubsPtr->tkpChangeFocus) /* 55 */
-#endif
-#ifndef TkpCloseDisplay
 #define TkpCloseDisplay \
   (tkIntStubsPtr->tkpCloseDisplay) /* 56 */
-#endif
-#ifndef TkpClaimFocus
 #define TkpClaimFocus \
   (tkIntStubsPtr->tkpClaimFocus) /* 57 */
-#endif
-#ifndef TkpDisplayWarning
 #define TkpDisplayWarning \
   (tkIntStubsPtr->tkpDisplayWarning) /* 58 */
-#endif
-#ifndef TkpGetAppName
 #define TkpGetAppName \
   (tkIntStubsPtr->tkpGetAppName) /* 59 */
-#endif
-#ifndef TkpGetOtherWindow
 #define TkpGetOtherWindow \
   (tkIntStubsPtr->tkpGetOtherWindow) /* 60 */
-#endif
-#ifndef TkpGetWrapperWindow
 #define TkpGetWrapperWindow \
   (tkIntStubsPtr->tkpGetWrapperWindow) /* 61 */
-#endif
-#ifndef TkpInit
 #define TkpInit \
   (tkIntStubsPtr->tkpInit) /* 62 */
-#endif
-#ifndef TkpInitializeMenuBindings
 #define TkpInitializeMenuBindings \
   (tkIntStubsPtr->tkpInitializeMenuBindings) /* 63 */
-#endif
-#ifndef TkpMakeContainer
 #define TkpMakeContainer \
   (tkIntStubsPtr->tkpMakeContainer) /* 64 */
-#endif
-#ifndef TkpMakeMenuWindow
 #define TkpMakeMenuWindow \
   (tkIntStubsPtr->tkpMakeMenuWindow) /* 65 */
-#endif
-#ifndef TkpMakeWindow
 #define TkpMakeWindow \
   (tkIntStubsPtr->tkpMakeWindow) /* 66 */
-#endif
-#ifndef TkpMenuNotifyToplevelCreate
 #define TkpMenuNotifyToplevelCreate \
   (tkIntStubsPtr->tkpMenuNotifyToplevelCreate) /* 67 */
-#endif
-#ifndef TkpOpenDisplay
 #define TkpOpenDisplay \
   (tkIntStubsPtr->tkpOpenDisplay) /* 68 */
-#endif
-#ifndef TkPointerEvent
 #define TkPointerEvent \
   (tkIntStubsPtr->tkPointerEvent) /* 69 */
-#endif
-#ifndef TkPolygonToArea
 #define TkPolygonToArea \
   (tkIntStubsPtr->tkPolygonToArea) /* 70 */
-#endif
-#ifndef TkPolygonToPoint
 #define TkPolygonToPoint \
   (tkIntStubsPtr->tkPolygonToPoint) /* 71 */
-#endif
-#ifndef TkPositionInTree
 #define TkPositionInTree \
   (tkIntStubsPtr->tkPositionInTree) /* 72 */
-#endif
-#ifndef TkpRedirectKeyEvent
 #define TkpRedirectKeyEvent \
   (tkIntStubsPtr->tkpRedirectKeyEvent) /* 73 */
-#endif
-#ifndef TkpSetMainMenubar
 #define TkpSetMainMenubar \
   (tkIntStubsPtr->tkpSetMainMenubar) /* 74 */
-#endif
-#ifndef TkpUseWindow
 #define TkpUseWindow \
   (tkIntStubsPtr->tkpUseWindow) /* 75 */
-#endif
 /* Slot 76 is reserved */
-#ifndef TkQueueEventForAllChildren
 #define TkQueueEventForAllChildren \
   (tkIntStubsPtr->tkQueueEventForAllChildren) /* 77 */
-#endif
-#ifndef TkReadBitmapFile
 #define TkReadBitmapFile \
   (tkIntStubsPtr->tkReadBitmapFile) /* 78 */
-#endif
-#ifndef TkScrollWindow
 #define TkScrollWindow \
   (tkIntStubsPtr->tkScrollWindow) /* 79 */
-#endif
-#ifndef TkSelDeadWindow
 #define TkSelDeadWindow \
   (tkIntStubsPtr->tkSelDeadWindow) /* 80 */
-#endif
-#ifndef TkSelEventProc
 #define TkSelEventProc \
   (tkIntStubsPtr->tkSelEventProc) /* 81 */
-#endif
-#ifndef TkSelInit
 #define TkSelInit \
   (tkIntStubsPtr->tkSelInit) /* 82 */
-#endif
-#ifndef TkSelPropProc
 #define TkSelPropProc \
   (tkIntStubsPtr->tkSelPropProc) /* 83 */
-#endif
 /* Slot 84 is reserved */
-#ifndef TkSetWindowMenuBar
 #define TkSetWindowMenuBar \
   (tkIntStubsPtr->tkSetWindowMenuBar) /* 85 */
-#endif
-#ifndef TkStringToKeysym
 #define TkStringToKeysym \
   (tkIntStubsPtr->tkStringToKeysym) /* 86 */
-#endif
-#ifndef TkThickPolyLineToArea
 #define TkThickPolyLineToArea \
   (tkIntStubsPtr->tkThickPolyLineToArea) /* 87 */
-#endif
-#ifndef TkWmAddToColormapWindows
 #define TkWmAddToColormapWindows \
   (tkIntStubsPtr->tkWmAddToColormapWindows) /* 88 */
-#endif
-#ifndef TkWmDeadWindow
 #define TkWmDeadWindow \
   (tkIntStubsPtr->tkWmDeadWindow) /* 89 */
-#endif
-#ifndef TkWmFocusToplevel
 #define TkWmFocusToplevel \
   (tkIntStubsPtr->tkWmFocusToplevel) /* 90 */
-#endif
-#ifndef TkWmMapWindow
 #define TkWmMapWindow \
   (tkIntStubsPtr->tkWmMapWindow) /* 91 */
-#endif
-#ifndef TkWmNewWindow
 #define TkWmNewWindow \
   (tkIntStubsPtr->tkWmNewWindow) /* 92 */
-#endif
-#ifndef TkWmProtocolEventProc
 #define TkWmProtocolEventProc \
   (tkIntStubsPtr->tkWmProtocolEventProc) /* 93 */
-#endif
-#ifndef TkWmRemoveFromColormapWindows
 #define TkWmRemoveFromColormapWindows \
   (tkIntStubsPtr->tkWmRemoveFromColormapWindows) /* 94 */
-#endif
-#ifndef TkWmRestackToplevel
 #define TkWmRestackToplevel \
   (tkIntStubsPtr->tkWmRestackToplevel) /* 95 */
-#endif
-#ifndef TkWmSetClass
 #define TkWmSetClass \
   (tkIntStubsPtr->tkWmSetClass) /* 96 */
-#endif
-#ifndef TkWmUnmapWindow
 #define TkWmUnmapWindow \
   (tkIntStubsPtr->tkWmUnmapWindow) /* 97 */
-#endif
-#ifndef TkDebugBitmap
 #define TkDebugBitmap \
   (tkIntStubsPtr->tkDebugBitmap) /* 98 */
-#endif
-#ifndef TkDebugBorder
 #define TkDebugBorder \
   (tkIntStubsPtr->tkDebugBorder) /* 99 */
-#endif
-#ifndef TkDebugCursor
 #define TkDebugCursor \
   (tkIntStubsPtr->tkDebugCursor) /* 100 */
-#endif
-#ifndef TkDebugColor
 #define TkDebugColor \
   (tkIntStubsPtr->tkDebugColor) /* 101 */
-#endif
-#ifndef TkDebugConfig
 #define TkDebugConfig \
   (tkIntStubsPtr->tkDebugConfig) /* 102 */
-#endif
-#ifndef TkDebugFont
 #define TkDebugFont \
   (tkIntStubsPtr->tkDebugFont) /* 103 */
-#endif
-#ifndef TkFindStateNumObj
 #define TkFindStateNumObj \
   (tkIntStubsPtr->tkFindStateNumObj) /* 104 */
-#endif
-#ifndef TkGetBitmapPredefTable
 #define TkGetBitmapPredefTable \
   (tkIntStubsPtr->tkGetBitmapPredefTable) /* 105 */
-#endif
-#ifndef TkGetDisplayList
 #define TkGetDisplayList \
   (tkIntStubsPtr->tkGetDisplayList) /* 106 */
-#endif
-#ifndef TkGetMainInfoList
 #define TkGetMainInfoList \
   (tkIntStubsPtr->tkGetMainInfoList) /* 107 */
-#endif
-#ifndef TkGetWindowFromObj
 #define TkGetWindowFromObj \
   (tkIntStubsPtr->tkGetWindowFromObj) /* 108 */
-#endif
-#ifndef TkpGetString
 #define TkpGetString \
   (tkIntStubsPtr->tkpGetString) /* 109 */
-#endif
-#ifndef TkpGetSubFonts
 #define TkpGetSubFonts \
   (tkIntStubsPtr->tkpGetSubFonts) /* 110 */
-#endif
-#ifndef TkpGetSystemDefault
 #define TkpGetSystemDefault \
   (tkIntStubsPtr->tkpGetSystemDefault) /* 111 */
-#endif
-#ifndef TkpMenuThreadInit
 #define TkpMenuThreadInit \
   (tkIntStubsPtr->tkpMenuThreadInit) /* 112 */
-#endif
-#ifdef __WIN32__ /* WIN */
-#ifndef TkClipBox
-#define TkClipBox \
-  (tkIntStubsPtr->tkClipBox) /* 113 */
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkClipBox
 #define TkClipBox \
   (tkIntStubsPtr->tkClipBox) /* 113 */
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkCreateRegion
-#define TkCreateRegion \
-  (tkIntStubsPtr->tkCreateRegion) /* 114 */
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkCreateRegion
 #define TkCreateRegion \
   (tkIntStubsPtr->tkCreateRegion) /* 114 */
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkDestroyRegion
-#define TkDestroyRegion \
-  (tkIntStubsPtr->tkDestroyRegion) /* 115 */
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkDestroyRegion
 #define TkDestroyRegion \
   (tkIntStubsPtr->tkDestroyRegion) /* 115 */
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkIntersectRegion
-#define TkIntersectRegion \
-  (tkIntStubsPtr->tkIntersectRegion) /* 116 */
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkIntersectRegion
 #define TkIntersectRegion \
   (tkIntStubsPtr->tkIntersectRegion) /* 116 */
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkRectInRegion
-#define TkRectInRegion \
-  (tkIntStubsPtr->tkRectInRegion) /* 117 */
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkRectInRegion
 #define TkRectInRegion \
   (tkIntStubsPtr->tkRectInRegion) /* 117 */
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkSetRegion
-#define TkSetRegion \
-  (tkIntStubsPtr->tkSetRegion) /* 118 */
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkSetRegion
 #define TkSetRegion \
   (tkIntStubsPtr->tkSetRegion) /* 118 */
-#endif
-#endif /* AQUA */
-#ifdef __WIN32__ /* WIN */
-#ifndef TkUnionRectWithRegion
 #define TkUnionRectWithRegion \
   (tkIntStubsPtr->tkUnionRectWithRegion) /* 119 */
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkUnionRectWithRegion
-#define TkUnionRectWithRegion \
-  (tkIntStubsPtr->tkUnionRectWithRegion) /* 119 */
-#endif
-#endif /* AQUA */
 /* Slot 120 is reserved */
 #ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkpCreateNativeBitmap
 #define TkpCreateNativeBitmap \
   (tkIntStubsPtr->tkpCreateNativeBitmap) /* 121 */
-#endif
 #endif /* AQUA */
 #ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkpDefineNativeBitmaps
 #define TkpDefineNativeBitmaps \
   (tkIntStubsPtr->tkpDefineNativeBitmaps) /* 122 */
-#endif
 #endif /* AQUA */
 /* Slot 123 is reserved */
 #ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkpGetNativeAppBitmap
 #define TkpGetNativeAppBitmap \
   (tkIntStubsPtr->tkpGetNativeAppBitmap) /* 124 */
-#endif
 #endif /* AQUA */
 /* Slot 125 is reserved */
 /* Slot 126 is reserved */
@@ -1787,110 +1038,140 @@
 /* Slot 132 is reserved */
 /* Slot 133 is reserved */
 /* Slot 134 is reserved */
-#ifndef TkpDrawHighlightBorder
 #define TkpDrawHighlightBorder \
   (tkIntStubsPtr->tkpDrawHighlightBorder) /* 135 */
-#endif
-#ifndef TkSetFocusWin
 #define TkSetFocusWin \
   (tkIntStubsPtr->tkSetFocusWin) /* 136 */
-#endif
-#ifndef TkpSetKeycodeAndState
 #define TkpSetKeycodeAndState \
   (tkIntStubsPtr->tkpSetKeycodeAndState) /* 137 */
-#endif
-#ifndef TkpGetKeySym
 #define TkpGetKeySym \
   (tkIntStubsPtr->tkpGetKeySym) /* 138 */
-#endif
-#ifndef TkpInitKeymapInfo
 #define TkpInitKeymapInfo \
   (tkIntStubsPtr->tkpInitKeymapInfo) /* 139 */
-#endif
-#ifndef TkPhotoGetValidRegion
 #define TkPhotoGetValidRegion \
   (tkIntStubsPtr->tkPhotoGetValidRegion) /* 140 */
-#endif
-#ifndef TkWmStackorderToplevel
 #define TkWmStackorderToplevel \
   (tkIntStubsPtr->tkWmStackorderToplevel) /* 141 */
-#endif
-#ifndef TkFocusFree
 #define TkFocusFree \
   (tkIntStubsPtr->tkFocusFree) /* 142 */
-#endif
-#ifndef TkClipCleanup
 #define TkClipCleanup \
   (tkIntStubsPtr->tkClipCleanup) /* 143 */
-#endif
-#ifndef TkGCCleanup
 #define TkGCCleanup \
   (tkIntStubsPtr->tkGCCleanup) /* 144 */
-#endif
-#ifdef __WIN32__ /* WIN */
-#ifndef TkSubtractRegion
-#define TkSubtractRegion \
-  (tkIntStubsPtr->tkSubtractRegion) /* 145 */
-#endif
-#endif /* WIN */
-#ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkSubtractRegion
 #define TkSubtractRegion \
   (tkIntStubsPtr->tkSubtractRegion) /* 145 */
-#endif
-#endif /* AQUA */
-#ifndef TkStylePkgInit
 #define TkStylePkgInit \
   (tkIntStubsPtr->tkStylePkgInit) /* 146 */
-#endif
-#ifndef TkStylePkgFree
 #define TkStylePkgFree \
   (tkIntStubsPtr->tkStylePkgFree) /* 147 */
-#endif
-#ifndef TkToplevelWindowForCommand
 #define TkToplevelWindowForCommand \
   (tkIntStubsPtr->tkToplevelWindowForCommand) /* 148 */
-#endif
-#ifndef TkGetOptionSpec
 #define TkGetOptionSpec \
   (tkIntStubsPtr->tkGetOptionSpec) /* 149 */
-#endif
-#ifndef TkMakeRawCurve
 #define TkMakeRawCurve \
   (tkIntStubsPtr->tkMakeRawCurve) /* 150 */
-#endif
-#ifndef TkMakeRawCurvePostscript
 #define TkMakeRawCurvePostscript \
   (tkIntStubsPtr->tkMakeRawCurvePostscript) /* 151 */
-#endif
-#ifndef TkpDrawFrame
 #define TkpDrawFrame \
   (tkIntStubsPtr->tkpDrawFrame) /* 152 */
-#endif
-#ifndef TkCreateThreadExitHandler
 #define TkCreateThreadExitHandler \
   (tkIntStubsPtr->tkCreateThreadExitHandler) /* 153 */
-#endif
-#ifndef TkDeleteThreadExitHandler
 #define TkDeleteThreadExitHandler \
   (tkIntStubsPtr->tkDeleteThreadExitHandler) /* 154 */
-#endif
 /* Slot 155 is reserved */
-#ifndef TkpTestembedCmd
 #define TkpTestembedCmd \
   (tkIntStubsPtr->tkpTestembedCmd) /* 156 */
-#endif
-#ifndef TkpTesttextCmd
 #define TkpTesttextCmd \
   (tkIntStubsPtr->tkpTesttextCmd) /* 157 */
-#endif
+#define TkSelGetSelection \
+  (tkIntStubsPtr->tkSelGetSelection) /* 158 */
+#define TkTextGetIndex \
+  (tkIntStubsPtr->tkTextGetIndex) /* 159 */
+#define TkTextIndexBackBytes \
+  (tkIntStubsPtr->tkTextIndexBackBytes) /* 160 */
+#define TkTextIndexForwBytes \
+  (tkIntStubsPtr->tkTextIndexForwBytes) /* 161 */
+#define TkTextMakeByteIndex \
+  (tkIntStubsPtr->tkTextMakeByteIndex) /* 162 */
+#define TkTextPrintIndex \
+  (tkIntStubsPtr->tkTextPrintIndex) /* 163 */
+#define TkTextSetMark \
+  (tkIntStubsPtr->tkTextSetMark) /* 164 */
+#define TkTextXviewCmd \
+  (tkIntStubsPtr->tkTextXviewCmd) /* 165 */
+#define TkTextChanged \
+  (tkIntStubsPtr->tkTextChanged) /* 166 */
+#define TkBTreeNumLines \
+  (tkIntStubsPtr->tkBTreeNumLines) /* 167 */
+#define TkTextInsertDisplayProc \
+  (tkIntStubsPtr->tkTextInsertDisplayProc) /* 168 */
+#define TkStateParseProc \
+  (tkIntStubsPtr->tkStateParseProc) /* 169 */
+#define TkStatePrintProc \
+  (tkIntStubsPtr->tkStatePrintProc) /* 170 */
+#define TkCanvasDashParseProc \
+  (tkIntStubsPtr->tkCanvasDashParseProc) /* 171 */
+#define TkCanvasDashPrintProc \
+  (tkIntStubsPtr->tkCanvasDashPrintProc) /* 172 */
+#define TkOffsetParseProc \
+  (tkIntStubsPtr->tkOffsetParseProc) /* 173 */
+#define TkOffsetPrintProc \
+  (tkIntStubsPtr->tkOffsetPrintProc) /* 174 */
+#define TkPixelParseProc \
+  (tkIntStubsPtr->tkPixelParseProc) /* 175 */
+#define TkPixelPrintProc \
+  (tkIntStubsPtr->tkPixelPrintProc) /* 176 */
+#define TkOrientParseProc \
+  (tkIntStubsPtr->tkOrientParseProc) /* 177 */
+#define TkOrientPrintProc \
+  (tkIntStubsPtr->tkOrientPrintProc) /* 178 */
+#define TkSmoothParseProc \
+  (tkIntStubsPtr->tkSmoothParseProc) /* 179 */
+#define TkSmoothPrintProc \
+  (tkIntStubsPtr->tkSmoothPrintProc) /* 180 */
+#define TkDrawAngledTextLayout \
+  (tkIntStubsPtr->tkDrawAngledTextLayout) /* 181 */
+#define TkUnderlineAngledTextLayout \
+  (tkIntStubsPtr->tkUnderlineAngledTextLayout) /* 182 */
+#define TkIntersectAngledTextLayout \
+  (tkIntStubsPtr->tkIntersectAngledTextLayout) /* 183 */
+#define TkDrawAngledChars \
+  (tkIntStubsPtr->tkDrawAngledChars) /* 184 */
 
-#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */
+#endif /* defined(USE_TK_STUBS) */
 
 /* !END!: Do not edit above this line. */
 
 #undef TCL_STORAGE_CLASS
 #define TCL_STORAGE_CLASS DLLIMPORT
 
+/*
+ * On X11, these macros are just wrappers for the equivalent X Region calls.
+ */
+#if !(defined(__WIN32__) || defined(__CYGWIN__) || defined(MAC_OSX_TK)) /* X11 */
+
+#undef TkClipBox
+#undef TkCreateRegion
+#undef TkDestroyRegion
+#undef TkIntersectRegion
+#undef TkRectInRegion
+#undef TkSetRegion
+#undef TkSubtractRegion
+#undef TkUnionRectWithRegion
+
+#define TkClipBox(rgn, rect) XClipBox((Region) rgn, rect)
+#define TkCreateRegion() (TkRegion) XCreateRegion()
+#define TkDestroyRegion(rgn) XDestroyRegion((Region) rgn)
+#define TkIntersectRegion(a, b, r) XIntersectRegion((Region) a, \
+  (Region) b, (Region) r)
+#define TkRectInRegion(r, x, y, w, h) XRectInRegion((Region) r, x, y, w, h)
+#define TkSetRegion(d, gc, rgn) XSetRegion(d, gc, (Region) rgn)
+#define TkSubtractRegion(a, b, r) XSubtractRegion((Region) a, \
+  (Region) b, (Region) r)
+#define TkUnionRectWithRegion(rect, src, ret) XUnionRectWithRegion(rect, \
+  (Region) src, (Region) ret)
+
+#endif /* UNIX */
+
 #endif /* _TKINTDECLS */
 
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkIntPlatDecls.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkIntPlatDecls.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkIntPlatDecls.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkIntPlatDecls.h	2019-02-01 16:20:04.000000000 +0100
@@ -8,8 +8,6 @@
  *
  * Copyright (c) 1998-1999 by Scriptics Corporation.
  * All rights reserved.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TKINTPLATDECLS
@@ -32,1030 +30,626 @@
  * Exported function declarations:
  */
 
-#ifdef __WIN32__ /* WIN */
-#ifndef TkAlignImageData_TCL_DECLARED
-#define TkAlignImageData_TCL_DECLARED
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
 /* 0 */
-EXTERN char *    TkAlignImageData (XImage * image, int alignment, 
+EXTERN char *    TkAlignImageData(XImage *image, int alignment,
         int bitOrder);
-#endif
 /* Slot 1 is reserved */
-#ifndef TkGenerateActivateEvents_TCL_DECLARED
-#define TkGenerateActivateEvents_TCL_DECLARED
 /* 2 */
-EXTERN void    TkGenerateActivateEvents (TkWindow * winPtr, 
+EXTERN void    TkGenerateActivateEvents(TkWindow *winPtr,
         int active);
-#endif
-#ifndef TkpGetMS_TCL_DECLARED
-#define TkpGetMS_TCL_DECLARED
 /* 3 */
-EXTERN unsigned long  TkpGetMS (void);
-#endif
-#ifndef TkPointerDeadWindow_TCL_DECLARED
-#define TkPointerDeadWindow_TCL_DECLARED
+EXTERN unsigned long  TkpGetMS(void);
 /* 4 */
-EXTERN void    TkPointerDeadWindow (TkWindow * winPtr);
-#endif
-#ifndef TkpPrintWindowId_TCL_DECLARED
-#define TkpPrintWindowId_TCL_DECLARED
+EXTERN void    TkPointerDeadWindow(TkWindow *winPtr);
 /* 5 */
-EXTERN void    TkpPrintWindowId (char * buf, Window window);
-#endif
-#ifndef TkpScanWindowId_TCL_DECLARED
-#define TkpScanWindowId_TCL_DECLARED
+EXTERN void    TkpPrintWindowId(char *buf, Window window);
 /* 6 */
-EXTERN int    TkpScanWindowId (Tcl_Interp * interp, 
-        CONST char * string, Window * idPtr);
-#endif
-#ifndef TkpSetCapture_TCL_DECLARED
-#define TkpSetCapture_TCL_DECLARED
+EXTERN int    TkpScanWindowId(Tcl_Interp *interp,
+        const char *string, Window *idPtr);
 /* 7 */
-EXTERN void    TkpSetCapture (TkWindow * winPtr);
-#endif
-#ifndef TkpSetCursor_TCL_DECLARED
-#define TkpSetCursor_TCL_DECLARED
+EXTERN void    TkpSetCapture(TkWindow *winPtr);
 /* 8 */
-EXTERN void    TkpSetCursor (TkpCursor cursor);
-#endif
-#ifndef TkpWmSetState_TCL_DECLARED
-#define TkpWmSetState_TCL_DECLARED
+EXTERN void    TkpSetCursor(TkpCursor cursor);
 /* 9 */
-EXTERN void    TkpWmSetState (TkWindow * winPtr, int state);
-#endif
-#ifndef TkSetPixmapColormap_TCL_DECLARED
-#define TkSetPixmapColormap_TCL_DECLARED
+EXTERN int    TkpWmSetState(TkWindow *winPtr, int state);
 /* 10 */
-EXTERN void    TkSetPixmapColormap (Pixmap pixmap, 
-        Colormap colormap);
-#endif
-#ifndef TkWinCancelMouseTimer_TCL_DECLARED
-#define TkWinCancelMouseTimer_TCL_DECLARED
+EXTERN void    TkSetPixmapColormap(Pixmap pixmap, Colormap colormap);
 /* 11 */
-EXTERN void    TkWinCancelMouseTimer (void);
-#endif
-#ifndef TkWinClipboardRender_TCL_DECLARED
-#define TkWinClipboardRender_TCL_DECLARED
+EXTERN void    TkWinCancelMouseTimer(void);
 /* 12 */
-EXTERN void    TkWinClipboardRender (TkDisplay * dispPtr, 
-        UINT format);
-#endif
-#ifndef TkWinEmbeddedEventProc_TCL_DECLARED
-#define TkWinEmbeddedEventProc_TCL_DECLARED
+EXTERN void    TkWinClipboardRender(TkDisplay *dispPtr, UINT format);
 /* 13 */
-EXTERN LRESULT    TkWinEmbeddedEventProc (HWND hwnd, UINT message, 
+EXTERN LRESULT    TkWinEmbeddedEventProc(HWND hwnd, UINT message,
         WPARAM wParam, LPARAM lParam);
-#endif
-#ifndef TkWinFillRect_TCL_DECLARED
-#define TkWinFillRect_TCL_DECLARED
 /* 14 */
-EXTERN void    TkWinFillRect (HDC dc, int x, int y, int width, 
+EXTERN void    TkWinFillRect(HDC dc, int x, int y, int width,
         int height, int pixel);
-#endif
-#ifndef TkWinGetBorderPixels_TCL_DECLARED
-#define TkWinGetBorderPixels_TCL_DECLARED
 /* 15 */
-EXTERN COLORREF    TkWinGetBorderPixels (Tk_Window tkwin, 
+EXTERN COLORREF    TkWinGetBorderPixels(Tk_Window tkwin,
         Tk_3DBorder border, int which);
-#endif
-#ifndef TkWinGetDrawableDC_TCL_DECLARED
-#define TkWinGetDrawableDC_TCL_DECLARED
 /* 16 */
-EXTERN HDC    TkWinGetDrawableDC (Display * display, Drawable d, 
-        TkWinDCState * state);
-#endif
-#ifndef TkWinGetModifierState_TCL_DECLARED
-#define TkWinGetModifierState_TCL_DECLARED
+EXTERN HDC    TkWinGetDrawableDC(Display *display, Drawable d,
+        TkWinDCState *state);
 /* 17 */
-EXTERN int    TkWinGetModifierState (void);
-#endif
-#ifndef TkWinGetSystemPalette_TCL_DECLARED
-#define TkWinGetSystemPalette_TCL_DECLARED
+EXTERN int    TkWinGetModifierState(void);
 /* 18 */
-EXTERN HPALETTE    TkWinGetSystemPalette (void);
-#endif
-#ifndef TkWinGetWrapperWindow_TCL_DECLARED
-#define TkWinGetWrapperWindow_TCL_DECLARED
+EXTERN HPALETTE    TkWinGetSystemPalette(void);
 /* 19 */
-EXTERN HWND    TkWinGetWrapperWindow (Tk_Window tkwin);
-#endif
-#ifndef TkWinHandleMenuEvent_TCL_DECLARED
-#define TkWinHandleMenuEvent_TCL_DECLARED
+EXTERN HWND    TkWinGetWrapperWindow(Tk_Window tkwin);
 /* 20 */
-EXTERN int    TkWinHandleMenuEvent (HWND * phwnd, UINT * pMessage, 
-        WPARAM * pwParam, LPARAM * plParam, 
-        LRESULT * plResult);
-#endif
-#ifndef TkWinIndexOfColor_TCL_DECLARED
-#define TkWinIndexOfColor_TCL_DECLARED
+EXTERN int    TkWinHandleMenuEvent(HWND *phwnd, UINT *pMessage,
+        WPARAM *pwParam, LPARAM *plParam,
+        LRESULT *plResult);
 /* 21 */
-EXTERN int    TkWinIndexOfColor (XColor * colorPtr);
-#endif
-#ifndef TkWinReleaseDrawableDC_TCL_DECLARED
-#define TkWinReleaseDrawableDC_TCL_DECLARED
+EXTERN int    TkWinIndexOfColor(XColor *colorPtr);
 /* 22 */
-EXTERN void    TkWinReleaseDrawableDC (Drawable d, HDC hdc, 
-        TkWinDCState * state);
-#endif
-#ifndef TkWinResendEvent_TCL_DECLARED
-#define TkWinResendEvent_TCL_DECLARED
+EXTERN void    TkWinReleaseDrawableDC(Drawable d, HDC hdc,
+        TkWinDCState *state);
 /* 23 */
-EXTERN LRESULT    TkWinResendEvent (WNDPROC wndproc, HWND hwnd, 
-        XEvent * eventPtr);
-#endif
-#ifndef TkWinSelectPalette_TCL_DECLARED
-#define TkWinSelectPalette_TCL_DECLARED
+EXTERN LRESULT    TkWinResendEvent(WNDPROC wndproc, HWND hwnd,
+        XEvent *eventPtr);
 /* 24 */
-EXTERN HPALETTE    TkWinSelectPalette (HDC dc, Colormap colormap);
-#endif
-#ifndef TkWinSetMenu_TCL_DECLARED
-#define TkWinSetMenu_TCL_DECLARED
+EXTERN HPALETTE    TkWinSelectPalette(HDC dc, Colormap colormap);
 /* 25 */
-EXTERN void    TkWinSetMenu (Tk_Window tkwin, HMENU hMenu);
-#endif
-#ifndef TkWinSetWindowPos_TCL_DECLARED
-#define TkWinSetWindowPos_TCL_DECLARED
+EXTERN void    TkWinSetMenu(Tk_Window tkwin, HMENU hMenu);
 /* 26 */
-EXTERN void    TkWinSetWindowPos (HWND hwnd, HWND siblingHwnd, 
+EXTERN void    TkWinSetWindowPos(HWND hwnd, HWND siblingHwnd,
         int pos);
-#endif
-#ifndef TkWinWmCleanup_TCL_DECLARED
-#define TkWinWmCleanup_TCL_DECLARED
 /* 27 */
-EXTERN void    TkWinWmCleanup (HINSTANCE hInstance);
-#endif
-#ifndef TkWinXCleanup_TCL_DECLARED
-#define TkWinXCleanup_TCL_DECLARED
+EXTERN void    TkWinWmCleanup(HINSTANCE hInstance);
 /* 28 */
-EXTERN void    TkWinXCleanup (ClientData clientData);
-#endif
-#ifndef TkWinXInit_TCL_DECLARED
-#define TkWinXInit_TCL_DECLARED
+EXTERN void    TkWinXCleanup(ClientData clientData);
 /* 29 */
-EXTERN void    TkWinXInit (HINSTANCE hInstance);
-#endif
-#ifndef TkWinSetForegroundWindow_TCL_DECLARED
-#define TkWinSetForegroundWindow_TCL_DECLARED
+EXTERN void    TkWinXInit(HINSTANCE hInstance);
 /* 30 */
-EXTERN void    TkWinSetForegroundWindow (TkWindow * winPtr);
-#endif
-#ifndef TkWinDialogDebug_TCL_DECLARED
-#define TkWinDialogDebug_TCL_DECLARED
+EXTERN void    TkWinSetForegroundWindow(TkWindow *winPtr);
 /* 31 */
-EXTERN void    TkWinDialogDebug (int debug);
-#endif
-#ifndef TkWinGetMenuSystemDefault_TCL_DECLARED
-#define TkWinGetMenuSystemDefault_TCL_DECLARED
+EXTERN void    TkWinDialogDebug(int debug);
 /* 32 */
-EXTERN Tcl_Obj *  TkWinGetMenuSystemDefault (Tk_Window tkwin, 
-        CONST char * dbName, CONST char * className);
-#endif
-#ifndef TkWinGetPlatformId_TCL_DECLARED
-#define TkWinGetPlatformId_TCL_DECLARED
+EXTERN Tcl_Obj *  TkWinGetMenuSystemDefault(Tk_Window tkwin,
+        const char *dbName, const char *className);
 /* 33 */
-EXTERN int    TkWinGetPlatformId (void);
-#endif
-#ifndef TkWinSetHINSTANCE_TCL_DECLARED
-#define TkWinSetHINSTANCE_TCL_DECLARED
+EXTERN int    TkWinGetPlatformId(void);
 /* 34 */
-EXTERN void    TkWinSetHINSTANCE (HINSTANCE hInstance);
-#endif
-#ifndef TkWinGetPlatformTheme_TCL_DECLARED
-#define TkWinGetPlatformTheme_TCL_DECLARED
+EXTERN void    TkWinSetHINSTANCE(HINSTANCE hInstance);
 /* 35 */
-EXTERN int    TkWinGetPlatformTheme (void);
-#endif
+EXTERN int    TkWinGetPlatformTheme(void);
+/* 36 */
+EXTERN LRESULT __stdcall TkWinChildProc(HWND hwnd, UINT message,
+        WPARAM wParam, LPARAM lParam);
+/* 37 */
+EXTERN void    TkCreateXEventSource(void);
+/* 38 */
+EXTERN int    TkpCmapStressed(Tk_Window tkwin, Colormap colormap);
+/* 39 */
+EXTERN void    TkpSync(Display *display);
+/* 40 */
+EXTERN Window    TkUnixContainerId(TkWindow *winPtr);
+/* 41 */
+EXTERN int    TkUnixDoOneXEvent(Tcl_Time *timePtr);
+/* 42 */
+EXTERN void    TkUnixSetMenubar(Tk_Window tkwin, Tk_Window menubar);
+/* 43 */
+EXTERN void    TkWmCleanup(TkDisplay *dispPtr);
+/* 44 */
+EXTERN void    TkSendCleanup(TkDisplay *dispPtr);
+/* 45 */
+EXTERN int    TkpTestsendCmd(ClientData clientData,
+        Tcl_Interp *interp, int argc,
+        const char **argv);
 #endif /* WIN */
 #ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkGenerateActivateEvents_TCL_DECLARED
-#define TkGenerateActivateEvents_TCL_DECLARED
 /* 0 */
-EXTERN void    TkGenerateActivateEvents (TkWindow * winPtr, 
+EXTERN void    TkGenerateActivateEvents(TkWindow *winPtr,
         int active);
-#endif
 /* Slot 1 is reserved */
 /* Slot 2 is reserved */
-#ifndef TkPointerDeadWindow_TCL_DECLARED
-#define TkPointerDeadWindow_TCL_DECLARED
 /* 3 */
-EXTERN void    TkPointerDeadWindow (TkWindow * winPtr);
-#endif
-#ifndef TkpSetCapture_TCL_DECLARED
-#define TkpSetCapture_TCL_DECLARED
+EXTERN void    TkPointerDeadWindow(TkWindow *winPtr);
 /* 4 */
-EXTERN void    TkpSetCapture (TkWindow * winPtr);
-#endif
-#ifndef TkpSetCursor_TCL_DECLARED
-#define TkpSetCursor_TCL_DECLARED
+EXTERN void    TkpSetCapture(TkWindow *winPtr);
 /* 5 */
-EXTERN void    TkpSetCursor (TkpCursor cursor);
-#endif
-#ifndef TkpWmSetState_TCL_DECLARED
-#define TkpWmSetState_TCL_DECLARED
+EXTERN void    TkpSetCursor(TkpCursor cursor);
 /* 6 */
-EXTERN void    TkpWmSetState (TkWindow * winPtr, int state);
-#endif
-#ifndef TkAboutDlg_TCL_DECLARED
-#define TkAboutDlg_TCL_DECLARED
+EXTERN void    TkpWmSetState(TkWindow *winPtr, int state);
 /* 7 */
-EXTERN void    TkAboutDlg (void);
-#endif
-#ifndef TkMacOSXButtonKeyState_TCL_DECLARED
-#define TkMacOSXButtonKeyState_TCL_DECLARED
+EXTERN void    TkAboutDlg(void);
 /* 8 */
-EXTERN unsigned int  TkMacOSXButtonKeyState (void);
-#endif
-#ifndef TkMacOSXClearMenubarActive_TCL_DECLARED
-#define TkMacOSXClearMenubarActive_TCL_DECLARED
+EXTERN unsigned int  TkMacOSXButtonKeyState(void);
 /* 9 */
-EXTERN void    TkMacOSXClearMenubarActive (void);
-#endif
-#ifndef TkMacOSXDispatchMenuEvent_TCL_DECLARED
-#define TkMacOSXDispatchMenuEvent_TCL_DECLARED
+EXTERN void    TkMacOSXClearMenubarActive(void);
 /* 10 */
-EXTERN int    TkMacOSXDispatchMenuEvent (int menuID, int index);
-#endif
-#ifndef TkMacOSXInstallCursor_TCL_DECLARED
-#define TkMacOSXInstallCursor_TCL_DECLARED
+EXTERN int    TkMacOSXDispatchMenuEvent(int menuID, int index);
 /* 11 */
-EXTERN void    TkMacOSXInstallCursor (int resizeOverride);
-#endif
-#ifndef TkMacOSXHandleTearoffMenu_TCL_DECLARED
-#define TkMacOSXHandleTearoffMenu_TCL_DECLARED
+EXTERN void    TkMacOSXInstallCursor(int resizeOverride);
 /* 12 */
-EXTERN void    TkMacOSXHandleTearoffMenu (void);
-#endif
+EXTERN void    TkMacOSXHandleTearoffMenu(void);
 /* Slot 13 is reserved */
-#ifndef TkMacOSXDoHLEvent_TCL_DECLARED
-#define TkMacOSXDoHLEvent_TCL_DECLARED
 /* 14 */
-EXTERN int    TkMacOSXDoHLEvent (EventRecord * theEvent);
-#endif
+EXTERN int    TkMacOSXDoHLEvent(void *theEvent);
 /* Slot 15 is reserved */
-#ifndef TkMacOSXGetXWindow_TCL_DECLARED
-#define TkMacOSXGetXWindow_TCL_DECLARED
 /* 16 */
-EXTERN Window    TkMacOSXGetXWindow (WindowRef macWinPtr);
-#endif
-#ifndef TkMacOSXGrowToplevel_TCL_DECLARED
-#define TkMacOSXGrowToplevel_TCL_DECLARED
+EXTERN Window    TkMacOSXGetXWindow(void *macWinPtr);
 /* 17 */
-EXTERN int    TkMacOSXGrowToplevel (WindowRef whichWindow, 
-        Point start);
-#endif
-#ifndef TkMacOSXHandleMenuSelect_TCL_DECLARED
-#define TkMacOSXHandleMenuSelect_TCL_DECLARED
+EXTERN int    TkMacOSXGrowToplevel(void *whichWindow, XPoint start);
 /* 18 */
-EXTERN void    TkMacOSXHandleMenuSelect (MenuID theMenu, 
-        MenuItemIndex theItem, int optionKeyPressed);
-#endif
+EXTERN void    TkMacOSXHandleMenuSelect(short theMenu,
+        unsigned short theItem, int optionKeyPressed);
 /* Slot 19 is reserved */
 /* Slot 20 is reserved */
-#ifndef TkMacOSXInvalidateWindow_TCL_DECLARED
-#define TkMacOSXInvalidateWindow_TCL_DECLARED
 /* 21 */
-EXTERN void    TkMacOSXInvalidateWindow (MacDrawable * macWin, 
+EXTERN void    TkMacOSXInvalidateWindow(MacDrawable *macWin,
         int flag);
-#endif
-#ifndef TkMacOSXIsCharacterMissing_TCL_DECLARED
-#define TkMacOSXIsCharacterMissing_TCL_DECLARED
 /* 22 */
-EXTERN int    TkMacOSXIsCharacterMissing (Tk_Font tkfont, 
+EXTERN int    TkMacOSXIsCharacterMissing(Tk_Font tkfont,
         unsigned int searchChar);
-#endif
-#ifndef TkMacOSXMakeRealWindowExist_TCL_DECLARED
-#define TkMacOSXMakeRealWindowExist_TCL_DECLARED
 /* 23 */
-EXTERN void    TkMacOSXMakeRealWindowExist (TkWindow * winPtr);
-#endif
-#ifndef TkMacOSXMakeStippleMap_TCL_DECLARED
-#define TkMacOSXMakeStippleMap_TCL_DECLARED
+EXTERN void    TkMacOSXMakeRealWindowExist(TkWindow *winPtr);
 /* 24 */
-EXTERN BitMapPtr  TkMacOSXMakeStippleMap (Drawable d1, Drawable d2);
-#endif
-#ifndef TkMacOSXMenuClick_TCL_DECLARED
-#define TkMacOSXMenuClick_TCL_DECLARED
+EXTERN void *    TkMacOSXMakeStippleMap(Drawable d1, Drawable d2);
 /* 25 */
-EXTERN void    TkMacOSXMenuClick (void);
-#endif
-#ifndef TkMacOSXRegisterOffScreenWindow_TCL_DECLARED
-#define TkMacOSXRegisterOffScreenWindow_TCL_DECLARED
+EXTERN void    TkMacOSXMenuClick(void);
 /* 26 */
-EXTERN void    TkMacOSXRegisterOffScreenWindow (Window window, 
-        GWorldPtr portPtr);
-#endif
-#ifndef TkMacOSXResizable_TCL_DECLARED
-#define TkMacOSXResizable_TCL_DECLARED
+EXTERN void    TkMacOSXRegisterOffScreenWindow(Window window,
+        void *portPtr);
 /* 27 */
-EXTERN int    TkMacOSXResizable (TkWindow * winPtr);
-#endif
-#ifndef TkMacOSXSetHelpMenuItemCount_TCL_DECLARED
-#define TkMacOSXSetHelpMenuItemCount_TCL_DECLARED
+EXTERN int    TkMacOSXResizable(TkWindow *winPtr);
 /* 28 */
-EXTERN void    TkMacOSXSetHelpMenuItemCount (void);
-#endif
-#ifndef TkMacOSXSetScrollbarGrow_TCL_DECLARED
-#define TkMacOSXSetScrollbarGrow_TCL_DECLARED
+EXTERN void    TkMacOSXSetHelpMenuItemCount(void);
 /* 29 */
-EXTERN void    TkMacOSXSetScrollbarGrow (TkWindow * winPtr, 
-        int flag);
-#endif
-#ifndef TkMacOSXSetUpClippingRgn_TCL_DECLARED
-#define TkMacOSXSetUpClippingRgn_TCL_DECLARED
+EXTERN void    TkMacOSXSetScrollbarGrow(TkWindow *winPtr, int flag);
 /* 30 */
-EXTERN void    TkMacOSXSetUpClippingRgn (Drawable drawable);
-#endif
-#ifndef TkMacOSXSetUpGraphicsPort_TCL_DECLARED
-#define TkMacOSXSetUpGraphicsPort_TCL_DECLARED
+EXTERN void    TkMacOSXSetUpClippingRgn(Drawable drawable);
 /* 31 */
-EXTERN void    TkMacOSXSetUpGraphicsPort (GC gc, GWorldPtr destPort);
-#endif
-#ifndef TkMacOSXUpdateClipRgn_TCL_DECLARED
-#define TkMacOSXUpdateClipRgn_TCL_DECLARED
+EXTERN void    TkMacOSXSetUpGraphicsPort(GC gc, void *destPort);
 /* 32 */
-EXTERN void    TkMacOSXUpdateClipRgn (TkWindow * winPtr);
-#endif
-#ifndef TkMacOSXUnregisterMacWindow_TCL_DECLARED
-#define TkMacOSXUnregisterMacWindow_TCL_DECLARED
+EXTERN void    TkMacOSXUpdateClipRgn(TkWindow *winPtr);
 /* 33 */
-EXTERN void    TkMacOSXUnregisterMacWindow (WindowRef portPtr);
-#endif
-#ifndef TkMacOSXUseMenuID_TCL_DECLARED
-#define TkMacOSXUseMenuID_TCL_DECLARED
+EXTERN void    TkMacOSXUnregisterMacWindow(void *portPtr);
 /* 34 */
-EXTERN int    TkMacOSXUseMenuID (short macID);
-#endif
-#ifndef TkMacOSXVisableClipRgn_TCL_DECLARED
-#define TkMacOSXVisableClipRgn_TCL_DECLARED
+EXTERN int    TkMacOSXUseMenuID(short macID);
 /* 35 */
-EXTERN RgnHandle  TkMacOSXVisableClipRgn (TkWindow * winPtr);
-#endif
-#ifndef TkMacOSXWinBounds_TCL_DECLARED
-#define TkMacOSXWinBounds_TCL_DECLARED
+EXTERN TkRegion    TkMacOSXVisableClipRgn(TkWindow *winPtr);
 /* 36 */
-EXTERN void    TkMacOSXWinBounds (TkWindow * winPtr, 
-        Rect * geometry);
-#endif
-#ifndef TkMacOSXWindowOffset_TCL_DECLARED
-#define TkMacOSXWindowOffset_TCL_DECLARED
+EXTERN void    TkMacOSXWinBounds(TkWindow *winPtr, void *geometry);
 /* 37 */
-EXTERN void    TkMacOSXWindowOffset (WindowRef wRef, int * xOffset, 
-        int * yOffset);
-#endif
-#ifndef TkSetMacColor_TCL_DECLARED
-#define TkSetMacColor_TCL_DECLARED
+EXTERN void    TkMacOSXWindowOffset(void *wRef, int *xOffset,
+        int *yOffset);
 /* 38 */
-EXTERN int    TkSetMacColor (unsigned long pixel, 
-        RGBColor * macColor);
-#endif
-#ifndef TkSetWMName_TCL_DECLARED
-#define TkSetWMName_TCL_DECLARED
+EXTERN int    TkSetMacColor(unsigned long pixel, void *macColor);
 /* 39 */
-EXTERN void    TkSetWMName (TkWindow * winPtr, Tk_Uid titleUid);
-#endif
-#ifndef TkSuspendClipboard_TCL_DECLARED
-#define TkSuspendClipboard_TCL_DECLARED
+EXTERN void    TkSetWMName(TkWindow *winPtr, Tk_Uid titleUid);
 /* 40 */
-EXTERN void    TkSuspendClipboard (void);
-#endif
-#ifndef TkMacOSXZoomToplevel_TCL_DECLARED
-#define TkMacOSXZoomToplevel_TCL_DECLARED
+EXTERN void    TkSuspendClipboard(void);
 /* 41 */
-EXTERN int    TkMacOSXZoomToplevel (WindowPtr whichWindow, 
+EXTERN int    TkMacOSXZoomToplevel(void *whichWindow,
         short zoomPart);
-#endif
-#ifndef Tk_TopCoordsToWindow_TCL_DECLARED
-#define Tk_TopCoordsToWindow_TCL_DECLARED
 /* 42 */
-EXTERN Tk_Window  Tk_TopCoordsToWindow (Tk_Window tkwin, int rootX, 
-        int rootY, int * newX, int * newY);
-#endif
-#ifndef TkMacOSXContainerId_TCL_DECLARED
-#define TkMacOSXContainerId_TCL_DECLARED
+EXTERN Tk_Window  Tk_TopCoordsToWindow(Tk_Window tkwin, int rootX,
+        int rootY, int *newX, int *newY);
 /* 43 */
-EXTERN MacDrawable *  TkMacOSXContainerId (TkWindow * winPtr);
-#endif
-#ifndef TkMacOSXGetHostToplevel_TCL_DECLARED
-#define TkMacOSXGetHostToplevel_TCL_DECLARED
+EXTERN MacDrawable *  TkMacOSXContainerId(TkWindow *winPtr);
 /* 44 */
-EXTERN MacDrawable *  TkMacOSXGetHostToplevel (TkWindow * winPtr);
-#endif
-#ifndef TkMacOSXPreprocessMenu_TCL_DECLARED
-#define TkMacOSXPreprocessMenu_TCL_DECLARED
+EXTERN MacDrawable *  TkMacOSXGetHostToplevel(TkWindow *winPtr);
 /* 45 */
-EXTERN void    TkMacOSXPreprocessMenu (void);
-#endif
-#ifndef TkpIsWindowFloating_TCL_DECLARED
-#define TkpIsWindowFloating_TCL_DECLARED
+EXTERN void    TkMacOSXPreprocessMenu(void);
 /* 46 */
-EXTERN int    TkpIsWindowFloating (WindowRef window);
-#endif
-#ifndef TkMacOSXGetCapture_TCL_DECLARED
-#define TkMacOSXGetCapture_TCL_DECLARED
+EXTERN int    TkpIsWindowFloating(void *window);
 /* 47 */
-EXTERN Tk_Window  TkMacOSXGetCapture (void);
-#endif
+EXTERN Tk_Window  TkMacOSXGetCapture(void);
 /* Slot 48 is reserved */
-#ifndef TkGetTransientMaster_TCL_DECLARED
-#define TkGetTransientMaster_TCL_DECLARED
 /* 49 */
-EXTERN Window    TkGetTransientMaster (TkWindow * winPtr);
-#endif
-#ifndef TkGenerateButtonEvent_TCL_DECLARED
-#define TkGenerateButtonEvent_TCL_DECLARED
+EXTERN Window    TkGetTransientMaster(TkWindow *winPtr);
 /* 50 */
-EXTERN int    TkGenerateButtonEvent (int x, int y, Window window, 
+EXTERN int    TkGenerateButtonEvent(int x, int y, Window window,
         unsigned int state);
-#endif
-#ifndef TkGenWMDestroyEvent_TCL_DECLARED
-#define TkGenWMDestroyEvent_TCL_DECLARED
 /* 51 */
-EXTERN void    TkGenWMDestroyEvent (Tk_Window tkwin);
-#endif
+EXTERN void    TkGenWMDestroyEvent(Tk_Window tkwin);
 /* Slot 52 is reserved */
-#ifndef TkpGetMS_TCL_DECLARED
-#define TkpGetMS_TCL_DECLARED
 /* 53 */
-EXTERN unsigned long  TkpGetMS (void);
-#endif
+EXTERN unsigned long  TkpGetMS(void);
+/* 54 */
+EXTERN void *    TkMacOSXDrawable(Drawable drawable);
 #endif /* AQUA */
-#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-#ifndef TkCreateXEventSource_TCL_DECLARED
-#define TkCreateXEventSource_TCL_DECLARED
+#if !(defined(__WIN32__) || defined(__CYGWIN__) || defined(MAC_OSX_TK)) /* X11 */
 /* 0 */
-EXTERN void    TkCreateXEventSource (void);
-#endif
+EXTERN void    TkCreateXEventSource(void);
 /* Slot 1 is reserved */
 /* Slot 2 is reserved */
-#ifndef TkpCmapStressed_TCL_DECLARED
-#define TkpCmapStressed_TCL_DECLARED
 /* 3 */
-EXTERN int    TkpCmapStressed (Tk_Window tkwin, Colormap colormap);
-#endif
-#ifndef TkpSync_TCL_DECLARED
-#define TkpSync_TCL_DECLARED
+EXTERN int    TkpCmapStressed(Tk_Window tkwin, Colormap colormap);
 /* 4 */
-EXTERN void    TkpSync (Display * display);
-#endif
-#ifndef TkUnixContainerId_TCL_DECLARED
-#define TkUnixContainerId_TCL_DECLARED
+EXTERN void    TkpSync(Display *display);
 /* 5 */
-EXTERN Window    TkUnixContainerId (TkWindow * winPtr);
-#endif
-#ifndef TkUnixDoOneXEvent_TCL_DECLARED
-#define TkUnixDoOneXEvent_TCL_DECLARED
+EXTERN Window    TkUnixContainerId(TkWindow *winPtr);
 /* 6 */
-EXTERN int    TkUnixDoOneXEvent (Tcl_Time * timePtr);
-#endif
-#ifndef TkUnixSetMenubar_TCL_DECLARED
-#define TkUnixSetMenubar_TCL_DECLARED
+EXTERN int    TkUnixDoOneXEvent(Tcl_Time *timePtr);
 /* 7 */
-EXTERN void    TkUnixSetMenubar (Tk_Window tkwin, Tk_Window menubar);
-#endif
-#ifndef TkpScanWindowId_TCL_DECLARED
-#define TkpScanWindowId_TCL_DECLARED
+EXTERN void    TkUnixSetMenubar(Tk_Window tkwin, Tk_Window menubar);
 /* 8 */
-EXTERN int    TkpScanWindowId (Tcl_Interp * interp, 
-        CONST char * string, Window * idPtr);
-#endif
-#ifndef TkWmCleanup_TCL_DECLARED
-#define TkWmCleanup_TCL_DECLARED
+EXTERN int    TkpScanWindowId(Tcl_Interp *interp,
+        const char *string, Window *idPtr);
 /* 9 */
-EXTERN void    TkWmCleanup (TkDisplay * dispPtr);
-#endif
-#ifndef TkSendCleanup_TCL_DECLARED
-#define TkSendCleanup_TCL_DECLARED
+EXTERN void    TkWmCleanup(TkDisplay *dispPtr);
 /* 10 */
-EXTERN void    TkSendCleanup (TkDisplay * dispPtr);
-#endif
+EXTERN void    TkSendCleanup(TkDisplay *dispPtr);
 /* Slot 11 is reserved */
-#ifndef TkpWmSetState_TCL_DECLARED
-#define TkpWmSetState_TCL_DECLARED
 /* 12 */
-EXTERN int    TkpWmSetState (TkWindow * winPtr, int state);
-#endif
-#ifndef TkpTestsendCmd_TCL_DECLARED
-#define TkpTestsendCmd_TCL_DECLARED
+EXTERN int    TkpWmSetState(TkWindow *winPtr, int state);
 /* 13 */
-EXTERN int    TkpTestsendCmd (ClientData clientData, 
-        Tcl_Interp * interp, int argc, 
-        CONST char ** argv);
-#endif
+EXTERN int    TkpTestsendCmd(ClientData clientData,
+        Tcl_Interp *interp, int argc,
+        const char **argv);
 #endif /* X11 */
 
 typedef struct TkIntPlatStubs {
     int magic;
-    CONST struct TkIntPlatStubHooks *hooks;
+    void *hooks;
 
-#ifdef __WIN32__ /* WIN */
-    char * (*tkAlignImageData) (XImage * image, int alignment, int bitOrder); /* 0 */
-    void *reserved1;
-    void (*tkGenerateActivateEvents) (TkWindow * winPtr, int active); /* 2 */
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
+    char * (*tkAlignImageData) (XImage *image, int alignment, int bitOrder); /* 0 */
+    void (*reserved1)(void);
+    void (*tkGenerateActivateEvents) (TkWindow *winPtr, int active); /* 2 */
     unsigned long (*tkpGetMS) (void); /* 3 */
-    void (*tkPointerDeadWindow) (TkWindow * winPtr); /* 4 */
-    void (*tkpPrintWindowId) (char * buf, Window window); /* 5 */
-    int (*tkpScanWindowId) (Tcl_Interp * interp, CONST char * string, Window * idPtr); /* 6 */
-    void (*tkpSetCapture) (TkWindow * winPtr); /* 7 */
+    void (*tkPointerDeadWindow) (TkWindow *winPtr); /* 4 */
+    void (*tkpPrintWindowId) (char *buf, Window window); /* 5 */
+    int (*tkpScanWindowId) (Tcl_Interp *interp, const char *string, Window *idPtr); /* 6 */
+    void (*tkpSetCapture) (TkWindow *winPtr); /* 7 */
     void (*tkpSetCursor) (TkpCursor cursor); /* 8 */
-    void (*tkpWmSetState) (TkWindow * winPtr, int state); /* 9 */
+    int (*tkpWmSetState) (TkWindow *winPtr, int state); /* 9 */
     void (*tkSetPixmapColormap) (Pixmap pixmap, Colormap colormap); /* 10 */
     void (*tkWinCancelMouseTimer) (void); /* 11 */
-    void (*tkWinClipboardRender) (TkDisplay * dispPtr, UINT format); /* 12 */
+    void (*tkWinClipboardRender) (TkDisplay *dispPtr, UINT format); /* 12 */
     LRESULT (*tkWinEmbeddedEventProc) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); /* 13 */
     void (*tkWinFillRect) (HDC dc, int x, int y, int width, int height, int pixel); /* 14 */
     COLORREF (*tkWinGetBorderPixels) (Tk_Window tkwin, Tk_3DBorder border, int which); /* 15 */
-    HDC (*tkWinGetDrawableDC) (Display * display, Drawable d, TkWinDCState * state); /* 16 */
+    HDC (*tkWinGetDrawableDC) (Display *display, Drawable d, TkWinDCState *state); /* 16 */
     int (*tkWinGetModifierState) (void); /* 17 */
     HPALETTE (*tkWinGetSystemPalette) (void); /* 18 */
     HWND (*tkWinGetWrapperWindow) (Tk_Window tkwin); /* 19 */
-    int (*tkWinHandleMenuEvent) (HWND * phwnd, UINT * pMessage, WPARAM * pwParam, LPARAM * plParam, LRESULT * plResult); /* 20 */
-    int (*tkWinIndexOfColor) (XColor * colorPtr); /* 21 */
-    void (*tkWinReleaseDrawableDC) (Drawable d, HDC hdc, TkWinDCState * state); /* 22 */
-    LRESULT (*tkWinResendEvent) (WNDPROC wndproc, HWND hwnd, XEvent * eventPtr); /* 23 */
+    int (*tkWinHandleMenuEvent) (HWND *phwnd, UINT *pMessage, WPARAM *pwParam, LPARAM *plParam, LRESULT *plResult); /* 20 */
+    int (*tkWinIndexOfColor) (XColor *colorPtr); /* 21 */
+    void (*tkWinReleaseDrawableDC) (Drawable d, HDC hdc, TkWinDCState *state); /* 22 */
+    LRESULT (*tkWinResendEvent) (WNDPROC wndproc, HWND hwnd, XEvent *eventPtr); /* 23 */
     HPALETTE (*tkWinSelectPalette) (HDC dc, Colormap colormap); /* 24 */
     void (*tkWinSetMenu) (Tk_Window tkwin, HMENU hMenu); /* 25 */
     void (*tkWinSetWindowPos) (HWND hwnd, HWND siblingHwnd, int pos); /* 26 */
     void (*tkWinWmCleanup) (HINSTANCE hInstance); /* 27 */
     void (*tkWinXCleanup) (ClientData clientData); /* 28 */
     void (*tkWinXInit) (HINSTANCE hInstance); /* 29 */
-    void (*tkWinSetForegroundWindow) (TkWindow * winPtr); /* 30 */
+    void (*tkWinSetForegroundWindow) (TkWindow *winPtr); /* 30 */
     void (*tkWinDialogDebug) (int debug); /* 31 */
-    Tcl_Obj * (*tkWinGetMenuSystemDefault) (Tk_Window tkwin, CONST char * dbName, CONST char * className); /* 32 */
+    Tcl_Obj * (*tkWinGetMenuSystemDefault) (Tk_Window tkwin, const char *dbName, const char *className); /* 32 */
     int (*tkWinGetPlatformId) (void); /* 33 */
     void (*tkWinSetHINSTANCE) (HINSTANCE hInstance); /* 34 */
     int (*tkWinGetPlatformTheme) (void); /* 35 */
+    LRESULT (__stdcall *tkWinChildProc) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); /* 36 */
+    void (*tkCreateXEventSource) (void); /* 37 */
+    int (*tkpCmapStressed) (Tk_Window tkwin, Colormap colormap); /* 38 */
+    void (*tkpSync) (Display *display); /* 39 */
+    Window (*tkUnixContainerId) (TkWindow *winPtr); /* 40 */
+    int (*tkUnixDoOneXEvent) (Tcl_Time *timePtr); /* 41 */
+    void (*tkUnixSetMenubar) (Tk_Window tkwin, Tk_Window menubar); /* 42 */
+    void (*tkWmCleanup) (TkDisplay *dispPtr); /* 43 */
+    void (*tkSendCleanup) (TkDisplay *dispPtr); /* 44 */
+    int (*tkpTestsendCmd) (ClientData clientData, Tcl_Interp *interp, int argc, const char **argv); /* 45 */
 #endif /* WIN */
 #ifdef MAC_OSX_TK /* AQUA */
-    void (*tkGenerateActivateEvents) (TkWindow * winPtr, int active); /* 0 */
-    void *reserved1;
-    void *reserved2;
-    void (*tkPointerDeadWindow) (TkWindow * winPtr); /* 3 */
-    void (*tkpSetCapture) (TkWindow * winPtr); /* 4 */
+    void (*tkGenerateActivateEvents) (TkWindow *winPtr, int active); /* 0 */
+    void (*reserved1)(void);
+    void (*reserved2)(void);
+    void (*tkPointerDeadWindow) (TkWindow *winPtr); /* 3 */
+    void (*tkpSetCapture) (TkWindow *winPtr); /* 4 */
     void (*tkpSetCursor) (TkpCursor cursor); /* 5 */
-    void (*tkpWmSetState) (TkWindow * winPtr, int state); /* 6 */
+    void (*tkpWmSetState) (TkWindow *winPtr, int state); /* 6 */
     void (*tkAboutDlg) (void); /* 7 */
     unsigned int (*tkMacOSXButtonKeyState) (void); /* 8 */
     void (*tkMacOSXClearMenubarActive) (void); /* 9 */
     int (*tkMacOSXDispatchMenuEvent) (int menuID, int index); /* 10 */
     void (*tkMacOSXInstallCursor) (int resizeOverride); /* 11 */
     void (*tkMacOSXHandleTearoffMenu) (void); /* 12 */
-    void *reserved13;
-    int (*tkMacOSXDoHLEvent) (EventRecord * theEvent); /* 14 */
-    void *reserved15;
-    Window (*tkMacOSXGetXWindow) (WindowRef macWinPtr); /* 16 */
-    int (*tkMacOSXGrowToplevel) (WindowRef whichWindow, Point start); /* 17 */
-    void (*tkMacOSXHandleMenuSelect) (MenuID theMenu, MenuItemIndex theItem, int optionKeyPressed); /* 18 */
-    void *reserved19;
-    void *reserved20;
-    void (*tkMacOSXInvalidateWindow) (MacDrawable * macWin, int flag); /* 21 */
+    void (*reserved13)(void);
+    int (*tkMacOSXDoHLEvent) (void *theEvent); /* 14 */
+    void (*reserved15)(void);
+    Window (*tkMacOSXGetXWindow) (void *macWinPtr); /* 16 */
+    int (*tkMacOSXGrowToplevel) (void *whichWindow, XPoint start); /* 17 */
+    void (*tkMacOSXHandleMenuSelect) (short theMenu, unsigned short theItem, int optionKeyPressed); /* 18 */
+    void (*reserved19)(void);
+    void (*reserved20)(void);
+    void (*tkMacOSXInvalidateWindow) (MacDrawable *macWin, int flag); /* 21 */
     int (*tkMacOSXIsCharacterMissing) (Tk_Font tkfont, unsigned int searchChar); /* 22 */
-    void (*tkMacOSXMakeRealWindowExist) (TkWindow * winPtr); /* 23 */
-    BitMapPtr (*tkMacOSXMakeStippleMap) (Drawable d1, Drawable d2); /* 24 */
+    void (*tkMacOSXMakeRealWindowExist) (TkWindow *winPtr); /* 23 */
+    void * (*tkMacOSXMakeStippleMap) (Drawable d1, Drawable d2); /* 24 */
     void (*tkMacOSXMenuClick) (void); /* 25 */
-    void (*tkMacOSXRegisterOffScreenWindow) (Window window, GWorldPtr portPtr); /* 26 */
-    int (*tkMacOSXResizable) (TkWindow * winPtr); /* 27 */
+    void (*tkMacOSXRegisterOffScreenWindow) (Window window, void *portPtr); /* 26 */
+    int (*tkMacOSXResizable) (TkWindow *winPtr); /* 27 */
     void (*tkMacOSXSetHelpMenuItemCount) (void); /* 28 */
-    void (*tkMacOSXSetScrollbarGrow) (TkWindow * winPtr, int flag); /* 29 */
+    void (*tkMacOSXSetScrollbarGrow) (TkWindow *winPtr, int flag); /* 29 */
     void (*tkMacOSXSetUpClippingRgn) (Drawable drawable); /* 30 */
-    void (*tkMacOSXSetUpGraphicsPort) (GC gc, GWorldPtr destPort); /* 31 */
-    void (*tkMacOSXUpdateClipRgn) (TkWindow * winPtr); /* 32 */
-    void (*tkMacOSXUnregisterMacWindow) (WindowRef portPtr); /* 33 */
+    void (*tkMacOSXSetUpGraphicsPort) (GC gc, void *destPort); /* 31 */
+    void (*tkMacOSXUpdateClipRgn) (TkWindow *winPtr); /* 32 */
+    void (*tkMacOSXUnregisterMacWindow) (void *portPtr); /* 33 */
     int (*tkMacOSXUseMenuID) (short macID); /* 34 */
-    RgnHandle (*tkMacOSXVisableClipRgn) (TkWindow * winPtr); /* 35 */
-    void (*tkMacOSXWinBounds) (TkWindow * winPtr, Rect * geometry); /* 36 */
-    void (*tkMacOSXWindowOffset) (WindowRef wRef, int * xOffset, int * yOffset); /* 37 */
-    int (*tkSetMacColor) (unsigned long pixel, RGBColor * macColor); /* 38 */
-    void (*tkSetWMName) (TkWindow * winPtr, Tk_Uid titleUid); /* 39 */
+    TkRegion (*tkMacOSXVisableClipRgn) (TkWindow *winPtr); /* 35 */
+    void (*tkMacOSXWinBounds) (TkWindow *winPtr, void *geometry); /* 36 */
+    void (*tkMacOSXWindowOffset) (void *wRef, int *xOffset, int *yOffset); /* 37 */
+    int (*tkSetMacColor) (unsigned long pixel, void *macColor); /* 38 */
+    void (*tkSetWMName) (TkWindow *winPtr, Tk_Uid titleUid); /* 39 */
     void (*tkSuspendClipboard) (void); /* 40 */
-    int (*tkMacOSXZoomToplevel) (WindowPtr whichWindow, short zoomPart); /* 41 */
-    Tk_Window (*tk_TopCoordsToWindow) (Tk_Window tkwin, int rootX, int rootY, int * newX, int * newY); /* 42 */
-    MacDrawable * (*tkMacOSXContainerId) (TkWindow * winPtr); /* 43 */
-    MacDrawable * (*tkMacOSXGetHostToplevel) (TkWindow * winPtr); /* 44 */
+    int (*tkMacOSXZoomToplevel) (void *whichWindow, short zoomPart); /* 41 */
+    Tk_Window (*tk_TopCoordsToWindow) (Tk_Window tkwin, int rootX, int rootY, int *newX, int *newY); /* 42 */
+    MacDrawable * (*tkMacOSXContainerId) (TkWindow *winPtr); /* 43 */
+    MacDrawable * (*tkMacOSXGetHostToplevel) (TkWindow *winPtr); /* 44 */
     void (*tkMacOSXPreprocessMenu) (void); /* 45 */
-    int (*tkpIsWindowFloating) (WindowRef window); /* 46 */
+    int (*tkpIsWindowFloating) (void *window); /* 46 */
     Tk_Window (*tkMacOSXGetCapture) (void); /* 47 */
-    void *reserved48;
-    Window (*tkGetTransientMaster) (TkWindow * winPtr); /* 49 */
+    void (*reserved48)(void);
+    Window (*tkGetTransientMaster) (TkWindow *winPtr); /* 49 */
     int (*tkGenerateButtonEvent) (int x, int y, Window window, unsigned int state); /* 50 */
     void (*tkGenWMDestroyEvent) (Tk_Window tkwin); /* 51 */
-    void *reserved52;
+    void (*reserved52)(void);
     unsigned long (*tkpGetMS) (void); /* 53 */
+    void * (*tkMacOSXDrawable) (Drawable drawable); /* 54 */
 #endif /* AQUA */
-#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
+#if !(defined(__WIN32__) || defined(__CYGWIN__) || defined(MAC_OSX_TK)) /* X11 */
     void (*tkCreateXEventSource) (void); /* 0 */
-    void *reserved1;
-    void *reserved2;
+    void (*reserved1)(void);
+    void (*reserved2)(void);
     int (*tkpCmapStressed) (Tk_Window tkwin, Colormap colormap); /* 3 */
-    void (*tkpSync) (Display * display); /* 4 */
-    Window (*tkUnixContainerId) (TkWindow * winPtr); /* 5 */
-    int (*tkUnixDoOneXEvent) (Tcl_Time * timePtr); /* 6 */
+    void (*tkpSync) (Display *display); /* 4 */
+    Window (*tkUnixContainerId) (TkWindow *winPtr); /* 5 */
+    int (*tkUnixDoOneXEvent) (Tcl_Time *timePtr); /* 6 */
     void (*tkUnixSetMenubar) (Tk_Window tkwin, Tk_Window menubar); /* 7 */
-    int (*tkpScanWindowId) (Tcl_Interp * interp, CONST char * string, Window * idPtr); /* 8 */
-    void (*tkWmCleanup) (TkDisplay * dispPtr); /* 9 */
-    void (*tkSendCleanup) (TkDisplay * dispPtr); /* 10 */
-    void *reserved11;
-    int (*tkpWmSetState) (TkWindow * winPtr, int state); /* 12 */
-    int (*tkpTestsendCmd) (ClientData clientData, Tcl_Interp * interp, int argc, CONST char ** argv); /* 13 */
+    int (*tkpScanWindowId) (Tcl_Interp *interp, const char *string, Window *idPtr); /* 8 */
+    void (*tkWmCleanup) (TkDisplay *dispPtr); /* 9 */
+    void (*tkSendCleanup) (TkDisplay *dispPtr); /* 10 */
+    void (*reserved11)(void);
+    int (*tkpWmSetState) (TkWindow *winPtr, int state); /* 12 */
+    int (*tkpTestsendCmd) (ClientData clientData, Tcl_Interp *interp, int argc, const char **argv); /* 13 */
 #endif /* X11 */
 } TkIntPlatStubs;
 
-#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)
-extern CONST TkIntPlatStubs *tkIntPlatStubsPtr;
-#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern const TkIntPlatStubs *tkIntPlatStubsPtr;
+#ifdef __cplusplus
+}
+#endif
 
-#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)
+#if defined(USE_TK_STUBS)
 
 /*
  * Inline function declarations:
  */
 
-#ifdef __WIN32__ /* WIN */
-#ifndef TkAlignImageData
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
 #define TkAlignImageData \
   (tkIntPlatStubsPtr->tkAlignImageData) /* 0 */
-#endif
 /* Slot 1 is reserved */
-#ifndef TkGenerateActivateEvents
 #define TkGenerateActivateEvents \
   (tkIntPlatStubsPtr->tkGenerateActivateEvents) /* 2 */
-#endif
-#ifndef TkpGetMS
 #define TkpGetMS \
   (tkIntPlatStubsPtr->tkpGetMS) /* 3 */
-#endif
-#ifndef TkPointerDeadWindow
 #define TkPointerDeadWindow \
   (tkIntPlatStubsPtr->tkPointerDeadWindow) /* 4 */
-#endif
-#ifndef TkpPrintWindowId
 #define TkpPrintWindowId \
   (tkIntPlatStubsPtr->tkpPrintWindowId) /* 5 */
-#endif
-#ifndef TkpScanWindowId
 #define TkpScanWindowId \
   (tkIntPlatStubsPtr->tkpScanWindowId) /* 6 */
-#endif
-#ifndef TkpSetCapture
 #define TkpSetCapture \
   (tkIntPlatStubsPtr->tkpSetCapture) /* 7 */
-#endif
-#ifndef TkpSetCursor
 #define TkpSetCursor \
   (tkIntPlatStubsPtr->tkpSetCursor) /* 8 */
-#endif
-#ifndef TkpWmSetState
 #define TkpWmSetState \
   (tkIntPlatStubsPtr->tkpWmSetState) /* 9 */
-#endif
-#ifndef TkSetPixmapColormap
 #define TkSetPixmapColormap \
   (tkIntPlatStubsPtr->tkSetPixmapColormap) /* 10 */
-#endif
-#ifndef TkWinCancelMouseTimer
 #define TkWinCancelMouseTimer \
   (tkIntPlatStubsPtr->tkWinCancelMouseTimer) /* 11 */
-#endif
-#ifndef TkWinClipboardRender
 #define TkWinClipboardRender \
   (tkIntPlatStubsPtr->tkWinClipboardRender) /* 12 */
-#endif
-#ifndef TkWinEmbeddedEventProc
 #define TkWinEmbeddedEventProc \
   (tkIntPlatStubsPtr->tkWinEmbeddedEventProc) /* 13 */
-#endif
-#ifndef TkWinFillRect
 #define TkWinFillRect \
   (tkIntPlatStubsPtr->tkWinFillRect) /* 14 */
-#endif
-#ifndef TkWinGetBorderPixels
 #define TkWinGetBorderPixels \
   (tkIntPlatStubsPtr->tkWinGetBorderPixels) /* 15 */
-#endif
-#ifndef TkWinGetDrawableDC
 #define TkWinGetDrawableDC \
   (tkIntPlatStubsPtr->tkWinGetDrawableDC) /* 16 */
-#endif
-#ifndef TkWinGetModifierState
 #define TkWinGetModifierState \
   (tkIntPlatStubsPtr->tkWinGetModifierState) /* 17 */
-#endif
-#ifndef TkWinGetSystemPalette
 #define TkWinGetSystemPalette \
   (tkIntPlatStubsPtr->tkWinGetSystemPalette) /* 18 */
-#endif
-#ifndef TkWinGetWrapperWindow
 #define TkWinGetWrapperWindow \
   (tkIntPlatStubsPtr->tkWinGetWrapperWindow) /* 19 */
-#endif
-#ifndef TkWinHandleMenuEvent
 #define TkWinHandleMenuEvent \
   (tkIntPlatStubsPtr->tkWinHandleMenuEvent) /* 20 */
-#endif
-#ifndef TkWinIndexOfColor
 #define TkWinIndexOfColor \
   (tkIntPlatStubsPtr->tkWinIndexOfColor) /* 21 */
-#endif
-#ifndef TkWinReleaseDrawableDC
 #define TkWinReleaseDrawableDC \
   (tkIntPlatStubsPtr->tkWinReleaseDrawableDC) /* 22 */
-#endif
-#ifndef TkWinResendEvent
 #define TkWinResendEvent \
   (tkIntPlatStubsPtr->tkWinResendEvent) /* 23 */
-#endif
-#ifndef TkWinSelectPalette
 #define TkWinSelectPalette \
   (tkIntPlatStubsPtr->tkWinSelectPalette) /* 24 */
-#endif
-#ifndef TkWinSetMenu
 #define TkWinSetMenu \
   (tkIntPlatStubsPtr->tkWinSetMenu) /* 25 */
-#endif
-#ifndef TkWinSetWindowPos
 #define TkWinSetWindowPos \
   (tkIntPlatStubsPtr->tkWinSetWindowPos) /* 26 */
-#endif
-#ifndef TkWinWmCleanup
 #define TkWinWmCleanup \
   (tkIntPlatStubsPtr->tkWinWmCleanup) /* 27 */
-#endif
-#ifndef TkWinXCleanup
 #define TkWinXCleanup \
   (tkIntPlatStubsPtr->tkWinXCleanup) /* 28 */
-#endif
-#ifndef TkWinXInit
 #define TkWinXInit \
   (tkIntPlatStubsPtr->tkWinXInit) /* 29 */
-#endif
-#ifndef TkWinSetForegroundWindow
 #define TkWinSetForegroundWindow \
   (tkIntPlatStubsPtr->tkWinSetForegroundWindow) /* 30 */
-#endif
-#ifndef TkWinDialogDebug
 #define TkWinDialogDebug \
   (tkIntPlatStubsPtr->tkWinDialogDebug) /* 31 */
-#endif
-#ifndef TkWinGetMenuSystemDefault
 #define TkWinGetMenuSystemDefault \
   (tkIntPlatStubsPtr->tkWinGetMenuSystemDefault) /* 32 */
-#endif
-#ifndef TkWinGetPlatformId
 #define TkWinGetPlatformId \
   (tkIntPlatStubsPtr->tkWinGetPlatformId) /* 33 */
-#endif
-#ifndef TkWinSetHINSTANCE
 #define TkWinSetHINSTANCE \
   (tkIntPlatStubsPtr->tkWinSetHINSTANCE) /* 34 */
-#endif
-#ifndef TkWinGetPlatformTheme
 #define TkWinGetPlatformTheme \
   (tkIntPlatStubsPtr->tkWinGetPlatformTheme) /* 35 */
-#endif
+#define TkWinChildProc \
+  (tkIntPlatStubsPtr->tkWinChildProc) /* 36 */
+#define TkCreateXEventSource \
+  (tkIntPlatStubsPtr->tkCreateXEventSource) /* 37 */
+#define TkpCmapStressed \
+  (tkIntPlatStubsPtr->tkpCmapStressed) /* 38 */
+#define TkpSync \
+  (tkIntPlatStubsPtr->tkpSync) /* 39 */
+#define TkUnixContainerId \
+  (tkIntPlatStubsPtr->tkUnixContainerId) /* 40 */
+#define TkUnixDoOneXEvent \
+  (tkIntPlatStubsPtr->tkUnixDoOneXEvent) /* 41 */
+#define TkUnixSetMenubar \
+  (tkIntPlatStubsPtr->tkUnixSetMenubar) /* 42 */
+#define TkWmCleanup \
+  (tkIntPlatStubsPtr->tkWmCleanup) /* 43 */
+#define TkSendCleanup \
+  (tkIntPlatStubsPtr->tkSendCleanup) /* 44 */
+#define TkpTestsendCmd \
+  (tkIntPlatStubsPtr->tkpTestsendCmd) /* 45 */
 #endif /* WIN */
 #ifdef MAC_OSX_TK /* AQUA */
-#ifndef TkGenerateActivateEvents
 #define TkGenerateActivateEvents \
   (tkIntPlatStubsPtr->tkGenerateActivateEvents) /* 0 */
-#endif
 /* Slot 1 is reserved */
 /* Slot 2 is reserved */
-#ifndef TkPointerDeadWindow
 #define TkPointerDeadWindow \
   (tkIntPlatStubsPtr->tkPointerDeadWindow) /* 3 */
-#endif
-#ifndef TkpSetCapture
 #define TkpSetCapture \
   (tkIntPlatStubsPtr->tkpSetCapture) /* 4 */
-#endif
-#ifndef TkpSetCursor
 #define TkpSetCursor \
   (tkIntPlatStubsPtr->tkpSetCursor) /* 5 */
-#endif
-#ifndef TkpWmSetState
 #define TkpWmSetState \
   (tkIntPlatStubsPtr->tkpWmSetState) /* 6 */
-#endif
-#ifndef TkAboutDlg
 #define TkAboutDlg \
   (tkIntPlatStubsPtr->tkAboutDlg) /* 7 */
-#endif
-#ifndef TkMacOSXButtonKeyState
 #define TkMacOSXButtonKeyState \
   (tkIntPlatStubsPtr->tkMacOSXButtonKeyState) /* 8 */
-#endif
-#ifndef TkMacOSXClearMenubarActive
 #define TkMacOSXClearMenubarActive \
   (tkIntPlatStubsPtr->tkMacOSXClearMenubarActive) /* 9 */
-#endif
-#ifndef TkMacOSXDispatchMenuEvent
 #define TkMacOSXDispatchMenuEvent \
   (tkIntPlatStubsPtr->tkMacOSXDispatchMenuEvent) /* 10 */
-#endif
-#ifndef TkMacOSXInstallCursor
 #define TkMacOSXInstallCursor \
   (tkIntPlatStubsPtr->tkMacOSXInstallCursor) /* 11 */
-#endif
-#ifndef TkMacOSXHandleTearoffMenu
 #define TkMacOSXHandleTearoffMenu \
   (tkIntPlatStubsPtr->tkMacOSXHandleTearoffMenu) /* 12 */
-#endif
 /* Slot 13 is reserved */
-#ifndef TkMacOSXDoHLEvent
 #define TkMacOSXDoHLEvent \
   (tkIntPlatStubsPtr->tkMacOSXDoHLEvent) /* 14 */
-#endif
 /* Slot 15 is reserved */
-#ifndef TkMacOSXGetXWindow
 #define TkMacOSXGetXWindow \
   (tkIntPlatStubsPtr->tkMacOSXGetXWindow) /* 16 */
-#endif
-#ifndef TkMacOSXGrowToplevel
 #define TkMacOSXGrowToplevel \
   (tkIntPlatStubsPtr->tkMacOSXGrowToplevel) /* 17 */
-#endif
-#ifndef TkMacOSXHandleMenuSelect
 #define TkMacOSXHandleMenuSelect \
   (tkIntPlatStubsPtr->tkMacOSXHandleMenuSelect) /* 18 */
-#endif
 /* Slot 19 is reserved */
 /* Slot 20 is reserved */
-#ifndef TkMacOSXInvalidateWindow
 #define TkMacOSXInvalidateWindow \
   (tkIntPlatStubsPtr->tkMacOSXInvalidateWindow) /* 21 */
-#endif
-#ifndef TkMacOSXIsCharacterMissing
 #define TkMacOSXIsCharacterMissing \
   (tkIntPlatStubsPtr->tkMacOSXIsCharacterMissing) /* 22 */
-#endif
-#ifndef TkMacOSXMakeRealWindowExist
 #define TkMacOSXMakeRealWindowExist \
   (tkIntPlatStubsPtr->tkMacOSXMakeRealWindowExist) /* 23 */
-#endif
-#ifndef TkMacOSXMakeStippleMap
 #define TkMacOSXMakeStippleMap \
   (tkIntPlatStubsPtr->tkMacOSXMakeStippleMap) /* 24 */
-#endif
-#ifndef TkMacOSXMenuClick
 #define TkMacOSXMenuClick \
   (tkIntPlatStubsPtr->tkMacOSXMenuClick) /* 25 */
-#endif
-#ifndef TkMacOSXRegisterOffScreenWindow
 #define TkMacOSXRegisterOffScreenWindow \
   (tkIntPlatStubsPtr->tkMacOSXRegisterOffScreenWindow) /* 26 */
-#endif
-#ifndef TkMacOSXResizable
 #define TkMacOSXResizable \
   (tkIntPlatStubsPtr->tkMacOSXResizable) /* 27 */
-#endif
-#ifndef TkMacOSXSetHelpMenuItemCount
 #define TkMacOSXSetHelpMenuItemCount \
   (tkIntPlatStubsPtr->tkMacOSXSetHelpMenuItemCount) /* 28 */
-#endif
-#ifndef TkMacOSXSetScrollbarGrow
 #define TkMacOSXSetScrollbarGrow \
   (tkIntPlatStubsPtr->tkMacOSXSetScrollbarGrow) /* 29 */
-#endif
-#ifndef TkMacOSXSetUpClippingRgn
 #define TkMacOSXSetUpClippingRgn \
   (tkIntPlatStubsPtr->tkMacOSXSetUpClippingRgn) /* 30 */
-#endif
-#ifndef TkMacOSXSetUpGraphicsPort
 #define TkMacOSXSetUpGraphicsPort \
   (tkIntPlatStubsPtr->tkMacOSXSetUpGraphicsPort) /* 31 */
-#endif
-#ifndef TkMacOSXUpdateClipRgn
 #define TkMacOSXUpdateClipRgn \
   (tkIntPlatStubsPtr->tkMacOSXUpdateClipRgn) /* 32 */
-#endif
-#ifndef TkMacOSXUnregisterMacWindow
 #define TkMacOSXUnregisterMacWindow \
   (tkIntPlatStubsPtr->tkMacOSXUnregisterMacWindow) /* 33 */
-#endif
-#ifndef TkMacOSXUseMenuID
 #define TkMacOSXUseMenuID \
   (tkIntPlatStubsPtr->tkMacOSXUseMenuID) /* 34 */
-#endif
-#ifndef TkMacOSXVisableClipRgn
 #define TkMacOSXVisableClipRgn \
   (tkIntPlatStubsPtr->tkMacOSXVisableClipRgn) /* 35 */
-#endif
-#ifndef TkMacOSXWinBounds
 #define TkMacOSXWinBounds \
   (tkIntPlatStubsPtr->tkMacOSXWinBounds) /* 36 */
-#endif
-#ifndef TkMacOSXWindowOffset
 #define TkMacOSXWindowOffset \
   (tkIntPlatStubsPtr->tkMacOSXWindowOffset) /* 37 */
-#endif
-#ifndef TkSetMacColor
 #define TkSetMacColor \
   (tkIntPlatStubsPtr->tkSetMacColor) /* 38 */
-#endif
-#ifndef TkSetWMName
 #define TkSetWMName \
   (tkIntPlatStubsPtr->tkSetWMName) /* 39 */
-#endif
-#ifndef TkSuspendClipboard
 #define TkSuspendClipboard \
   (tkIntPlatStubsPtr->tkSuspendClipboard) /* 40 */
-#endif
-#ifndef TkMacOSXZoomToplevel
 #define TkMacOSXZoomToplevel \
   (tkIntPlatStubsPtr->tkMacOSXZoomToplevel) /* 41 */
-#endif
-#ifndef Tk_TopCoordsToWindow
 #define Tk_TopCoordsToWindow \
   (tkIntPlatStubsPtr->tk_TopCoordsToWindow) /* 42 */
-#endif
-#ifndef TkMacOSXContainerId
 #define TkMacOSXContainerId \
   (tkIntPlatStubsPtr->tkMacOSXContainerId) /* 43 */
-#endif
-#ifndef TkMacOSXGetHostToplevel
 #define TkMacOSXGetHostToplevel \
   (tkIntPlatStubsPtr->tkMacOSXGetHostToplevel) /* 44 */
-#endif
-#ifndef TkMacOSXPreprocessMenu
 #define TkMacOSXPreprocessMenu \
   (tkIntPlatStubsPtr->tkMacOSXPreprocessMenu) /* 45 */
-#endif
-#ifndef TkpIsWindowFloating
 #define TkpIsWindowFloating \
   (tkIntPlatStubsPtr->tkpIsWindowFloating) /* 46 */
-#endif
-#ifndef TkMacOSXGetCapture
 #define TkMacOSXGetCapture \
   (tkIntPlatStubsPtr->tkMacOSXGetCapture) /* 47 */
-#endif
 /* Slot 48 is reserved */
-#ifndef TkGetTransientMaster
 #define TkGetTransientMaster \
   (tkIntPlatStubsPtr->tkGetTransientMaster) /* 49 */
-#endif
-#ifndef TkGenerateButtonEvent
 #define TkGenerateButtonEvent \
   (tkIntPlatStubsPtr->tkGenerateButtonEvent) /* 50 */
-#endif
-#ifndef TkGenWMDestroyEvent
 #define TkGenWMDestroyEvent \
   (tkIntPlatStubsPtr->tkGenWMDestroyEvent) /* 51 */
-#endif
 /* Slot 52 is reserved */
-#ifndef TkpGetMS
 #define TkpGetMS \
   (tkIntPlatStubsPtr->tkpGetMS) /* 53 */
-#endif
+#define TkMacOSXDrawable \
+  (tkIntPlatStubsPtr->tkMacOSXDrawable) /* 54 */
 #endif /* AQUA */
-#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
-#ifndef TkCreateXEventSource
+#if !(defined(__WIN32__) || defined(__CYGWIN__) || defined(MAC_OSX_TK)) /* X11 */
 #define TkCreateXEventSource \
   (tkIntPlatStubsPtr->tkCreateXEventSource) /* 0 */
-#endif
 /* Slot 1 is reserved */
 /* Slot 2 is reserved */
-#ifndef TkpCmapStressed
 #define TkpCmapStressed \
   (tkIntPlatStubsPtr->tkpCmapStressed) /* 3 */
-#endif
-#ifndef TkpSync
 #define TkpSync \
   (tkIntPlatStubsPtr->tkpSync) /* 4 */
-#endif
-#ifndef TkUnixContainerId
 #define TkUnixContainerId \
   (tkIntPlatStubsPtr->tkUnixContainerId) /* 5 */
-#endif
-#ifndef TkUnixDoOneXEvent
 #define TkUnixDoOneXEvent \
   (tkIntPlatStubsPtr->tkUnixDoOneXEvent) /* 6 */
-#endif
-#ifndef TkUnixSetMenubar
 #define TkUnixSetMenubar \
   (tkIntPlatStubsPtr->tkUnixSetMenubar) /* 7 */
-#endif
-#ifndef TkpScanWindowId
 #define TkpScanWindowId \
   (tkIntPlatStubsPtr->tkpScanWindowId) /* 8 */
-#endif
-#ifndef TkWmCleanup
 #define TkWmCleanup \
   (tkIntPlatStubsPtr->tkWmCleanup) /* 9 */
-#endif
-#ifndef TkSendCleanup
 #define TkSendCleanup \
   (tkIntPlatStubsPtr->tkSendCleanup) /* 10 */
-#endif
 /* Slot 11 is reserved */
-#ifndef TkpWmSetState
 #define TkpWmSetState \
   (tkIntPlatStubsPtr->tkpWmSetState) /* 12 */
-#endif
-#ifndef TkpTestsendCmd
 #define TkpTestsendCmd \
   (tkIntPlatStubsPtr->tkpTestsendCmd) /* 13 */
-#endif
 #endif /* X11 */
 
-#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */
+#endif /* defined(USE_TK_STUBS) */
 
 /* !END!: Do not edit above this line. */
 
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkMacOSXDefault.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkMacOSXDefault.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkMacOSXDefault.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkMacOSXDefault.h	2019-02-01 16:20:04.000000000 +0100
@@ -6,18 +6,20 @@
  *
  * Copyright (c) 1991-1994 The Regents of the University of California.
  * Copyright (c) 1994-1997 Sun Microsystems, Inc.
- * Copyright 2001, Apple Computer, Inc.
- * Copyright (c) 2006-2007 Daniel A. Steffen <das@users.sourceforge.net>
+ * Copyright 2001-2009, Apple Inc.
+ * Copyright (c) 2006-2009 Daniel A. Steffen <das@users.sourceforge.net>
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TKMACDEFAULT
 #define _TKMACDEFAULT
 
+#ifndef TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
+#define TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS 1
+#endif
+
 /*
  * The definitions below provide symbolic names for the default colors.
  * NORMAL_BG -    Normal background color.
@@ -29,17 +31,17 @@
  * DISABLED -    Foreground color when widget is disabled.
  */
 
-#define BLACK        "Black"
-#define WHITE        "White"
-#define NORMAL_BG      "systemWindowBody"
-#define ACTIVE_BG      "systemButtonFacePressed"
-#define ACTIVE_FG      "systemPushButtonPressedText"
-#define SELECT_BG      "systemHighlight"
-#define SELECT_FG      None
-#define INACTIVE_SELECT_BG    "systemHighlightSecondary"
-#define TROUGH        "#c3c3c3"
-#define INDICATOR      "#b03060"
-#define DISABLED      "#a3a3a3"
+#define BLACK      "Black"
+#define WHITE      "White"
+#define NORMAL_BG    "systemWindowBody"
+#define ACTIVE_BG    "systemButtonFacePressed"
+#define ACTIVE_FG    "systemPushButtonPressedText"
+#define SELECT_BG    "systemHighlight"
+#define SELECT_FG    None
+#define INACTIVE_SELECT_BG  "systemHighlightSecondary"
+#define TROUGH      "#c3c3c3"
+#define INDICATOR    "#b03060"
+#define DISABLED    "#a3a3a3"
 
 /*
  * Defaults for labels, buttons, checkbuttons, and radiobuttons:
@@ -70,17 +72,32 @@
 #define DEF_BUTTON_HIGHLIGHT_BG_MONO  DEF_BUTTON_BG_MONO
 #define DEF_BUTTON_HIGHLIGHT    "systemButtonFrame"
 #define DEF_LABEL_HIGHLIGHT_WIDTH  "0"
+#if TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
 #define DEF_BUTTON_HIGHLIGHT_WIDTH  "4"
-#define DEF_BUTTON_IMAGE    (char *) NULL
+#define DEF_BUTTON_HIGHLIGHT_WIDTH_NOCM  "1"
+#else
+#define DEF_BUTTON_HIGHLIGHT_WIDTH  "1"
+#endif
+#define DEF_BUTTON_IMAGE    ((char *) NULL)
 #define DEF_BUTTON_INDICATOR    "1"
 #define DEF_BUTTON_JUSTIFY    "center"
 #define DEF_BUTTON_OFF_VALUE    "0"
 #define DEF_BUTTON_ON_VALUE    "1"
 #define DEF_BUTTON_TRISTATE_VALUE  ""
 #define DEF_BUTTON_OVER_RELIEF    ""
+#if TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
 #define DEF_BUTTON_PADX      "12"
+#define DEF_BUTTON_PADX_NOCM    "1"
+#else
+#define DEF_BUTTON_PADX      "1"
+#endif
 #define DEF_LABCHKRAD_PADX    "1"
+#if TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
 #define DEF_BUTTON_PADY      "3"
+#define DEF_BUTTON_PADY_NOCM    "1"
+#else
+#define DEF_BUTTON_PADY      "1"
+#endif
 #define DEF_LABCHKRAD_PADY    "1"
 #define DEF_BUTTON_RELIEF    "flat"
 #define DEF_LABCHKRAD_RELIEF    "flat"
@@ -88,10 +105,10 @@
 #define DEF_BUTTON_REPEAT_INTERVAL  "0"
 #define DEF_BUTTON_SELECT_COLOR    INDICATOR
 #define DEF_BUTTON_SELECT_MONO    BLACK
-#define DEF_BUTTON_SELECT_IMAGE    (char *) NULL
+#define DEF_BUTTON_SELECT_IMAGE    ((char *) NULL)
 #define DEF_BUTTON_STATE    "normal"
 #define DEF_LABEL_TAKE_FOCUS    "0"
-#define DEF_BUTTON_TAKE_FOCUS    (char *) NULL
+#define DEF_BUTTON_TAKE_FOCUS    ((char *) NULL)
 #define DEF_BUTTON_TEXT      ""
 #define DEF_BUTTON_TEXT_VARIABLE  ""
 #define DEF_BUTTON_UNDERLINE    "-1"
@@ -129,7 +146,7 @@
 #define DEF_CANVAS_SELECT_BD_MONO  "0"
 #define DEF_CANVAS_SELECT_FG_COLOR  SELECT_FG
 #define DEF_CANVAS_SELECT_FG_MONO  WHITE
-#define DEF_CANVAS_TAKE_FOCUS    (char *) NULL
+#define DEF_CANVAS_TAKE_FOCUS    ((char *) NULL)
 #define DEF_CANVAS_WIDTH    "10c"
 #define DEF_CANVAS_X_SCROLL_CMD    ""
 #define DEF_CANVAS_X_SCROLL_INCREMENT  "0"
@@ -185,9 +202,9 @@
 #define DEF_ENTRY_SELECT_BD_MONO  "0"
 #define DEF_ENTRY_SELECT_FG_COLOR  SELECT_FG
 #define DEF_ENTRY_SELECT_FG_MONO  WHITE
-#define DEF_ENTRY_SHOW      (char *) NULL
+#define DEF_ENTRY_SHOW      ((char *) NULL)
 #define DEF_ENTRY_STATE      "normal"
-#define DEF_ENTRY_TAKE_FOCUS    (char *) NULL
+#define DEF_ENTRY_TAKE_FOCUS    ((char *) NULL)
 #define DEF_ENTRY_TEXT_VARIABLE    ""
 #define DEF_ENTRY_WIDTH      "20"
 
@@ -253,36 +270,36 @@
 #define DEF_LISTBOX_SELECT_MODE    "browse"
 #define DEF_LISTBOX_SET_GRID    "0"
 #define DEF_LISTBOX_STATE    "normal"
-#define DEF_LISTBOX_TAKE_FOCUS    (char *) NULL
+#define DEF_LISTBOX_TAKE_FOCUS    ((char *) NULL)
 #define DEF_LISTBOX_WIDTH    "20"
 
 /*
  * Defaults for individual entries of menus:
  */
 
-#define DEF_MENU_ENTRY_ACTIVE_BG  (char *) NULL
-#define DEF_MENU_ENTRY_ACTIVE_FG  (char *) NULL
-#define DEF_MENU_ENTRY_ACCELERATOR  (char *) NULL
-#define DEF_MENU_ENTRY_BG    (char *) NULL
+#define DEF_MENU_ENTRY_ACTIVE_BG  ((char *) NULL)
+#define DEF_MENU_ENTRY_ACTIVE_FG  ((char *) NULL)
+#define DEF_MENU_ENTRY_ACCELERATOR  ((char *) NULL)
+#define DEF_MENU_ENTRY_BG    ((char *) NULL)
 #define DEF_MENU_ENTRY_BITMAP    None
 #define DEF_MENU_ENTRY_COLUMN_BREAK  "0"
-#define DEF_MENU_ENTRY_COMMAND    (char *) NULL
+#define DEF_MENU_ENTRY_COMMAND    ((char *) NULL)
 #define DEF_MENU_ENTRY_COMPOUND    "none"
-#define DEF_MENU_ENTRY_FG    (char *) NULL
-#define DEF_MENU_ENTRY_FONT    (char *) NULL
+#define DEF_MENU_ENTRY_FG    ((char *) NULL)
+#define DEF_MENU_ENTRY_FONT    ((char *) NULL)
 #define DEF_MENU_ENTRY_HIDE_MARGIN  "0"
-#define DEF_MENU_ENTRY_IMAGE    (char *) NULL
+#define DEF_MENU_ENTRY_IMAGE    ((char *) NULL)
 #define DEF_MENU_ENTRY_INDICATOR  "1"
-#define DEF_MENU_ENTRY_LABEL    (char *) NULL
-#define DEF_MENU_ENTRY_MENU    (char *) NULL
+#define DEF_MENU_ENTRY_LABEL    ((char *) NULL)
+#define DEF_MENU_ENTRY_MENU    ((char *) NULL)
 #define DEF_MENU_ENTRY_OFF_VALUE  "0"
 #define DEF_MENU_ENTRY_ON_VALUE    "1"
-#define DEF_MENU_ENTRY_SELECT_IMAGE  (char *) NULL
+#define DEF_MENU_ENTRY_SELECT_IMAGE  ((char *) NULL)
 #define DEF_MENU_ENTRY_STATE    "normal"
-#define DEF_MENU_ENTRY_VALUE    (char *) NULL
-#define DEF_MENU_ENTRY_CHECK_VARIABLE  (char *) NULL
+#define DEF_MENU_ENTRY_VALUE    ((char *) NULL)
+#define DEF_MENU_ENTRY_CHECK_VARIABLE  ((char *) NULL)
 #define DEF_MENU_ENTRY_RADIO_VARIABLE  "selectedButton"
-#define DEF_MENU_ENTRY_SELECT  (char *) NULL
+#define DEF_MENU_ENTRY_SELECT    ((char *) NULL)
 #define DEF_MENU_ENTRY_UNDERLINE  "-1"
 
 /*
@@ -313,7 +330,7 @@
  */
 
 #define DEF_MENU_TEAROFF    "0"
-#define DEF_MENU_TEAROFF_CMD    (char *) NULL
+#define DEF_MENU_TEAROFF_CMD    ((char *) NULL)
 #define DEF_MENU_TITLE      ""
 #define DEF_MENU_TYPE      "normal"
 
@@ -341,13 +358,12 @@
 #define DEF_MENUBUTTON_HIGHLIGHT_BG_MONO  DEF_MENUBUTTON_BG_MONO
 #define DEF_MENUBUTTON_HIGHLIGHT  BLACK
 #define DEF_MENUBUTTON_HIGHLIGHT_WIDTH  "0"
-#define DEF_MENUBUTTON_IMAGE    (char *) NULL
-#define DEF_MENUBUTTON_INDICATOR  "0"
-/* #define DEF_MENUBUTTON_JUSTIFY    "center" */
+#define DEF_MENUBUTTON_IMAGE    ((char *) NULL)
+#define DEF_MENUBUTTON_INDICATOR  "1"
 #define DEF_MENUBUTTON_JUSTIFY    "left"
 #define DEF_MENUBUTTON_MENU    ""
-#define DEF_MENUBUTTON_PADX    "4p"
-#define DEF_MENUBUTTON_PADY    "3p"
+#define DEF_MENUBUTTON_PADX    "4"
+#define DEF_MENUBUTTON_PADY    "3"
 #define DEF_MENUBUTTON_RELIEF    "flat"
 #define DEF_MENUBUTTON_STATE    "normal"
 #define DEF_MENUBUTTON_TAKE_FOCUS  "0"
@@ -450,7 +466,7 @@
 #define DEF_SCALE_SLIDER_LENGTH    "30"
 #define DEF_SCALE_SLIDER_RELIEF    "raised"
 #define DEF_SCALE_STATE      "normal"
-#define DEF_SCALE_TAKE_FOCUS    (char *) NULL
+#define DEF_SCALE_TAKE_FOCUS    ((char *) NULL)
 #define DEF_SCALE_TICK_INTERVAL    "0"
 #define DEF_SCALE_TO      "100"
 #define DEF_SCALE_VARIABLE    ""
@@ -477,7 +493,7 @@
 #define DEF_SCROLLBAR_RELIEF    "flat"
 #define DEF_SCROLLBAR_REPEAT_DELAY  "300"
 #define DEF_SCROLLBAR_REPEAT_INTERVAL  "100"
-#define DEF_SCROLLBAR_TAKE_FOCUS  (char *) NULL
+#define DEF_SCROLLBAR_TAKE_FOCUS  ((char *) NULL)
 #define DEF_SCROLLBAR_TROUGH_COLOR  TROUGH
 #define DEF_SCROLLBAR_TROUGH_MONO  WHITE
 #define DEF_SCROLLBAR_WIDTH    "15"
@@ -504,6 +520,7 @@
 #define DEF_TEXT_INSERT_BD_MONO    "0"
 #define DEF_TEXT_INSERT_OFF_TIME  "300"
 #define DEF_TEXT_INSERT_ON_TIME    "600"
+#define DEF_TEXT_INSERT_UNFOCUSSED  "none"
 #define DEF_TEXT_INSERT_WIDTH    "1"
 #define DEF_TEXT_MAX_UNDO    "0"
 #define DEF_TEXT_PADX      "1"
@@ -524,7 +541,7 @@
 #define DEF_TEXT_STATE      "normal"
 #define DEF_TEXT_TABS      ""
 #define DEF_TEXT_TABSTYLE    "tabular"
-#define DEF_TEXT_TAKE_FOCUS    (char *) NULL
+#define DEF_TEXT_TAKE_FOCUS    ((char *) NULL)
 #define DEF_TEXT_UNDO      "0"
 #define DEF_TEXT_WIDTH      "80"
 #define DEF_TEXT_WRAP      "char"
@@ -547,4 +564,10 @@
 #define DEF_TOPLEVEL_SCREEN    ""
 #define DEF_TOPLEVEL_USE    ""
 
+/*
+ * Defaults for busy windows (not really used yet):
+ */
+
+#define DEF_BUSY_CURSOR      "watch"
+
 #endif /* _TKMACDEFAULT */
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkMacOSXInt.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkMacOSXInt.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkMacOSXInt.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkMacOSXInt.h	2019-02-01 16:20:04.000000000 +0100
@@ -4,13 +4,11 @@
  *  Declarations of Macintosh specific shared variables and procedures.
  *
  * Copyright (c) 1995-1997 Sun Microsystems, Inc.
- * Copyright 2001, Apple Computer, Inc.
- * Copyright (c) 2005-2007 Daniel A. Steffen <das@users.sourceforge.net>
+ * Copyright 2001-2009, Apple Inc.
+ * Copyright (c) 2005-2009 Daniel A. Steffen <das@users.sourceforge.net>
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TKMACINT
@@ -20,10 +18,6 @@
 #include "tkInt.h"
 #endif
 
-#define TextStyle MacTextStyle
-#include <Carbon/Carbon.h>
-#undef TextStyle
-
 /*
  * Include platform specific public interfaces.
  */
@@ -32,17 +26,46 @@
 #include "tkMacOSX.h"
 #endif
 
+/*
+ * Define compatibility platform types used in the structures below so that
+ * this header can be included without pulling in the platform headers.
+ */
+
+#ifndef _TKMACPRIV
+#   ifndef CGGEOMETRY_H_
+#  ifndef CGFLOAT_DEFINED
+#      if __LP64__
+#    define CGFloat double
+#      else
+#    define CGFloat float
+#      endif
+#  endif
+#  define CGSize struct {CGFloat width; CGFloat height;}
+#   endif
+#   ifndef CGCONTEXT_H_
+#  define CGContextRef void *
+#   endif
+#   ifndef CGCOLOR_H_
+#  define CGColorRef void *
+#   endif
+#   ifndef __HISHAPE__
+#  define HIShapeRef void *
+#   endif
+#   ifndef _APPKITDEFINES_H
+#  define NSView void *
+#   endif
+#endif
+
 struct TkWindowPrivate {
     TkWindow *winPtr;    /* Ptr to tk window or NULL if Pixmap */
-    CGrafPtr grafPtr;
+    NSView *view;
     CGContextRef context;
-    ControlRef rootControl;
     int xOff;      /* X offset from toplevel window */
     int yOff;      /* Y offset from toplevel window */
     CGSize size;
     HIShapeRef visRgn;    /* Visible region of window */
     HIShapeRef aboveVisRgn;  /* Visible region of window & its children */
-    CGRect drawRect;    /* Clipped drawing rect */
+    HIShapeRef drawRgn;    /* Clipped drawing region */
     int referenceCount;    /* Don't delete toplevel until children are
          * gone. */
     struct TkWindowPrivate *toplevel;
@@ -52,18 +75,6 @@
 typedef struct TkWindowPrivate MacDrawable;
 
 /*
- * This list is used to keep track of toplevel windows that have a Mac
- * window attached. This is useful for several things, not the least
- * of which is maintaining floating windows.
- */
-
-typedef struct TkMacOSXWindowList {
-    struct TkMacOSXWindowList *nextPtr;
-        /* The next window in the list. */
-    TkWindow *winPtr;    /* This window */
-} TkMacOSXWindowList;
-
-/*
  * Defines use for the flags field of the MacDrawable data structure.
  */
 
@@ -71,7 +82,7 @@
 #define TK_CLIP_INVALID    0x02
 #define TK_HOST_EXISTS    0x04
 #define TK_DRAWN_UNDER_MENU  0x08
-#define TK_CLIPPED_DRAW    0x10
+#define TK_FOCUSED_VIEW    0x10
 #define TK_IS_PIXMAP    0x20
 #define TK_IS_BW_PIXMAP    0x40
 
@@ -103,6 +114,46 @@
 MODULE_SCOPE TkMacOSXEmbedHandler *tkMacOSXEmbedHandler;
 
 /*
+ * GC CGColorRef cache for tkMacOSXColor.c
+ */
+
+typedef struct {
+    unsigned long cachedForeground;
+    CGColorRef cachedForegroundColor;
+    unsigned long cachedBackground;
+    CGColorRef cachedBackgroundColor;
+} TkpGCCache;
+
+MODULE_SCOPE TkpGCCache *TkpGetGCCache(GC gc);
+MODULE_SCOPE void TkpInitGCCache(GC gc);
+MODULE_SCOPE void TkpFreeGCCache(GC gc);
+
+/*
+ * Undef compatibility platform types defined above.
+ */
+
+#ifndef _TKMACPRIV
+#   ifndef CGGEOMETRY_H_
+#  ifndef CGFLOAT_DEFINED
+#      undef CGFloat
+#  endif
+#  undef CGSize
+#   endif
+#   ifndef CGCONTEXT_H_
+#  undef CGContextRef
+#   endif
+#   ifndef CGCOLOR_H_
+#  undef CGColorRef
+#   endif
+#   ifndef __HISHAPE__
+#  undef HIShapeRef
+#   endif
+#   ifndef _APPKITDEFINES_H
+#  undef NSView
+#   endif
+#endif
+
+/*
  * Defines used for TkMacOSXInvalidateWindow
  */
 
@@ -117,12 +168,13 @@
     (((TkWindow *) (tkwin))->privatePtr->toplevel->flags & TK_HOST_EXISTS)
 
 /*
- * Defines use for the flags argument to TkGenWMConfigureEvent.
+ * Defines used for the flags argument to TkGenWMConfigureEvent.
  */
 
 #define TK_LOCATION_CHANGED  1
 #define TK_SIZE_CHANGED    2
 #define TK_BOTH_CHANGED    3
+#define TK_MACOSX_HANDLE_EVENT_IMMEDIATELY 1024
 
 /*
  * Defines for tkTextDisp.c
@@ -131,32 +183,6 @@
 #define TK_LAYOUT_WITH_BASE_CHUNKS  1
 #define TK_DRAW_IN_CONTEXT    1
 
-#if !TK_DRAW_IN_CONTEXT
-MODULE_SCOPE int TkMacOSXCompareColors(unsigned long c1, unsigned long c2);
-#endif
-
-/*
- * Globals shared among TkAqua.
- */
-
-MODULE_SCOPE MenuHandle tkCurrentAppleMenu; /* Handle to current Apple Menu */
-MODULE_SCOPE MenuHandle tkAppleMenu;  /* Handle to default Apple Menu */
-MODULE_SCOPE MenuHandle tkFileMenu;  /* Handles to menus */
-MODULE_SCOPE MenuHandle tkEditMenu;  /* Handles to menus */
-MODULE_SCOPE int tkPictureIsOpen;  /* If this is 1, we are drawing to a
-           * picture The clipping should then be
-           * done relative to the bounds of the
-           * picture rather than the window. As
-           * of OS X.0.4, something is seriously
-           * wrong: The clipping bounds only
-           * seem to work if the top,left values
-           * are 0,0 The destination rectangle
-           * for CopyBits should also have
-           * top,left values of 0,0
-           */
-MODULE_SCOPE TkMacOSXWindowList *tkMacOSXWindowListPtr; /* List of toplevels */
-MODULE_SCOPE Tcl_Encoding TkMacOSXCarbonEncoding;
-
 /*
  * Prototypes of internal procs not in the stubs table.
  */
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkMacOSXPort.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkMacOSXPort.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkMacOSXPort.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkMacOSXPort.h	2019-02-01 16:20:04.000000000 +0100
@@ -6,33 +6,16 @@
  *  #includes for system include files and a few other things.
  *
  * Copyright (c) 1994-1996 Sun Microsystems, Inc.
- * Copyright 2001, Apple Computer, Inc.
- * Copyright (c) 2005-2007 Daniel A. Steffen <das@users.sourceforge.net>
+ * Copyright 2001-2009, Apple Inc.
+ * Copyright (c) 2005-2009 Daniel A. Steffen <das@users.sourceforge.net>
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TKMACPORT
 #define _TKMACPORT
 
-/*
- * Macro to use instead of "void" for arguments that must have
- * type "void *" in ANSI C; maps them to type "char *" in
- * non-ANSI systems. This macro may be used in some of the include
- * files below, which is why it is defined here.
- */
-
-#ifndef VOID
-#   ifdef __STDC__
-#  define VOID void
-#   else
-#  define VOID char
-#   endif
-#endif
-
 #include <stdio.h>
 #include <ctype.h>
 #include <fcntl.h>
@@ -129,7 +112,7 @@
  */
 
 #define XFlush(display)
-#define XFree(data) {if ((data) != NULL) ckfree((char *) (data));}
+#define XFree(data) {if ((data) != NULL) ckfree(data);}
 #define XGrabServer(display)
 #define XNoOp(display) {display->request++;}
 #define XUngrabServer(display)
@@ -140,7 +123,6 @@
  * The following functions are not used on the Mac, so we stub them out.
  */
 
-#define TkpButtonSetDefaults(specPtr) {}
 #define TkpCmapStressed(tkwin,colormap) (0)
 #define TkpFreeColor(tkColPtr)
 #define TkSetPixmapColormap(p,c) {}
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkPlatDecls.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkPlatDecls.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkPlatDecls.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkPlatDecls.h	2019-02-01 16:20:04.000000000 +0100
@@ -7,8 +7,6 @@
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TKPLATDECLS
@@ -25,224 +23,151 @@
  * in the generic/tk.decls script.
  */
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /* !BEGIN!: Do not edit below this line. */
 
 /*
  * Exported function declarations:
  */
 
-#ifdef __WIN32__ /* WIN */
-#ifndef Tk_AttachHWND_TCL_DECLARED
-#define Tk_AttachHWND_TCL_DECLARED
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
 /* 0 */
-EXTERN Window    Tk_AttachHWND (Tk_Window tkwin, HWND hwnd);
-#endif
-#ifndef Tk_GetHINSTANCE_TCL_DECLARED
-#define Tk_GetHINSTANCE_TCL_DECLARED
+EXTERN Window    Tk_AttachHWND(Tk_Window tkwin, HWND hwnd);
 /* 1 */
-EXTERN HINSTANCE  Tk_GetHINSTANCE (void);
-#endif
-#ifndef Tk_GetHWND_TCL_DECLARED
-#define Tk_GetHWND_TCL_DECLARED
+EXTERN HINSTANCE  Tk_GetHINSTANCE(void);
 /* 2 */
-EXTERN HWND    Tk_GetHWND (Window window);
-#endif
-#ifndef Tk_HWNDToWindow_TCL_DECLARED
-#define Tk_HWNDToWindow_TCL_DECLARED
+EXTERN HWND    Tk_GetHWND(Window window);
 /* 3 */
-EXTERN Tk_Window  Tk_HWNDToWindow (HWND hwnd);
-#endif
-#ifndef Tk_PointerEvent_TCL_DECLARED
-#define Tk_PointerEvent_TCL_DECLARED
+EXTERN Tk_Window  Tk_HWNDToWindow(HWND hwnd);
 /* 4 */
-EXTERN void    Tk_PointerEvent (HWND hwnd, int x, int y);
-#endif
-#ifndef Tk_TranslateWinEvent_TCL_DECLARED
-#define Tk_TranslateWinEvent_TCL_DECLARED
+EXTERN void    Tk_PointerEvent(HWND hwnd, int x, int y);
 /* 5 */
-EXTERN int    Tk_TranslateWinEvent (HWND hwnd, UINT message, 
-        WPARAM wParam, LPARAM lParam, 
-        LRESULT * result);
-#endif
+EXTERN int    Tk_TranslateWinEvent(HWND hwnd, UINT message,
+        WPARAM wParam, LPARAM lParam,
+        LRESULT *result);
 #endif /* WIN */
 #ifdef MAC_OSX_TK /* AQUA */
-#ifndef Tk_MacOSXSetEmbedHandler_TCL_DECLARED
-#define Tk_MacOSXSetEmbedHandler_TCL_DECLARED
 /* 0 */
-EXTERN void    Tk_MacOSXSetEmbedHandler (
-        Tk_MacOSXEmbedRegisterWinProc * registerWinProcPtr, 
-        Tk_MacOSXEmbedGetGrafPortProc * getPortProcPtr, 
-        Tk_MacOSXEmbedMakeContainerExistProc * containerExistProcPtr, 
-        Tk_MacOSXEmbedGetClipProc * getClipProc, 
-        Tk_MacOSXEmbedGetOffsetInParentProc * getOffsetProc);
-#endif
-#ifndef Tk_MacOSXTurnOffMenus_TCL_DECLARED
-#define Tk_MacOSXTurnOffMenus_TCL_DECLARED
+EXTERN void    Tk_MacOSXSetEmbedHandler(
+        Tk_MacOSXEmbedRegisterWinProc *registerWinProcPtr,
+        Tk_MacOSXEmbedGetGrafPortProc *getPortProcPtr,
+        Tk_MacOSXEmbedMakeContainerExistProc *containerExistProcPtr,
+        Tk_MacOSXEmbedGetClipProc *getClipProc,
+        Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc);
 /* 1 */
-EXTERN void    Tk_MacOSXTurnOffMenus (void);
-#endif
-#ifndef Tk_MacOSXTkOwnsCursor_TCL_DECLARED
-#define Tk_MacOSXTkOwnsCursor_TCL_DECLARED
+EXTERN void    Tk_MacOSXTurnOffMenus(void);
 /* 2 */
-EXTERN void    Tk_MacOSXTkOwnsCursor (int tkOwnsIt);
-#endif
-#ifndef TkMacOSXInitMenus_TCL_DECLARED
-#define TkMacOSXInitMenus_TCL_DECLARED
+EXTERN void    Tk_MacOSXTkOwnsCursor(int tkOwnsIt);
 /* 3 */
-EXTERN void    TkMacOSXInitMenus (Tcl_Interp * interp);
-#endif
-#ifndef TkMacOSXInitAppleEvents_TCL_DECLARED
-#define TkMacOSXInitAppleEvents_TCL_DECLARED
+EXTERN void    TkMacOSXInitMenus(Tcl_Interp *interp);
 /* 4 */
-EXTERN void    TkMacOSXInitAppleEvents (Tcl_Interp * interp);
-#endif
-#ifndef TkGenWMConfigureEvent_TCL_DECLARED
-#define TkGenWMConfigureEvent_TCL_DECLARED
+EXTERN void    TkMacOSXInitAppleEvents(Tcl_Interp *interp);
 /* 5 */
-EXTERN void    TkGenWMConfigureEvent (Tk_Window tkwin, int x, int y, 
+EXTERN void    TkGenWMConfigureEvent(Tk_Window tkwin, int x, int y,
         int width, int height, int flags);
-#endif
-#ifndef TkMacOSXInvalClipRgns_TCL_DECLARED
-#define TkMacOSXInvalClipRgns_TCL_DECLARED
 /* 6 */
-EXTERN void    TkMacOSXInvalClipRgns (Tk_Window tkwin);
-#endif
-#ifndef TkMacOSXGetDrawablePort_TCL_DECLARED
-#define TkMacOSXGetDrawablePort_TCL_DECLARED
+EXTERN void    TkMacOSXInvalClipRgns(Tk_Window tkwin);
 /* 7 */
-EXTERN GWorldPtr  TkMacOSXGetDrawablePort (Drawable drawable);
-#endif
-#ifndef TkMacOSXGetRootControl_TCL_DECLARED
-#define TkMacOSXGetRootControl_TCL_DECLARED
+EXTERN void *    TkMacOSXGetDrawablePort(Drawable drawable);
 /* 8 */
-EXTERN ControlRef  TkMacOSXGetRootControl (Drawable drawable);
-#endif
-#ifndef Tk_MacOSXSetupTkNotifier_TCL_DECLARED
-#define Tk_MacOSXSetupTkNotifier_TCL_DECLARED
+EXTERN void *    TkMacOSXGetRootControl(Drawable drawable);
 /* 9 */
-EXTERN void    Tk_MacOSXSetupTkNotifier (void);
-#endif
-#ifndef Tk_MacOSXIsAppInFront_TCL_DECLARED
-#define Tk_MacOSXIsAppInFront_TCL_DECLARED
+EXTERN void    Tk_MacOSXSetupTkNotifier(void);
 /* 10 */
-EXTERN int    Tk_MacOSXIsAppInFront (void);
-#endif
+EXTERN int    Tk_MacOSXIsAppInFront(void);
 #endif /* AQUA */
 
 typedef struct TkPlatStubs {
     int magic;
-    CONST struct TkPlatStubHooks *hooks;
+    void *hooks;
 
-#ifdef __WIN32__ /* WIN */
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
     Window (*tk_AttachHWND) (Tk_Window tkwin, HWND hwnd); /* 0 */
     HINSTANCE (*tk_GetHINSTANCE) (void); /* 1 */
     HWND (*tk_GetHWND) (Window window); /* 2 */
     Tk_Window (*tk_HWNDToWindow) (HWND hwnd); /* 3 */
     void (*tk_PointerEvent) (HWND hwnd, int x, int y); /* 4 */
-    int (*tk_TranslateWinEvent) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT * result); /* 5 */
+    int (*tk_TranslateWinEvent) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT *result); /* 5 */
 #endif /* WIN */
 #ifdef MAC_OSX_TK /* AQUA */
-    void (*tk_MacOSXSetEmbedHandler) (Tk_MacOSXEmbedRegisterWinProc * registerWinProcPtr, Tk_MacOSXEmbedGetGrafPortProc * getPortProcPtr, Tk_MacOSXEmbedMakeContainerExistProc * containerExistProcPtr, Tk_MacOSXEmbedGetClipProc * getClipProc, Tk_MacOSXEmbedGetOffsetInParentProc * getOffsetProc); /* 0 */
+    void (*tk_MacOSXSetEmbedHandler) (Tk_MacOSXEmbedRegisterWinProc *registerWinProcPtr, Tk_MacOSXEmbedGetGrafPortProc *getPortProcPtr, Tk_MacOSXEmbedMakeContainerExistProc *containerExistProcPtr, Tk_MacOSXEmbedGetClipProc *getClipProc, Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc); /* 0 */
     void (*tk_MacOSXTurnOffMenus) (void); /* 1 */
     void (*tk_MacOSXTkOwnsCursor) (int tkOwnsIt); /* 2 */
-    void (*tkMacOSXInitMenus) (Tcl_Interp * interp); /* 3 */
-    void (*tkMacOSXInitAppleEvents) (Tcl_Interp * interp); /* 4 */
+    void (*tkMacOSXInitMenus) (Tcl_Interp *interp); /* 3 */
+    void (*tkMacOSXInitAppleEvents) (Tcl_Interp *interp); /* 4 */
     void (*tkGenWMConfigureEvent) (Tk_Window tkwin, int x, int y, int width, int height, int flags); /* 5 */
     void (*tkMacOSXInvalClipRgns) (Tk_Window tkwin); /* 6 */
-    GWorldPtr (*tkMacOSXGetDrawablePort) (Drawable drawable); /* 7 */
-    ControlRef (*tkMacOSXGetRootControl) (Drawable drawable); /* 8 */
+    void * (*tkMacOSXGetDrawablePort) (Drawable drawable); /* 7 */
+    void * (*tkMacOSXGetRootControl) (Drawable drawable); /* 8 */
     void (*tk_MacOSXSetupTkNotifier) (void); /* 9 */
     int (*tk_MacOSXIsAppInFront) (void); /* 10 */
 #endif /* AQUA */
 } TkPlatStubs;
 
-#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)
-extern CONST TkPlatStubs *tkPlatStubsPtr;
-#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern const TkPlatStubs *tkPlatStubsPtr;
+#ifdef __cplusplus
+}
+#endif
 
-#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)
+#if defined(USE_TK_STUBS)
 
 /*
  * Inline function declarations:
  */
 
-#ifdef __WIN32__ /* WIN */
-#ifndef Tk_AttachHWND
+#if defined(__WIN32__) || defined(__CYGWIN__) /* WIN */
 #define Tk_AttachHWND \
   (tkPlatStubsPtr->tk_AttachHWND) /* 0 */
-#endif
-#ifndef Tk_GetHINSTANCE
 #define Tk_GetHINSTANCE \
   (tkPlatStubsPtr->tk_GetHINSTANCE) /* 1 */
-#endif
-#ifndef Tk_GetHWND
 #define Tk_GetHWND \
   (tkPlatStubsPtr->tk_GetHWND) /* 2 */
-#endif
-#ifndef Tk_HWNDToWindow
 #define Tk_HWNDToWindow \
   (tkPlatStubsPtr->tk_HWNDToWindow) /* 3 */
-#endif
-#ifndef Tk_PointerEvent
 #define Tk_PointerEvent \
   (tkPlatStubsPtr->tk_PointerEvent) /* 4 */
-#endif
-#ifndef Tk_TranslateWinEvent
 #define Tk_TranslateWinEvent \
   (tkPlatStubsPtr->tk_TranslateWinEvent) /* 5 */
-#endif
 #endif /* WIN */
 #ifdef MAC_OSX_TK /* AQUA */
-#ifndef Tk_MacOSXSetEmbedHandler
 #define Tk_MacOSXSetEmbedHandler \
   (tkPlatStubsPtr->tk_MacOSXSetEmbedHandler) /* 0 */
-#endif
-#ifndef Tk_MacOSXTurnOffMenus
 #define Tk_MacOSXTurnOffMenus \
   (tkPlatStubsPtr->tk_MacOSXTurnOffMenus) /* 1 */
-#endif
-#ifndef Tk_MacOSXTkOwnsCursor
 #define Tk_MacOSXTkOwnsCursor \
   (tkPlatStubsPtr->tk_MacOSXTkOwnsCursor) /* 2 */
-#endif
-#ifndef TkMacOSXInitMenus
 #define TkMacOSXInitMenus \
   (tkPlatStubsPtr->tkMacOSXInitMenus) /* 3 */
-#endif
-#ifndef TkMacOSXInitAppleEvents
 #define TkMacOSXInitAppleEvents \
   (tkPlatStubsPtr->tkMacOSXInitAppleEvents) /* 4 */
-#endif
-#ifndef TkGenWMConfigureEvent
 #define TkGenWMConfigureEvent \
   (tkPlatStubsPtr->tkGenWMConfigureEvent) /* 5 */
-#endif
-#ifndef TkMacOSXInvalClipRgns
 #define TkMacOSXInvalClipRgns \
   (tkPlatStubsPtr->tkMacOSXInvalClipRgns) /* 6 */
-#endif
-#ifndef TkMacOSXGetDrawablePort
 #define TkMacOSXGetDrawablePort \
   (tkPlatStubsPtr->tkMacOSXGetDrawablePort) /* 7 */
-#endif
-#ifndef TkMacOSXGetRootControl
 #define TkMacOSXGetRootControl \
   (tkPlatStubsPtr->tkMacOSXGetRootControl) /* 8 */
-#endif
-#ifndef Tk_MacOSXSetupTkNotifier
 #define Tk_MacOSXSetupTkNotifier \
   (tkPlatStubsPtr->tk_MacOSXSetupTkNotifier) /* 9 */
-#endif
-#ifndef Tk_MacOSXIsAppInFront
 #define Tk_MacOSXIsAppInFront \
   (tkPlatStubsPtr->tk_MacOSXIsAppInFront) /* 10 */
-#endif
 #endif /* AQUA */
 
-#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */
+#endif /* defined(USE_TK_STUBS) */
 
 /* !END!: Do not edit above this line. */
 
+#ifdef __cplusplus
+}
+#endif
+
 #undef TCL_STORAGE_CLASS
 #define TCL_STORAGE_CLASS DLLIMPORT
 
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkPort.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkPort.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkPort.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkPort.h	2019-02-01 16:20:04.000000000 +0100
@@ -9,23 +9,18 @@
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TKPORT
 #define _TKPORT
 
-#ifndef _TK
-#include "tk.h"
+#if defined(_WIN32)
+#   include "tkWinPort.h"
 #endif
-#ifndef _TCL
-#include "tcl.h"
+#ifndef _TK
+#   include "tk.h"
 #endif
-
-#if defined(__WIN32__) || defined(_WIN32)
-#   include "tkWinPort.h"
-#else
+#if !defined(_WIN32)
 #   if defined(MAC_OSX_TK)
 #  include "tkMacOSXPort.h"
 #   else
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkUnixDefault.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkUnixDefault.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkUnixDefault.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkUnixDefault.h	2019-02-01 16:20:04.000000000 +0100
@@ -9,8 +9,6 @@
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TKUNIXDEFAULT
@@ -66,7 +64,7 @@
 #define DEF_BUTTON_HIGHLIGHT    BLACK
 #define DEF_LABEL_HIGHLIGHT_WIDTH  "0"
 #define DEF_BUTTON_HIGHLIGHT_WIDTH  "1"
-#define DEF_BUTTON_IMAGE    (char *) NULL
+#define DEF_BUTTON_IMAGE    ((char *) NULL)
 #define DEF_BUTTON_INDICATOR    "1"
 #define DEF_BUTTON_JUSTIFY    "center"
 #define DEF_BUTTON_OFF_VALUE    "0"
@@ -83,10 +81,10 @@
 #define DEF_BUTTON_REPEAT_INTERVAL  "0"
 #define DEF_BUTTON_SELECT_COLOR    CHECK_INDICATOR
 #define DEF_BUTTON_SELECT_MONO    BLACK
-#define DEF_BUTTON_SELECT_IMAGE    (char *) NULL
+#define DEF_BUTTON_SELECT_IMAGE    ((char *) NULL)
 #define DEF_BUTTON_STATE    "normal"
 #define DEF_LABEL_TAKE_FOCUS    "0"
-#define DEF_BUTTON_TAKE_FOCUS    (char *) NULL
+#define DEF_BUTTON_TAKE_FOCUS    ((char *) NULL)
 #define DEF_BUTTON_TEXT      ""
 #define DEF_BUTTON_TEXT_VARIABLE  ""
 #define DEF_BUTTON_UNDERLINE    "-1"
@@ -124,7 +122,7 @@
 #define DEF_CANVAS_SELECT_BD_MONO  "0"
 #define DEF_CANVAS_SELECT_FG_COLOR  BLACK
 #define DEF_CANVAS_SELECT_FG_MONO  WHITE
-#define DEF_CANVAS_TAKE_FOCUS    (char *) NULL
+#define DEF_CANVAS_TAKE_FOCUS    ((char *) NULL)
 #define DEF_CANVAS_WIDTH    "10c"
 #define DEF_CANVAS_X_SCROLL_CMD    ""
 #define DEF_CANVAS_X_SCROLL_INCREMENT  "0"
@@ -165,9 +163,9 @@
 #define DEF_ENTRY_SELECT_BD_MONO  "0"
 #define DEF_ENTRY_SELECT_FG_COLOR  BLACK
 #define DEF_ENTRY_SELECT_FG_MONO  WHITE
-#define DEF_ENTRY_SHOW      (char *) NULL
+#define DEF_ENTRY_SHOW      ((char *) NULL)
 #define DEF_ENTRY_STATE      "normal"
-#define DEF_ENTRY_TAKE_FOCUS    (char *) NULL
+#define DEF_ENTRY_TAKE_FOCUS    ((char *) NULL)
 #define DEF_ENTRY_TEXT_VARIABLE    ""
 #define DEF_ENTRY_WIDTH      "20"
 
@@ -234,36 +232,36 @@
 #define DEF_LISTBOX_SELECT_MODE    "browse"
 #define DEF_LISTBOX_SET_GRID    "0"
 #define DEF_LISTBOX_STATE    "normal"
-#define DEF_LISTBOX_TAKE_FOCUS    (char *) NULL
+#define DEF_LISTBOX_TAKE_FOCUS    ((char *) NULL)
 #define DEF_LISTBOX_WIDTH    "20"
 
 /*
  * Defaults for individual entries of menus:
  */
 
-#define DEF_MENU_ENTRY_ACTIVE_BG  (char *) NULL
-#define DEF_MENU_ENTRY_ACTIVE_FG  (char *) NULL
-#define DEF_MENU_ENTRY_ACCELERATOR  (char *) NULL
-#define DEF_MENU_ENTRY_BG    (char *) NULL
+#define DEF_MENU_ENTRY_ACTIVE_BG  ((char *) NULL)
+#define DEF_MENU_ENTRY_ACTIVE_FG  ((char *) NULL)
+#define DEF_MENU_ENTRY_ACCELERATOR  ((char *) NULL)
+#define DEF_MENU_ENTRY_BG    ((char *) NULL)
 #define DEF_MENU_ENTRY_BITMAP    None
 #define DEF_MENU_ENTRY_COLUMN_BREAK  "0"
-#define DEF_MENU_ENTRY_COMMAND    (char *) NULL
+#define DEF_MENU_ENTRY_COMMAND    ((char *) NULL)
 #define DEF_MENU_ENTRY_COMPOUND   "none"
-#define DEF_MENU_ENTRY_FG    (char *) NULL
-#define DEF_MENU_ENTRY_FONT    (char *) NULL
+#define DEF_MENU_ENTRY_FG    ((char *) NULL)
+#define DEF_MENU_ENTRY_FONT    ((char *) NULL)
 #define DEF_MENU_ENTRY_HIDE_MARGIN  "0"
-#define DEF_MENU_ENTRY_IMAGE    (char *) NULL
+#define DEF_MENU_ENTRY_IMAGE    ((char *) NULL)
 #define DEF_MENU_ENTRY_INDICATOR  "1"
-#define DEF_MENU_ENTRY_LABEL    (char *) NULL
-#define DEF_MENU_ENTRY_MENU    (char *) NULL
+#define DEF_MENU_ENTRY_LABEL    ((char *) NULL)
+#define DEF_MENU_ENTRY_MENU    ((char *) NULL)
 #define DEF_MENU_ENTRY_OFF_VALUE  "0"
 #define DEF_MENU_ENTRY_ON_VALUE    "1"
-#define DEF_MENU_ENTRY_SELECT_IMAGE  (char *) NULL
+#define DEF_MENU_ENTRY_SELECT_IMAGE  ((char *) NULL)
 #define DEF_MENU_ENTRY_STATE    "normal"
-#define DEF_MENU_ENTRY_VALUE    (char *) NULL
-#define DEF_MENU_ENTRY_CHECK_VARIABLE  (char *) NULL
+#define DEF_MENU_ENTRY_VALUE    ((char *) NULL)
+#define DEF_MENU_ENTRY_CHECK_VARIABLE  ((char *) NULL)
 #define DEF_MENU_ENTRY_RADIO_VARIABLE  "selectedButton"
-#define DEF_MENU_ENTRY_SELECT  (char *) NULL
+#define DEF_MENU_ENTRY_SELECT    ((char *) NULL)
 #define DEF_MENU_ENTRY_UNDERLINE  "-1"
 
 /*
@@ -289,7 +287,7 @@
 #define DEF_MENU_SELECT_MONO    BLACK
 #define DEF_MENU_TAKE_FOCUS    "0"
 #define DEF_MENU_TEAROFF    "1"
-#define DEF_MENU_TEAROFF_CMD    (char *) NULL
+#define DEF_MENU_TEAROFF_CMD    ((char *) NULL)
 #define DEF_MENU_TITLE      ""
 #define DEF_MENU_TYPE      "normal"
 
@@ -317,7 +315,7 @@
 #define DEF_MENUBUTTON_HIGHLIGHT_BG_MONO  DEF_MENUBUTTON_BG_MONO
 #define DEF_MENUBUTTON_HIGHLIGHT  BLACK
 #define DEF_MENUBUTTON_HIGHLIGHT_WIDTH  "0"
-#define DEF_MENUBUTTON_IMAGE    (char *) NULL
+#define DEF_MENUBUTTON_IMAGE    ((char *) NULL)
 #define DEF_MENUBUTTON_INDICATOR  "0"
 #define DEF_MENUBUTTON_JUSTIFY    "center"
 #define DEF_MENUBUTTON_MENU    ""
@@ -417,7 +415,7 @@
 #define DEF_SCALE_LENGTH    "100"
 #define DEF_SCALE_ORIENT    "vertical"
 #define DEF_SCALE_RELIEF    "flat"
-#define DEF_SCALE_REPEAT_DELAY          "300"
+#define DEF_SCALE_REPEAT_DELAY    "300"
 #define DEF_SCALE_REPEAT_INTERVAL  "100"
 #define DEF_SCALE_RESOLUTION    "1"
 #define DEF_SCALE_TROUGH_COLOR    TROUGH
@@ -426,7 +424,7 @@
 #define DEF_SCALE_SLIDER_LENGTH    "30"
 #define DEF_SCALE_SLIDER_RELIEF    "raised"
 #define DEF_SCALE_STATE      "normal"
-#define DEF_SCALE_TAKE_FOCUS    (char *) NULL
+#define DEF_SCALE_TAKE_FOCUS    ((char *) NULL)
 #define DEF_SCALE_TICK_INTERVAL    "0"
 #define DEF_SCALE_TO      "100"
 #define DEF_SCALE_VARIABLE    ""
@@ -453,7 +451,7 @@
 #define DEF_SCROLLBAR_RELIEF    "sunken"
 #define DEF_SCROLLBAR_REPEAT_DELAY  "300"
 #define DEF_SCROLLBAR_REPEAT_INTERVAL  "100"
-#define DEF_SCROLLBAR_TAKE_FOCUS  (char *) NULL
+#define DEF_SCROLLBAR_TAKE_FOCUS  ((char *) NULL)
 #define DEF_SCROLLBAR_TROUGH_COLOR  TROUGH
 #define DEF_SCROLLBAR_TROUGH_MONO  WHITE
 #define DEF_SCROLLBAR_WIDTH    "11"
@@ -480,8 +478,9 @@
 #define DEF_TEXT_INSERT_BD_MONO    "0"
 #define DEF_TEXT_INSERT_OFF_TIME  "300"
 #define DEF_TEXT_INSERT_ON_TIME    "600"
+#define DEF_TEXT_INSERT_UNFOCUSSED  "none"
 #define DEF_TEXT_INSERT_WIDTH    "2"
-#define DEF_TEXT_MAX_UNDO      "0"
+#define DEF_TEXT_MAX_UNDO    "0"
 #define DEF_TEXT_PADX      "1"
 #define DEF_TEXT_PADY      "1"
 #define DEF_TEXT_RELIEF      "sunken"
@@ -500,8 +499,8 @@
 #define DEF_TEXT_STATE      "normal"
 #define DEF_TEXT_TABS      ""
 #define DEF_TEXT_TABSTYLE    "tabular"
-#define DEF_TEXT_TAKE_FOCUS    (char *) NULL
-#define DEF_TEXT_UNDO        "0"
+#define DEF_TEXT_TAKE_FOCUS    ((char *) NULL)
+#define DEF_TEXT_UNDO      "0"
 #define DEF_TEXT_WIDTH      "80"
 #define DEF_TEXT_WRAP      "char"
 #define DEF_TEXT_XSCROLL_COMMAND  ""
@@ -523,4 +522,10 @@
 #define DEF_TOPLEVEL_SCREEN    ""
 #define DEF_TOPLEVEL_USE    ""
 
+/*
+ * Defaults for busy windows:
+ */
+
+#define DEF_BUSY_CURSOR      "watch"
+
 #endif /* _TKUNIXDEFAULT */
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkUnixPort.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkUnixPort.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkUnixPort.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkUnixPort.h	2019-02-01 16:20:04.000000000 +0100
@@ -10,8 +10,6 @@
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _UNIXPORT
@@ -19,21 +17,6 @@
 
 #define __UNIX__ 1
 
-/*
- * Macro to use instead of "void" for arguments that must have
- * type "void *" in ANSI C;  maps them to type "char *" in
- * non-ANSI systems.  This macro may be used in some of the include
- * files below, which is why it is defined here.
- */
-
-#ifndef VOID
-#   ifdef __STDC__
-#       define VOID void
-#   else
-#       define VOID char
-#   endif
-#endif
-
 #include <stdio.h>
 #include <ctype.h>
 #include <fcntl.h>
@@ -130,30 +113,34 @@
 #   define NBBY 8
 #endif
 
-/*
- * These macros are just wrappers for the equivalent X Region calls.
- */
-
-#define TkClipBox(rgn, rect) XClipBox((Region) rgn, rect)
-#define TkCreateRegion() (TkRegion) XCreateRegion()
-#define TkDestroyRegion(rgn) XDestroyRegion((Region) rgn)
-#define TkIntersectRegion(a, b, r) XIntersectRegion((Region) a, \
-  (Region) b, (Region) r)
-#define TkRectInRegion(r, x, y, w, h) XRectInRegion((Region) r, x, y, w, h)
-#define TkSetRegion(d, gc, rgn) XSetRegion(d, gc, (Region) rgn)
-#define TkSubtractRegion(a, b, r) XSubtractRegion((Region) a, \
-  (Region) b, (Region) r)
-#define TkUnionRectWithRegion(rect, src, ret) XUnionRectWithRegion(rect, \
-  (Region) src, (Region) ret)
-
-/*
- * The TkPutImage macro strips off the color table information, which isn't
- * needed for X.
- */
+#ifdef __CYGWIN__
+#   define UINT unsigned int
+#   define HWND void *
+#   define HDC void *
+#   define HINSTANCE void *
+#   define COLORREF void *
+#   define HMENU void *
+#   define TkWinDCState void
+#   define HPALETTE void *
+#   define WNDPROC void *
+#   define WPARAM void *
+#   define LPARAM void *
+#   define LRESULT void *
+
+EXTERN int TkPutImage (unsigned long *, int, Display *, Drawable, GC,
+  XImage *, int, int, int, int, unsigned int, unsigned int);
+
+#else /* !__CYGWIN__ */
+    /*
+     * The TkPutImage macro strips off the color table information, which isn't
+     * needed for X.
+     */
+
+#   define TkPutImage(colors, ncolors, display, pixels, gc, image, srcx, srcy, destx, desty, width, height) \
+    XPutImage(display, pixels, gc, image, srcx, srcy, destx, \
+    desty, width, height);
 
-#define TkPutImage(colors, ncolors, display, pixels, gc, image, srcx, srcy, destx, desty, width, height) \
-  XPutImage(display, pixels, gc, image, srcx, srcy, destx, \
-  desty, width, height);
+#endif /* !__CYGWIN__ */
 
 /*
  * Supply macros for seek offsets, if they're not already provided by
@@ -182,10 +169,12 @@
  * These functions do nothing under Unix, so we just eliminate calls to them.
  */
 
-#define TkpButtonSetDefaults(specPtr) {}
+#define TkpButtonSetDefaults() {}
 #define TkpDestroyButton(butPtr) {}
 #define TkSelUpdateClipboard(a,b) {}
+#ifndef __CYGWIN__
 #define TkSetPixmapColormap(p,c) {}
+#endif
 
 /*
  * These calls implement native bitmaps which are not supported under
@@ -201,7 +190,9 @@
  * This should perhaps use the real size of an XID.
  */
 
+#ifndef __CYGWIN__
 #define TkpPrintWindowId(buf,w) \
   sprintf((buf), "%#08lx", (unsigned long) (w))
+#endif
 
 #endif /* _UNIXPORT */
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkWin.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkWin.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkWin.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkWin.h	2019-02-01 16:20:04.000000000 +0100
@@ -8,8 +8,6 @@
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TKWIN
@@ -20,14 +18,14 @@
  * the SystemParametersInfo API doesn't like to receive structures that
  * are larger than it expects which affects the font assignements.
  *
- * WINVER = 0x0410 means Windows 98 and above
+ * WINVER = 0x0500 means Windows 2000 and above
  */
 
 #ifndef WINVER
-#define WINVER 0x0410
+#define WINVER 0x0500
 #endif
-#ifndef _WIN32_WINDOWS
-#define _WIN32_WINDOWS 0x0410
+#ifndef _WIN32_WINNT
+#define _WIN32_WINNT 0x0500
 #endif
 
 #ifndef _TK
@@ -38,16 +36,11 @@
 #include <windows.h>
 #undef WIN32_LEAN_AND_MEAN
 
-#ifdef BUILD_tk
-# undef TCL_STORAGE_CLASS
-# define TCL_STORAGE_CLASS DLLEXPORT
-#endif
-
 /*
  * The following messages are used to communicate between a Tk toplevel
- * and its container window. A Tk container may not be able to provide 
- * service to all of the following requests at the moment. But an embedded 
- * Tk window will send out these requests to support external Tk container 
+ * and its container window. A Tk container may not be able to provide
+ * service to all of the following requests at the moment. But an embedded
+ * Tk window will send out these requests to support external Tk container
  * application.
  */
 
@@ -68,13 +61,13 @@
 
 /*
  * The following are sub-messages (wParam) for TK_INFO.  An embedded window may
- * send a TK_INFO message with one of the sub-messages to query a container 
+ * send a TK_INFO message with one of the sub-messages to query a container
  * for verification and availability
  */
 #define TK_CONTAINER_VERIFY      0x01
 #define TK_CONTAINER_ISAVAILABLE    0x02
 
-
+
 /*
  *--------------------------------------------------------------
  *
@@ -85,7 +78,4 @@
 
 #include "tkPlatDecls.h"
 
-# undef TCL_STORAGE_CLASS
-# define TCL_STORAGE_CLASS DLLIMPORT
-
 #endif /* _TKWIN */
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkWinDefault.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkWinDefault.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkWinDefault.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkWinDefault.h	2019-02-01 16:20:04.000000000 +0100
@@ -8,8 +8,6 @@
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TKWINDEFAULT
@@ -70,7 +68,7 @@
 #define DEF_BUTTON_HIGHLIGHT    HIGHLIGHT
 #define DEF_LABEL_HIGHLIGHT_WIDTH  "0"
 #define DEF_BUTTON_HIGHLIGHT_WIDTH  "1"
-#define DEF_BUTTON_IMAGE    (char *) NULL
+#define DEF_BUTTON_IMAGE    ((char *) NULL)
 #define DEF_BUTTON_INDICATOR    "1"
 #define DEF_BUTTON_JUSTIFY    "center"
 #define DEF_BUTTON_OFF_VALUE    "0"
@@ -86,10 +84,10 @@
 #define DEF_BUTTON_REPEAT_INTERVAL  "0"
 #define DEF_BUTTON_SELECT_COLOR    INDICATOR
 #define DEF_BUTTON_SELECT_MONO    BLACK
-#define DEF_BUTTON_SELECT_IMAGE    (char *) NULL
+#define DEF_BUTTON_SELECT_IMAGE    ((char *) NULL)
 #define DEF_BUTTON_STATE    "normal"
 #define DEF_LABEL_TAKE_FOCUS    "0"
-#define DEF_BUTTON_TAKE_FOCUS    (char *) NULL
+#define DEF_BUTTON_TAKE_FOCUS    ((char *) NULL)
 #define DEF_BUTTON_TEXT      ""
 #define DEF_BUTTON_TEXT_VARIABLE  ""
 #define DEF_BUTTON_TRISTATE_VALUE  ""
@@ -128,7 +126,7 @@
 #define DEF_CANVAS_SELECT_BD_MONO  "0"
 #define DEF_CANVAS_SELECT_FG_COLOR  SELECT_FG
 #define DEF_CANVAS_SELECT_FG_MONO  WHITE
-#define DEF_CANVAS_TAKE_FOCUS    (char *) NULL
+#define DEF_CANVAS_TAKE_FOCUS    ((char *) NULL)
 #define DEF_CANVAS_WIDTH    "10c"
 #define DEF_CANVAS_X_SCROLL_CMD    ""
 #define DEF_CANVAS_X_SCROLL_INCREMENT  "0"
@@ -169,9 +167,9 @@
 #define DEF_ENTRY_SELECT_BD_MONO  "0"
 #define DEF_ENTRY_SELECT_FG_COLOR  SELECT_FG
 #define DEF_ENTRY_SELECT_FG_MONO  WHITE
-#define DEF_ENTRY_SHOW      (char *) NULL
+#define DEF_ENTRY_SHOW      ((char *) NULL)
 #define DEF_ENTRY_STATE      "normal"
-#define DEF_ENTRY_TAKE_FOCUS    (char *) NULL
+#define DEF_ENTRY_TAKE_FOCUS    ((char *) NULL)
 #define DEF_ENTRY_TEXT_VARIABLE    ""
 #define DEF_ENTRY_WIDTH      "20"
 
@@ -237,36 +235,36 @@
 #define DEF_LISTBOX_SELECT_MODE    "browse"
 #define DEF_LISTBOX_SET_GRID    "0"
 #define DEF_LISTBOX_STATE    "normal"
-#define DEF_LISTBOX_TAKE_FOCUS    (char *) NULL
+#define DEF_LISTBOX_TAKE_FOCUS    ((char *) NULL)
 #define DEF_LISTBOX_WIDTH    "20"
 
 /*
  * Defaults for individual entries of menus:
  */
 
-#define DEF_MENU_ENTRY_ACTIVE_BG  (char *) NULL
-#define DEF_MENU_ENTRY_ACTIVE_FG  (char *) NULL
-#define DEF_MENU_ENTRY_ACCELERATOR  (char *) NULL
-#define DEF_MENU_ENTRY_BG    (char *) NULL
+#define DEF_MENU_ENTRY_ACTIVE_BG  ((char *) NULL)
+#define DEF_MENU_ENTRY_ACTIVE_FG  ((char *) NULL)
+#define DEF_MENU_ENTRY_ACCELERATOR  ((char *) NULL)
+#define DEF_MENU_ENTRY_BG    ((char *) NULL)
 #define DEF_MENU_ENTRY_BITMAP    None
 #define DEF_MENU_ENTRY_COLUMN_BREAK  "0"
-#define DEF_MENU_ENTRY_COMMAND    (char *) NULL
+#define DEF_MENU_ENTRY_COMMAND    ((char *) NULL)
 #define DEF_MENU_ENTRY_COMPOUND   "none"
-#define DEF_MENU_ENTRY_FG    (char *) NULL
-#define DEF_MENU_ENTRY_FONT    (char *) NULL
+#define DEF_MENU_ENTRY_FG    ((char *) NULL)
+#define DEF_MENU_ENTRY_FONT    ((char *) NULL)
 #define DEF_MENU_ENTRY_HIDE_MARGIN  "0"
-#define DEF_MENU_ENTRY_IMAGE    (char *) NULL
+#define DEF_MENU_ENTRY_IMAGE    ((char *) NULL)
 #define DEF_MENU_ENTRY_INDICATOR  "1"
-#define DEF_MENU_ENTRY_LABEL    (char *) NULL
-#define DEF_MENU_ENTRY_MENU    (char *) NULL
+#define DEF_MENU_ENTRY_LABEL    ((char *) NULL)
+#define DEF_MENU_ENTRY_MENU    ((char *) NULL)
 #define DEF_MENU_ENTRY_OFF_VALUE  "0"
 #define DEF_MENU_ENTRY_ON_VALUE    "1"
-#define DEF_MENU_ENTRY_SELECT_IMAGE  (char *) NULL
+#define DEF_MENU_ENTRY_SELECT_IMAGE  ((char *) NULL)
 #define DEF_MENU_ENTRY_STATE    "normal"
-#define DEF_MENU_ENTRY_VALUE    (char *) NULL
-#define DEF_MENU_ENTRY_CHECK_VARIABLE  (char *) NULL
+#define DEF_MENU_ENTRY_VALUE    ((char *) NULL)
+#define DEF_MENU_ENTRY_CHECK_VARIABLE  ((char *) NULL)
 #define DEF_MENU_ENTRY_RADIO_VARIABLE  "selectedButton"
-#define DEF_MENU_ENTRY_SELECT  (char *) NULL
+#define DEF_MENU_ENTRY_SELECT    ((char *) NULL)
 #define DEF_MENU_ENTRY_UNDERLINE  "-1"
 
 /*
@@ -292,7 +290,7 @@
 #define DEF_MENU_SELECT_MONO    BLACK
 #define DEF_MENU_TAKE_FOCUS    "0"
 #define DEF_MENU_TEAROFF    "1"
-#define DEF_MENU_TEAROFF_CMD    (char *) NULL
+#define DEF_MENU_TEAROFF_CMD    ((char *) NULL)
 #define DEF_MENU_TITLE      ""
 #define DEF_MENU_TYPE      "normal"
 
@@ -320,7 +318,7 @@
 #define DEF_MENUBUTTON_HIGHLIGHT_BG_MONO  DEF_MENUBUTTON_BG_MONO
 #define DEF_MENUBUTTON_HIGHLIGHT  HIGHLIGHT
 #define DEF_MENUBUTTON_HIGHLIGHT_WIDTH  "0"
-#define DEF_MENUBUTTON_IMAGE    (char *) NULL
+#define DEF_MENUBUTTON_IMAGE    ((char *) NULL)
 #define DEF_MENUBUTTON_INDICATOR  "0"
 #define DEF_MENUBUTTON_JUSTIFY    "center"
 #define DEF_MENUBUTTON_MENU    ""
@@ -420,7 +418,7 @@
 #define DEF_SCALE_LENGTH    "100"
 #define DEF_SCALE_ORIENT    "vertical"
 #define DEF_SCALE_RELIEF    "flat"
-#define DEF_SCALE_REPEAT_DELAY  "300"
+#define DEF_SCALE_REPEAT_DELAY    "300"
 #define DEF_SCALE_REPEAT_INTERVAL  "100"
 #define DEF_SCALE_RESOLUTION    "1"
 #define DEF_SCALE_TROUGH_COLOR    TROUGH
@@ -429,7 +427,7 @@
 #define DEF_SCALE_SLIDER_LENGTH    "30"
 #define DEF_SCALE_SLIDER_RELIEF    "raised"
 #define DEF_SCALE_STATE      "normal"
-#define DEF_SCALE_TAKE_FOCUS    (char *) NULL
+#define DEF_SCALE_TAKE_FOCUS    ((char *) NULL)
 #define DEF_SCALE_TICK_INTERVAL    "0"
 #define DEF_SCALE_TO      "100"
 #define DEF_SCALE_VARIABLE    ""
@@ -456,7 +454,7 @@
 #define DEF_SCROLLBAR_RELIEF    "sunken"
 #define DEF_SCROLLBAR_REPEAT_DELAY  "300"
 #define DEF_SCROLLBAR_REPEAT_INTERVAL  "100"
-#define DEF_SCROLLBAR_TAKE_FOCUS  (char *) NULL
+#define DEF_SCROLLBAR_TAKE_FOCUS  ((char *) NULL)
 #define DEF_SCROLLBAR_TROUGH_COLOR  TROUGH
 #define DEF_SCROLLBAR_TROUGH_MONO  WHITE
 #define DEF_SCROLLBAR_WIDTH    "10"
@@ -483,8 +481,9 @@
 #define DEF_TEXT_INSERT_BD_MONO    "0"
 #define DEF_TEXT_INSERT_OFF_TIME  "300"
 #define DEF_TEXT_INSERT_ON_TIME    "600"
+#define DEF_TEXT_INSERT_UNFOCUSSED  "none"
 #define DEF_TEXT_INSERT_WIDTH    "2"
-#define DEF_TEXT_MAX_UNDO      "0"
+#define DEF_TEXT_MAX_UNDO    "0"
 #define DEF_TEXT_PADX      "1"
 #define DEF_TEXT_PADY      "1"
 #define DEF_TEXT_RELIEF      "sunken"
@@ -503,8 +502,8 @@
 #define DEF_TEXT_STATE      "normal"
 #define DEF_TEXT_TABS      ""
 #define DEF_TEXT_TABSTYLE    "tabular"
-#define DEF_TEXT_TAKE_FOCUS    (char *) NULL
-#define DEF_TEXT_UNDO        "0"
+#define DEF_TEXT_TAKE_FOCUS    ((char *) NULL)
+#define DEF_TEXT_UNDO      "0"
 #define DEF_TEXT_WIDTH      "80"
 #define DEF_TEXT_WRAP      "char"
 #define DEF_TEXT_XSCROLL_COMMAND  ""
@@ -526,4 +525,10 @@
 #define DEF_TOPLEVEL_SCREEN    ""
 #define DEF_TOPLEVEL_USE    ""
 
+/*
+ * Defaults for busy windows:
+ */
+
+#define DEF_BUSY_CURSOR      "wait"
+
 #endif /* _TKWINDEFAULT */
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkWinInt.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkWinInt.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkWinInt.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkWinInt.h	2019-02-01 16:20:04.000000000 +0100
@@ -9,8 +9,6 @@
  *
  * See the file "license.terms" for information on usage and redistribution of
  * this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _TKWININT
@@ -28,10 +26,6 @@
 #include "tkWin.h"
 #endif
 
-#ifndef _TKPORT
-#include "tkPort.h"
-#endif
-
 /*
  * Define constants missing from older Win32 SDK header files.
  */
@@ -39,6 +33,9 @@
 #ifndef WS_EX_TOOLWINDOW
 #define WS_EX_TOOLWINDOW  0x00000080L
 #endif
+#ifndef SPI_SETKEYBOARDCUES
+#define SPI_SETKEYBOARDCUES 0x100B
+#endif
 
 /*
  * The TkWinDCState is used to save the state of a device context so that it
@@ -120,16 +117,16 @@
  * The following macros define the class names for Tk Window types.
  */
 
-#define TK_WIN_TOPLEVEL_CLASS_NAME "TkTopLevel"
-#define TK_WIN_CHILD_CLASS_NAME "TkChild"
+#define TK_WIN_TOPLEVEL_CLASS_NAME TEXT("TkTopLevel")
+#define TK_WIN_CHILD_CLASS_NAME TEXT("TkChild")
 
 /*
  * The following variable is a translation table between X gc functions and
  * Win32 raster and BitBlt op modes.
  */
 
-extern int tkpWinRopModes[];
-extern int tkpWinBltModes[];
+MODULE_SCOPE const int tkpWinRopModes[];
+MODULE_SCOPE const int tkpWinBltModes[];
 
 /*
  * The following defines are used with TkWinGetBorderPixels to get the extra 2
@@ -146,86 +143,41 @@
 #include "tkIntPlatDecls.h"
 
 /*
- * We need to specially add the TkWinChildProc because of the special
- * prototype it has (doesn't fit into stubs schema)
- */
-
-#ifdef BUILD_tk
-#undef TCL_STORAGE_CLASS
-#define TCL_STORAGE_CLASS DLLEXPORT
-#endif
-
-EXTERN LRESULT CALLBACK  TkWinChildProc(HWND hwnd, UINT message,
-          WPARAM wParam, LPARAM lParam);
-
-/*
  * Special proc needed as tsd accessor function between
  * tkWinX.c:GenerateXEvent and tkWinClipboard.c:UpdateClipboard
  */
 
-EXTERN void    TkWinUpdatingClipboard(int mode);
+MODULE_SCOPE void TkWinUpdatingClipboard(int mode);
 
 /*
  * Used by tkWinDialog.c to associate the right icon with tk_messageBox
  */
 
-EXTERN HICON    TkWinGetIcon(Tk_Window tkw, DWORD iconsize);
+MODULE_SCOPE HICON TkWinGetIcon(Tk_Window tkw, DWORD iconsize);
 
 /*
  * Used by tkWinX.c on for certain system display change messages and cleanup
  * up containers
  */
 
-EXTERN void    TkWinDisplayChanged(Display *display);
-void      TkWinCleanupContainerList(void);
+MODULE_SCOPE void TkWinDisplayChanged(Display *display);
+MODULE_SCOPE void TkWinCleanupContainerList(void);
 
 /*
  * Used by tkWinWm.c for embedded menu handling. May become public.
  */
 
-EXTERN HWND    Tk_GetMenuHWND(Tk_Window tkwin);
-EXTERN HWND    Tk_GetEmbeddedMenuHWND(Tk_Window tkwin);
-
-/*
- * The following structure keeps track of whether we are using the multi-byte
- * or the wide-character interfaces to the operating system. System calls
- * should be made through the following function table.
- *
- * While some system calls need to use this A/W jump-table, it is not
- * necessary for all calls to do it, which is why you won't see this used
- * throughout the Tk code, but only in key areas. -- hobbs
- */
-
-typedef struct TkWinProcs {
-    int useWide;
-    LRESULT (WINAPI *callWindowProc)(WNDPROC lpPrevWndFunc, HWND hWnd,
-      UINT Msg, WPARAM wParam, LPARAM lParam);
-    LRESULT (WINAPI *defWindowProc)(HWND hWnd, UINT Msg, WPARAM wParam,
-      LPARAM lParam);
-    ATOM (WINAPI *registerClass)(const WNDCLASS *lpWndClass);
-    BOOL (WINAPI *setWindowText)(HWND hWnd, LPCTSTR lpString);
-    HWND (WINAPI *createWindowEx)(DWORD dwExStyle, LPCTSTR lpClassName,
-      LPCTSTR lpWindowName, DWORD dwStyle, int x, int y,
-      int nWidth, int nHeight, HWND hWndParent, HMENU hMenu,
-      HINSTANCE hInstance, LPVOID lpParam);
-    BOOL (WINAPI *insertMenu)(HMENU hMenu, UINT uPosition, UINT uFlags,
-      UINT uIDNewItem, LPCTSTR lpNewItem);
-    int (WINAPI *getWindowText)(HWND hWnd, LPCTSTR lpString, int nMaxCount);
-} TkWinProcs;
-
-EXTERN TkWinProcs *tkWinProcs;
-
-#undef TCL_STORAGE_CLASS
-#define TCL_STORAGE_CLASS DLLIMPORT
+MODULE_SCOPE HWND Tk_GetMenuHWND(Tk_Window tkwin);
+MODULE_SCOPE HWND Tk_GetEmbeddedMenuHWND(Tk_Window tkwin);
 
 /*
  * The following allows us to cache these encoding for multiple functions.
  */
 
 
-extern Tcl_Encoding  TkWinGetKeyInputEncoding(void);
-extern Tcl_Encoding  TkWinGetUnicodeEncoding(void);
-extern void    TkWinSetupSystemFonts(TkMainInfo *mainPtr);
+MODULE_SCOPE Tcl_Encoding  TkWinGetKeyInputEncoding(void);
+MODULE_SCOPE Tcl_Encoding  TkWinGetUnicodeEncoding(void);
+MODULE_SCOPE void    TkWinSetupSystemFonts(TkMainInfo *mainPtr);
 
 /*
  * Values returned by TkWinGetPlatformTheme.
@@ -238,19 +190,19 @@
  * The following is implemented in tkWinWm and used by tkWinEmbed.c
  */
 
-void      TkpWinToplevelWithDraw(TkWindow *winPtr);
-void      TkpWinToplevelIconify(TkWindow *winPtr);
-void      TkpWinToplevelDeiconify(TkWindow *winPtr);
-long      TkpWinToplevelIsControlledByWm(TkWindow *winPtr);
-long      TkpWinToplevelMove(TkWindow *winPtr, int x, int y);
-long      TkpWinToplevelOverrideRedirect(TkWindow *winPtr,
+MODULE_SCOPE void    TkpWinToplevelWithDraw(TkWindow *winPtr);
+MODULE_SCOPE void    TkpWinToplevelIconify(TkWindow *winPtr);
+MODULE_SCOPE void    TkpWinToplevelDeiconify(TkWindow *winPtr);
+MODULE_SCOPE long    TkpWinToplevelIsControlledByWm(TkWindow *winPtr);
+MODULE_SCOPE long    TkpWinToplevelMove(TkWindow *winPtr, int x, int y);
+MODULE_SCOPE long    TkpWinToplevelOverrideRedirect(TkWindow *winPtr,
           int reqValue);
-void      TkpWinToplevelDetachWindow(TkWindow *winPtr);
-int      TkpWmGetState(TkWindow *winPtr);
+MODULE_SCOPE void    TkpWinToplevelDetachWindow(TkWindow *winPtr);
+MODULE_SCOPE int    TkpWmGetState(TkWindow *winPtr);
 
 /*
  * The following functions are not present in old versions of Windows
- * API headers but are used in the Tk source to ensure 64bit 
+ * API headers but are used in the Tk source to ensure 64bit
  * compatability.
  */
 
diff -ru vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkWinPort.h vtk5.10/Utilities/TclTk/internals/tk8.6/tkWinPort.h
--- vtk5.10-orig/Utilities/TclTk/internals/tk8.6/tkWinPort.h	2019-02-01 14:00:06.000000000 +0100
+++ vtk5.10/Utilities/TclTk/internals/tk8.6/tkWinPort.h	2019-02-01 16:20:04.000000000 +0100
@@ -9,28 +9,28 @@
  *
  * See the file "license.terms" for information on usage and redistribution
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) Id
  */
 
 #ifndef _WINPORT
 #define _WINPORT
 
-#include <X11/Xlib.h>
-#include <X11/cursorfont.h>
-#include <X11/keysym.h>
-#include <X11/Xatom.h>
-#include <X11/Xutil.h>
+/*
+ *---------------------------------------------------------------------------
+ * The following sets of #includes and #ifdefs are required to get Tcl to
+ * compile under the windows compilers.
+ *---------------------------------------------------------------------------
+ */
 
-#include <malloc.h>
+#include <wchar.h>
+#include <io.h>
+#include <stdlib.h>
 #include <errno.h>
+#include <fcntl.h>
+#include <malloc.h>
 #include <ctype.h>
 #include <math.h>
-#include <stdlib.h>
 #include <string.h>
 #include <limits.h>
-#include <fcntl.h>
-#include <io.h>
 
 /*
  * Need to block out this include for building extensions with MetroWerks
@@ -42,16 +42,33 @@
 #endif
 
 #include <time.h>
-#ifdef __CYGWIN__
-#    define _T(x) L##x
-#else
-#    include <tchar.h>
-#endif
 
 #ifdef _MSC_VER
-#    define hypot _hypot
+#   ifndef hypot
+#  define hypot _hypot
+#   endif
 #endif /* _MSC_VER */
 
+/*
+ *  Pull in the typedef of TCHAR for windows.
+ */
+#include <tchar.h>
+#ifndef _TCHAR_DEFINED
+    /* Borland seems to forget to set this. */
+    typedef _TCHAR TCHAR;
+#   define _TCHAR_DEFINED
+#endif
+#if defined(_MSC_VER) && defined(__STDC__)
+    /* VS2005 SP1 misses this. See [Bug #3110161] */
+    typedef _TCHAR TCHAR;
+#endif
+
+#include <X11/Xlib.h>
+#include <X11/cursorfont.h>
+#include <X11/keysym.h>
+#include <X11/Xatom.h>
+#include <X11/Xutil.h>
+
 #ifndef __GNUC__
 #    define strncasecmp strnicmp
 #    define strcasecmp stricmp
@@ -81,27 +98,6 @@
 #endif /* _MSC_VER */
 
 /*
- * The following stubs implement various calls that don't do anything
- * under Windows.
- */
-
-#define TkpCmapStressed(tkwin,colormap) (0)
-#define XFlush(display)
-#define XGrabServer(display)
-#define XUngrabServer(display)
-#define TkpSync(display)
-
-/*
- * The following functions are implemented as macros under Windows.
- */
-
-#define XFree(data) {if ((data) != NULL) ckfree((char *) (data));}
-#define XNoOp(display) {display->request++;}
-#define XSynchronize(display, bool) {display->request++;}
-#define XSync(display, bool) {display->request++;}
-#define XVisualIDFromVisual(visual) (visual->visualid)
-
-/*
  * The following Tk functions are implemented as macros under Windows.
  */
 
@@ -109,7 +105,7 @@
   | ((p)->green & 0xff00) | (((p)->blue << 8) & 0xff0000)) | 0x20000000)
 
 /*
- * These calls implement native bitmaps which are not currently 
+ * These calls implement native bitmaps which are not currently
  * supported under Windows.  The macros eliminate the calls.
  */
 
@@ -117,13 +113,4 @@
 #define TkpCreateNativeBitmap(display, source) None
 #define TkpGetNativeAppBitmap(display, name, w, h) None
 
-/*
- * Define timezone for gettimeofday.
- */
-
-struct timezone {
-    int tz_minuteswest;
-    int tz_dsttime;
-};
-
 #endif /* _WINPORT */
Only in vtk5.10/Utilities/vtktiff: .tif_config.h.in.swp
diff -ru vtk5.10-orig/Utilities/vtktiff/tif_config.h.in vtk5.10/Utilities/vtktiff/tif_config.h.in
--- vtk5.10-orig/Utilities/vtktiff/tif_config.h.in	2019-02-01 14:00:05.000000000 +0100
+++ vtk5.10/Utilities/vtktiff/tif_config.h.in	2019-02-01 17:21:03.000000000 +0100
@@ -241,7 +241,7 @@
 /* Define to `__inline__' or `__inline' if that's what the C compiler
    calls it, or to nothing if 'inline' is not supported under any name.  */
 #ifndef __cplusplus
-#define inline
+//#define inline
 //#cmakedefine inline
 #endif
 
diff -ru vtk5.10-orig/Wrapping/Tcl/pkgIndex.tcl.in vtk5.10/Wrapping/Tcl/pkgIndex.tcl.in
--- vtk5.10-orig/Wrapping/Tcl/pkgIndex.tcl.in	2019-02-01 14:16:42.000000000 +0100
+++ vtk5.10/Wrapping/Tcl/pkgIndex.tcl.in	2019-02-01 14:23:39.000000000 +0100
@@ -5,7 +5,7 @@
     proc load_library_package {libName libPath {libPrefix {@VTK_TCL_LIBNAME_PREFIX@}}} {
       set libExt [info sharedlibextension]
       set currentDirectory [pwd]
-      set libFile [file join $libPath "$libPrefix$libName$libExt"]
+      set libFile [file normalize [file join $libPath "$libPrefix$libName$libExt"]]
       if {[catch "cd {$libPath}; load {$libFile}" errorMessage]} {
         puts $errorMessage
       }
